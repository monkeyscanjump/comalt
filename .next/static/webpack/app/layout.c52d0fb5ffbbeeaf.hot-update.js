"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/config/whitelist.ts":
/*!*********************************!*\
  !*** ./src/config/whitelist.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALLOWED_ADDRESSES: function() { return /* binding */ ALLOWED_ADDRESSES; },\n/* harmony export */   hasWhitelistedAddresses: function() { return /* binding */ hasWhitelistedAddresses; },\n/* harmony export */   hasWhitelistedAddressesAsync: function() { return /* binding */ hasWhitelistedAddressesAsync; },\n/* harmony export */   isAddressAllowed: function() { return /* binding */ isAddressAllowed; },\n/* harmony export */   isAddressAllowedAsync: function() { return /* binding */ isAddressAllowedAsync; }\n/* harmony export */ });\n/**\n * Whitelist configuration\n * Moved to server-side for security\n */ // A cache to store results and reduce API calls\nlet publicModeCache = {\n    value: null,\n    timestamp: 0\n};\n// Cache for address validation results (lasts for session only)\nconst addressValidationCache = new Map();\n/**\n * Check if any addresses are configured in the whitelist\n * Now uses a server API endpoint to check\n */ async function hasWhitelistedAddressesAsync() {\n    try {\n        // Check cache first (valid for 5 minutes)\n        const now = Date.now();\n        if (publicModeCache.value !== null && now - publicModeCache.timestamp < 300000) {\n            return !publicModeCache.value;\n        }\n        const response = await fetch(\"/api/auth/check-mode\");\n        if (!response.ok) throw new Error(\"Failed to check whitelist mode\");\n        const data = await response.json();\n        // Update cache\n        publicModeCache = {\n            value: data.isPublicMode,\n            timestamp: now\n        };\n        return !data.isPublicMode;\n    } catch (error) {\n        console.error(\"Error checking whitelist mode:\", error);\n        // Assume restricted mode by default for safety\n        return true;\n    }\n}\n/**\n * Synchronous version for components that can't use async\n * Uses cached result if available, otherwise assumes restricted mode\n */ function hasWhitelistedAddresses() {\n    // Use cached value if available\n    if (publicModeCache.value !== null) {\n        return !publicModeCache.value;\n    }\n    // Trigger async check to update cache for future calls\n    hasWhitelistedAddressesAsync().catch(console.error);\n    // Default to restricted mode for safety\n    return true;\n}\n/**\n * Check if a wallet address is allowed to access the application\n * Now uses a server API endpoint to validate\n * @param address Wallet address to check\n * @returns Promise resolving to boolean indicating if the address is allowed\n */ async function isAddressAllowedAsync(address) {\n    if (!address) return false;\n    try {\n        // Check cache first\n        if (addressValidationCache.has(address)) {\n            return addressValidationCache.get(address);\n        }\n        const response = await fetch(\"/api/auth/validate-address\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                address\n            })\n        });\n        if (!response.ok) throw new Error(\"Failed to validate address\");\n        const data = await response.json();\n        // Cache result\n        addressValidationCache.set(address, data.isAllowed);\n        return data.isAllowed;\n    } catch (error) {\n        console.error(\"Error validating address:\", error);\n        return false; // Default to not allowed for safety\n    }\n}\n/**\n * Synchronous version for backward compatibility\n * @param address Wallet address to check\n * @returns boolean indicating if the address is allowed based on cached result\n */ function isAddressAllowed(address) {\n    if (!address) return false;\n    // Use cached value if available\n    if (addressValidationCache.has(address)) {\n        return addressValidationCache.get(address);\n    }\n    // Trigger async check to update cache for future calls\n    isAddressAllowedAsync(address).catch(console.error);\n    // If we're in public mode (cached), all addresses are allowed\n    if (publicModeCache.value === true) {\n        return true;\n    }\n    // Default to not allowed if we have no cached data yet\n    return false;\n}\n// For backward compatibility with components that expect this variable\n// This will be empty on the client side for security, but the API will still work\nconst ALLOWED_ADDRESSES = [];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb25maWcvd2hpdGVsaXN0LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBRUQsZ0RBQWdEO0FBQ2hELElBQUlBLGtCQUFnRTtJQUNsRUMsT0FBTztJQUNQQyxXQUFXO0FBQ2I7QUFFQSxnRUFBZ0U7QUFDaEUsTUFBTUMseUJBQXlCLElBQUlDO0FBRW5DOzs7Q0FHQyxHQUNNLGVBQWVDO0lBQ3BCLElBQUk7UUFDRiwwQ0FBMEM7UUFDMUMsTUFBTUMsTUFBTUMsS0FBS0QsR0FBRztRQUNwQixJQUFJTixnQkFBZ0JDLEtBQUssS0FBSyxRQUFRLE1BQU9ELGdCQUFnQkUsU0FBUyxHQUFJLFFBQVE7WUFDaEYsT0FBTyxDQUFDRixnQkFBZ0JDLEtBQUs7UUFDL0I7UUFFQSxNQUFNTyxXQUFXLE1BQU1DLE1BQU07UUFDN0IsSUFBSSxDQUFDRCxTQUFTRSxFQUFFLEVBQUUsTUFBTSxJQUFJQyxNQUFNO1FBRWxDLE1BQU1DLE9BQU8sTUFBTUosU0FBU0ssSUFBSTtRQUVoQyxlQUFlO1FBQ2ZiLGtCQUFrQjtZQUNoQkMsT0FBT1csS0FBS0UsWUFBWTtZQUN4QlosV0FBV0k7UUFDYjtRQUVBLE9BQU8sQ0FBQ00sS0FBS0UsWUFBWTtJQUMzQixFQUFFLE9BQU9DLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLGtDQUFrQ0E7UUFDaEQsK0NBQStDO1FBQy9DLE9BQU87SUFDVDtBQUNGO0FBRUE7OztDQUdDLEdBQ00sU0FBU0U7SUFDZCxnQ0FBZ0M7SUFDaEMsSUFBSWpCLGdCQUFnQkMsS0FBSyxLQUFLLE1BQU07UUFDbEMsT0FBTyxDQUFDRCxnQkFBZ0JDLEtBQUs7SUFDL0I7SUFFQSx1REFBdUQ7SUFDdkRJLCtCQUErQmEsS0FBSyxDQUFDRixRQUFRRCxLQUFLO0lBRWxELHdDQUF3QztJQUN4QyxPQUFPO0FBQ1Q7QUFFQTs7Ozs7Q0FLQyxHQUNNLGVBQWVJLHNCQUFzQkMsT0FBa0M7SUFDNUUsSUFBSSxDQUFDQSxTQUFTLE9BQU87SUFFckIsSUFBSTtRQUNGLG9CQUFvQjtRQUNwQixJQUFJakIsdUJBQXVCa0IsR0FBRyxDQUFDRCxVQUFVO1lBQ3ZDLE9BQU9qQix1QkFBdUJtQixHQUFHLENBQUNGO1FBQ3BDO1FBRUEsTUFBTVosV0FBVyxNQUFNQyxNQUFNLDhCQUE4QjtZQUN6RGMsUUFBUTtZQUNSQyxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO2dCQUFFUDtZQUFRO1FBQ2pDO1FBRUEsSUFBSSxDQUFDWixTQUFTRSxFQUFFLEVBQUUsTUFBTSxJQUFJQyxNQUFNO1FBRWxDLE1BQU1DLE9BQU8sTUFBTUosU0FBU0ssSUFBSTtRQUVoQyxlQUFlO1FBQ2ZWLHVCQUF1QnlCLEdBQUcsQ0FBQ1IsU0FBU1IsS0FBS2lCLFNBQVM7UUFFbEQsT0FBT2pCLEtBQUtpQixTQUFTO0lBQ3ZCLEVBQUUsT0FBT2QsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsNkJBQTZCQTtRQUMzQyxPQUFPLE9BQU8sb0NBQW9DO0lBQ3BEO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ00sU0FBU2UsaUJBQWlCVixPQUFrQztJQUNqRSxJQUFJLENBQUNBLFNBQVMsT0FBTztJQUVyQixnQ0FBZ0M7SUFDaEMsSUFBSWpCLHVCQUF1QmtCLEdBQUcsQ0FBQ0QsVUFBVTtRQUN2QyxPQUFPakIsdUJBQXVCbUIsR0FBRyxDQUFDRjtJQUNwQztJQUVBLHVEQUF1RDtJQUN2REQsc0JBQXNCQyxTQUFTRixLQUFLLENBQUNGLFFBQVFELEtBQUs7SUFFbEQsOERBQThEO0lBQzlELElBQUlmLGdCQUFnQkMsS0FBSyxLQUFLLE1BQU07UUFDbEMsT0FBTztJQUNUO0lBRUEsdURBQXVEO0lBQ3ZELE9BQU87QUFDVDtBQUVBLHVFQUF1RTtBQUN2RSxrRkFBa0Y7QUFDM0UsTUFBTThCLG9CQUF1QyxFQUFFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbmZpZy93aGl0ZWxpc3QudHM/YjRjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFdoaXRlbGlzdCBjb25maWd1cmF0aW9uXG4gKiBNb3ZlZCB0byBzZXJ2ZXItc2lkZSBmb3Igc2VjdXJpdHlcbiAqL1xuXG4vLyBBIGNhY2hlIHRvIHN0b3JlIHJlc3VsdHMgYW5kIHJlZHVjZSBBUEkgY2FsbHNcbmxldCBwdWJsaWNNb2RlQ2FjaGU6IHsgdmFsdWU6IGJvb2xlYW4gfCBudWxsOyB0aW1lc3RhbXA6IG51bWJlciB9ID0ge1xuICB2YWx1ZTogbnVsbCxcbiAgdGltZXN0YW1wOiAwXG59O1xuXG4vLyBDYWNoZSBmb3IgYWRkcmVzcyB2YWxpZGF0aW9uIHJlc3VsdHMgKGxhc3RzIGZvciBzZXNzaW9uIG9ubHkpXG5jb25zdCBhZGRyZXNzVmFsaWRhdGlvbkNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIGJvb2xlYW4+KCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYW55IGFkZHJlc3NlcyBhcmUgY29uZmlndXJlZCBpbiB0aGUgd2hpdGVsaXN0XG4gKiBOb3cgdXNlcyBhIHNlcnZlciBBUEkgZW5kcG9pbnQgdG8gY2hlY2tcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhc1doaXRlbGlzdGVkQWRkcmVzc2VzQXN5bmMoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3QgKHZhbGlkIGZvciA1IG1pbnV0ZXMpXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAocHVibGljTW9kZUNhY2hlLnZhbHVlICE9PSBudWxsICYmIChub3cgLSBwdWJsaWNNb2RlQ2FjaGUudGltZXN0YW1wKSA8IDMwMDAwMCkge1xuICAgICAgcmV0dXJuICFwdWJsaWNNb2RlQ2FjaGUudmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9hdXRoL2NoZWNrLW1vZGUnKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjaGVjayB3aGl0ZWxpc3QgbW9kZScpO1xuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgIC8vIFVwZGF0ZSBjYWNoZVxuICAgIHB1YmxpY01vZGVDYWNoZSA9IHtcbiAgICAgIHZhbHVlOiBkYXRhLmlzUHVibGljTW9kZSxcbiAgICAgIHRpbWVzdGFtcDogbm93XG4gICAgfTtcblxuICAgIHJldHVybiAhZGF0YS5pc1B1YmxpY01vZGU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgd2hpdGVsaXN0IG1vZGU6JywgZXJyb3IpO1xuICAgIC8vIEFzc3VtZSByZXN0cmljdGVkIG1vZGUgYnkgZGVmYXVsdCBmb3Igc2FmZXR5XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91cyB2ZXJzaW9uIGZvciBjb21wb25lbnRzIHRoYXQgY2FuJ3QgdXNlIGFzeW5jXG4gKiBVc2VzIGNhY2hlZCByZXN1bHQgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYXNzdW1lcyByZXN0cmljdGVkIG1vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc1doaXRlbGlzdGVkQWRkcmVzc2VzKCk6IGJvb2xlYW4ge1xuICAvLyBVc2UgY2FjaGVkIHZhbHVlIGlmIGF2YWlsYWJsZVxuICBpZiAocHVibGljTW9kZUNhY2hlLnZhbHVlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuICFwdWJsaWNNb2RlQ2FjaGUudmFsdWU7XG4gIH1cblxuICAvLyBUcmlnZ2VyIGFzeW5jIGNoZWNrIHRvIHVwZGF0ZSBjYWNoZSBmb3IgZnV0dXJlIGNhbGxzXG4gIGhhc1doaXRlbGlzdGVkQWRkcmVzc2VzQXN5bmMoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcblxuICAvLyBEZWZhdWx0IHRvIHJlc3RyaWN0ZWQgbW9kZSBmb3Igc2FmZXR5XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgd2FsbGV0IGFkZHJlc3MgaXMgYWxsb3dlZCB0byBhY2Nlc3MgdGhlIGFwcGxpY2F0aW9uXG4gKiBOb3cgdXNlcyBhIHNlcnZlciBBUEkgZW5kcG9pbnQgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSBhZGRyZXNzIFdhbGxldCBhZGRyZXNzIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGFkZHJlc3MgaXMgYWxsb3dlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNBZGRyZXNzQWxsb3dlZEFzeW5jKGFkZHJlc3M6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgaWYgKCFhZGRyZXNzKSByZXR1cm4gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxuICAgIGlmIChhZGRyZXNzVmFsaWRhdGlvbkNhY2hlLmhhcyhhZGRyZXNzKSkge1xuICAgICAgcmV0dXJuIGFkZHJlc3NWYWxpZGF0aW9uQ2FjaGUuZ2V0KGFkZHJlc3MpITtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2F1dGgvdmFsaWRhdGUtYWRkcmVzcycsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGFkZHJlc3MgfSlcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHZhbGlkYXRlIGFkZHJlc3MnKTtcblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAvLyBDYWNoZSByZXN1bHRcbiAgICBhZGRyZXNzVmFsaWRhdGlvbkNhY2hlLnNldChhZGRyZXNzLCBkYXRhLmlzQWxsb3dlZCk7XG5cbiAgICByZXR1cm4gZGF0YS5pc0FsbG93ZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmFsaWRhdGluZyBhZGRyZXNzOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7IC8vIERlZmF1bHQgdG8gbm90IGFsbG93ZWQgZm9yIHNhZmV0eVxuICB9XG59XG5cbi8qKlxuICogU3luY2hyb25vdXMgdmVyc2lvbiBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICogQHBhcmFtIGFkZHJlc3MgV2FsbGV0IGFkZHJlc3MgdG8gY2hlY2tcbiAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgYWRkcmVzcyBpcyBhbGxvd2VkIGJhc2VkIG9uIGNhY2hlZCByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWRkcmVzc0FsbG93ZWQoYWRkcmVzczogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICBpZiAoIWFkZHJlc3MpIHJldHVybiBmYWxzZTtcblxuICAvLyBVc2UgY2FjaGVkIHZhbHVlIGlmIGF2YWlsYWJsZVxuICBpZiAoYWRkcmVzc1ZhbGlkYXRpb25DYWNoZS5oYXMoYWRkcmVzcykpIHtcbiAgICByZXR1cm4gYWRkcmVzc1ZhbGlkYXRpb25DYWNoZS5nZXQoYWRkcmVzcykhO1xuICB9XG5cbiAgLy8gVHJpZ2dlciBhc3luYyBjaGVjayB0byB1cGRhdGUgY2FjaGUgZm9yIGZ1dHVyZSBjYWxsc1xuICBpc0FkZHJlc3NBbGxvd2VkQXN5bmMoYWRkcmVzcykuY2F0Y2goY29uc29sZS5lcnJvcik7XG5cbiAgLy8gSWYgd2UncmUgaW4gcHVibGljIG1vZGUgKGNhY2hlZCksIGFsbCBhZGRyZXNzZXMgYXJlIGFsbG93ZWRcbiAgaWYgKHB1YmxpY01vZGVDYWNoZS52YWx1ZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gRGVmYXVsdCB0byBub3QgYWxsb3dlZCBpZiB3ZSBoYXZlIG5vIGNhY2hlZCBkYXRhIHlldFxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggY29tcG9uZW50cyB0aGF0IGV4cGVjdCB0aGlzIHZhcmlhYmxlXG4vLyBUaGlzIHdpbGwgYmUgZW1wdHkgb24gdGhlIGNsaWVudCBzaWRlIGZvciBzZWN1cml0eSwgYnV0IHRoZSBBUEkgd2lsbCBzdGlsbCB3b3JrXG5leHBvcnQgY29uc3QgQUxMT1dFRF9BRERSRVNTRVM6IHJlYWRvbmx5IHN0cmluZ1tdID0gW107XG4iXSwibmFtZXMiOlsicHVibGljTW9kZUNhY2hlIiwidmFsdWUiLCJ0aW1lc3RhbXAiLCJhZGRyZXNzVmFsaWRhdGlvbkNhY2hlIiwiTWFwIiwiaGFzV2hpdGVsaXN0ZWRBZGRyZXNzZXNBc3luYyIsIm5vdyIsIkRhdGUiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsImRhdGEiLCJqc29uIiwiaXNQdWJsaWNNb2RlIiwiZXJyb3IiLCJjb25zb2xlIiwiaGFzV2hpdGVsaXN0ZWRBZGRyZXNzZXMiLCJjYXRjaCIsImlzQWRkcmVzc0FsbG93ZWRBc3luYyIsImFkZHJlc3MiLCJoYXMiLCJnZXQiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXQiLCJpc0FsbG93ZWQiLCJpc0FkZHJlc3NBbGxvd2VkIiwiQUxMT1dFRF9BRERSRVNTRVMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/config/whitelist.ts\n"));

/***/ })

});