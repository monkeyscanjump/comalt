"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/contexts/auth/AuthProvider.tsx":
/*!********************************************!*\
  !*** ./src/contexts/auth/AuthProvider.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthContext */ \"(app-pages-browser)/./src/contexts/auth/AuthContext.tsx\");\n/* harmony import */ var _WalletService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WalletService */ \"(app-pages-browser)/./src/contexts/auth/WalletService.ts\");\n/* harmony import */ var _config_whitelist__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/config/whitelist */ \"(app-pages-browser)/./src/config/whitelist.ts\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst AuthProvider = (param)=>{\n    let { children } = param;\n    _s();\n    // Account and wallet states\n    const [walletAddress, setWalletAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [accounts, setAccounts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedAccount, setSelectedAccount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // UI states\n    const [isConnecting, setIsConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showAccountSelector, setShowAccountSelector] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Authentication states\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isAllowed, setIsAllowed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [token, setToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Signature states\n    const [wasSignatureRejected, setWasSignatureRejected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isRequestingSignature, setIsRequestingSignature] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Public mode detection - we'll use the sync version for initialization but update with async later\n    const isPublicMode = !(0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.hasWhitelistedAddresses)();\n    // Calculate derived states\n    const isWalletConnected = !!selectedAccount || !!walletAddress;\n    // Initialize auth state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const initAuth = async ()=>{\n            try {\n                // First check if we're in public mode - this will populate the cache\n                await (0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.hasWhitelistedAddressesAsync)();\n                // Restore connection from localStorage if available\n                const storedAddress = localStorage.getItem(\"wallet-address\");\n                const storedToken = localStorage.getItem(\"auth-token\");\n                if (storedAddress) {\n                    setWalletAddress(storedAddress);\n                    // Check if this specific address is allowed by the whitelist using the async API\n                    const addressIsAllowed = await (0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.isAddressAllowedAsync)(storedAddress);\n                    console.log(\"Restored address allowed:\", addressIsAllowed, storedAddress);\n                    // If address is not allowed, clear storage and don't proceed with auth\n                    if (!addressIsAllowed) {\n                        console.warn(\"Stored wallet address is not in whitelist, clearing data\");\n                        localStorage.removeItem(\"wallet-address\");\n                        localStorage.removeItem(\"auth-token\");\n                        localStorage.removeItem(\"user-data\");\n                        setWalletAddress(null);\n                        setIsLoading(false);\n                        return;\n                    }\n                    setIsAllowed(addressIsAllowed);\n                    // Get accounts if extension is available\n                    try {\n                        const isEnabled = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.enableWallet();\n                        if (isEnabled) {\n                            const walletAccounts = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.getAccounts();\n                            setAccounts(walletAccounts);\n                            // Find the stored account\n                            const account = walletAccounts.find((acc)=>acc.address === storedAddress);\n                            if (account) {\n                                setSelectedAccount(account);\n                            }\n                        }\n                    } catch (err) {\n                        console.warn(\"Failed to restore wallet connection:\", err);\n                    }\n                    // Restore auth state only if address is allowed\n                    if (storedToken && addressIsAllowed) {\n                        setToken(storedToken);\n                        setIsAuthenticated(true);\n                        try {\n                            // Restore user data if available\n                            const userData = localStorage.getItem(\"user-data\");\n                            if (userData) {\n                                setUser(JSON.parse(userData));\n                            }\n                        } catch (e) {\n                            console.warn(\"Failed to restore user data:\", e);\n                        }\n                    }\n                }\n            } catch (err) {\n                console.error(\"Error initializing auth:\", err);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        initAuth();\n    }, []);\n    // Connect wallet\n    const connect = async ()=>{\n        setIsConnecting(true);\n        setError(null);\n        try {\n            // Enable wallet extension\n            const isEnabled = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.enableWallet();\n            if (!isEnabled) {\n                throw new Error(\"Wallet extension not found or not enabled\");\n            }\n            // Get accounts\n            const walletAccounts = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.getAccounts();\n            if (!walletAccounts || walletAccounts.length === 0) {\n                throw new Error(\"No accounts found in wallet\");\n            }\n            // Update state\n            setAccounts(walletAccounts);\n            setShowAccountSelector(true);\n            return true;\n        } catch (err) {\n            console.error(\"Wallet connection error:\", err);\n            setError(err instanceof Error ? err.message : \"Failed to connect wallet\");\n            return false;\n        } finally{\n            setIsConnecting(false);\n        }\n    };\n    // Select account\n    const selectAccount = async (account)=>{\n        console.log(\"Account selected:\", account.address);\n        // Update state with selected account\n        setSelectedAccount(account);\n        setWalletAddress(account.address);\n        setShowAccountSelector(false);\n        // Save to localStorage\n        localStorage.setItem(\"wallet-address\", account.address);\n        try {\n            // Check if the SPECIFIC account is allowed by the whitelist using the async API\n            const addressIsAllowed = await (0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.isAddressAllowedAsync)(account.address);\n            console.log(\"Address allowed:\", addressIsAllowed);\n            setIsAllowed(addressIsAllowed);\n        } catch (error) {\n            console.error(\"Error checking whitelist:\", error);\n            setIsAllowed(false);\n        }\n        // Reset signature rejection state when selecting a new account\n        setWasSignatureRejected(false);\n    };\n    // Sign message\n    const signMessage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (message, accountOverride)=>{\n        const addressToUse = (accountOverride === null || accountOverride === void 0 ? void 0 : accountOverride.address) || (selectedAccount === null || selectedAccount === void 0 ? void 0 : selectedAccount.address) || walletAddress;\n        if (!addressToUse) return null;\n        try {\n            console.log(\"Signing message for address:\", addressToUse);\n            return await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.signMessage(addressToUse, message);\n        } catch (err) {\n            console.error(\"Signature error:\", err);\n            // Check if user rejected the signature\n            const isRejection = err instanceof Error && (err.message.toLowerCase().includes(\"reject\") || err.message.toLowerCase().includes(\"cancel\") || err.message.toLowerCase().includes(\"denied\") || err.message.toLowerCase().includes(\"user cancelled\"));\n            if (isRejection) {\n                console.log(\"Setting wasSignatureRejected to true\");\n                setWasSignatureRejected(true);\n            }\n            throw err;\n        }\n    }, [\n        selectedAccount,\n        walletAddress,\n        setWasSignatureRejected\n    ]);\n    // Request signature for authentication\n    const requestSignature = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (address)=>{\n        if (!address) return false;\n        try {\n            var _selectedAccount_meta;\n            // Add critical whitelist check using the async API\n            const addressIsAllowed = await (0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.isAddressAllowedAsync)(address);\n            if (!addressIsAllowed) {\n                console.error(\"Signature request blocked - address not in whitelist:\", address);\n                setError(\"This wallet address is not authorized\");\n                return false;\n            }\n            console.log(\"Starting signature request for address:\", address);\n            setIsRequestingSignature(true);\n            setWasSignatureRejected(false);\n            // Create a unique message\n            const message = \"Sign this message to authenticate with Download Manager: \".concat(Date.now());\n            // Get signature - this might throw if rejected\n            console.log(\"Requesting signature for message:\", message);\n            const signature = await signMessage(message);\n            if (!signature) {\n                console.warn(\"No signature returned\");\n                return false;\n            }\n            console.log(\"Signature received, authenticating...\");\n            // In a real app, you'd verify this signature on the server\n            const token = \"auth-token-\" + Date.now(); // Simplified token\n            setToken(token);\n            localStorage.setItem(\"auth-token\", token);\n            // Set authenticated state\n            setIsAuthenticated(true);\n            // Create user object\n            const user = {\n                id: \"1\",\n                address,\n                name: (selectedAccount === null || selectedAccount === void 0 ? void 0 : (_selectedAccount_meta = selectedAccount.meta) === null || _selectedAccount_meta === void 0 ? void 0 : _selectedAccount_meta.name) || null,\n                isAdmin: true,\n                createdAt: new Date(),\n                updatedAt: new Date(),\n                lastLoginAt: new Date()\n            };\n            setUser(user);\n            localStorage.setItem(\"user-data\", JSON.stringify(user));\n            return true;\n        } catch (err) {\n            console.error(\"Signature request failed:\", err);\n            // Check if this was a rejection\n            const isRejection = err instanceof Error && (err.message.toLowerCase().includes(\"reject\") || err.message.toLowerCase().includes(\"cancel\") || err.message.toLowerCase().includes(\"denied\"));\n            if (isRejection) {\n                console.log(\"Setting wasSignatureRejected to true\");\n                setWasSignatureRejected(true);\n            } else {\n                setError(err instanceof Error ? err.message : \"Failed to sign message\");\n            }\n            return false;\n        } finally{\n            setIsRequestingSignature(false);\n        }\n    }, [\n        selectedAccount,\n        setError,\n        setIsRequestingSignature,\n        setWasSignatureRejected,\n        signMessage,\n        setToken,\n        setIsAuthenticated,\n        setUser\n    ]);\n    // Effect to auto-trigger signature request\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Skip if still loading, already authenticated, requesting signature, or in public mode\n        // Also skip if signature was previously rejected - don't auto-retry after rejection\n        if (isLoading || isAuthenticated || isRequestingSignature || isPublicMode || wasSignatureRejected) {\n            return;\n        }\n        // If we have a connected wallet and it's allowed but not authenticated, request signature\n        if (selectedAccount && isAllowed && !isAuthenticated) {\n            console.log(\"[AUTH] Auto-triggering signature request for connected wallet:\", selectedAccount.address);\n            // Short delay to ensure all state is properly updated\n            const timer = setTimeout(async ()=>{\n                try {\n                    await requestSignature(selectedAccount.address);\n                } catch (err) {\n                    console.error(\"Failed to auto-request signature:\", err);\n                }\n            }, 300);\n            return ()=>clearTimeout(timer);\n        }\n    }, [\n        selectedAccount,\n        isAllowed,\n        isAuthenticated,\n        isLoading,\n        isRequestingSignature,\n        isPublicMode,\n        wasSignatureRejected,\n        requestSignature\n    ]);\n    // Refresh auth token\n    const refreshAuthToken = async ()=>{\n        if (!isAuthenticated || !walletAddress) return false;\n        try {\n            // Verify wallet is still allowed before refreshing token using the async API\n            const addressIsAllowed = await (0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.isAddressAllowedAsync)(walletAddress);\n            if (!addressIsAllowed) {\n                console.error(\"Token refresh blocked - address not in whitelist:\", walletAddress);\n                logout(); // Force logout if address no longer allowed\n                return false;\n            }\n            const newToken = \"refreshed-token-\" + Date.now();\n            setToken(newToken);\n            localStorage.setItem(\"auth-token\", newToken);\n            return true;\n        } catch (err) {\n            console.error(\"Token refresh failed:\", err);\n            return false;\n        }\n    };\n    // Logout\n    const logout = ()=>{\n        setSelectedAccount(null);\n        setWalletAddress(null);\n        setIsAuthenticated(false);\n        setIsAllowed(false);\n        setUser(null);\n        setToken(null);\n        setWasSignatureRejected(false);\n        // Clear localStorage\n        localStorage.removeItem(\"wallet-address\");\n        localStorage.removeItem(\"auth-token\");\n        localStorage.removeItem(\"user-data\");\n    };\n    // Reset rejection state\n    const resetRejectionState = ()=>{\n        setWasSignatureRejected(false);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_AuthContext__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Provider, {\n        value: {\n            // Account states\n            walletAddress,\n            accounts,\n            selectedAccount,\n            // UI states\n            error,\n            showAccountSelector,\n            setShowAccountSelector,\n            // User data\n            user,\n            token,\n            // Core methods\n            logout,\n            connect,\n            selectAccount,\n            signMessage,\n            refreshAuthToken,\n            requestSignature,\n            // Signature states\n            wasSignatureRejected,\n            isRequestingSignature,\n            resetRejectionState,\n            // Derived states\n            isPublicMode,\n            isWalletConnected,\n            isAuthenticated,\n            isLoading,\n            isAllowed,\n            isConnecting\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\crist\\\\monkeyscanjump\\\\download-manager\\\\src\\\\contexts\\\\auth\\\\AuthProvider.tsx\",\n        lineNumber: 365,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AuthProvider, \"dDVBMSeyiBL3mYdA12FjWrzJIhQ=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9hdXRoL0F1dGhQcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRWdFO0FBQ3hCO0FBQ1E7QUFNcEI7QUFJckIsTUFBTVMsZUFBZTtRQUFDLEVBQUVDLFFBQVEsRUFBaUM7O0lBQ3RFLDRCQUE0QjtJQUM1QixNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHWCwrQ0FBUUEsQ0FBZ0I7SUFDbEUsTUFBTSxDQUFDWSxVQUFVQyxZQUFZLEdBQUdiLCtDQUFRQSxDQUE0QixFQUFFO0lBQ3RFLE1BQU0sQ0FBQ2MsaUJBQWlCQyxtQkFBbUIsR0FBR2YsK0NBQVFBLENBQWlDO0lBRXZGLFlBQVk7SUFDWixNQUFNLENBQUNnQixjQUFjQyxnQkFBZ0IsR0FBR2pCLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ2tCLFdBQVdDLGFBQWEsR0FBR25CLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ29CLE9BQU9DLFNBQVMsR0FBR3JCLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUNzQixxQkFBcUJDLHVCQUF1QixHQUFHdkIsK0NBQVFBLENBQUM7SUFFL0Qsd0JBQXdCO0lBQ3hCLE1BQU0sQ0FBQ3dCLGlCQUFpQkMsbUJBQW1CLEdBQUd6QiwrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNLENBQUMwQixXQUFXQyxhQUFhLEdBQUczQiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUM0QixNQUFNQyxRQUFRLEdBQUc3QiwrQ0FBUUEsQ0FBYztJQUM5QyxNQUFNLENBQUM4QixPQUFPQyxTQUFTLEdBQUcvQiwrQ0FBUUEsQ0FBZ0I7SUFFbEQsbUJBQW1CO0lBQ25CLE1BQU0sQ0FBQ2dDLHNCQUFzQkMsd0JBQXdCLEdBQUdqQywrQ0FBUUEsQ0FBQztJQUNqRSxNQUFNLENBQUNrQyx1QkFBdUJDLHlCQUF5QixHQUFHbkMsK0NBQVFBLENBQUM7SUFFbkUsb0dBQW9HO0lBQ3BHLE1BQU1vQyxlQUFlLENB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SUFFQSxxQkFDRSw4REFBQzlCLG9EQUFXQSxDQUFDeUYsUUFBUTtRQUNuQkMsT0FBTztZQUNMLGlCQUFpQjtZQUNqQm5GO1lBQ0FFO1lBQ0FFO1lBRUEsWUFBWTtZQUNaTTtZQUNBRTtZQUNBQztZQUVBLFlBQVk7WUFDWks7WUFDQUU7WUFFQSxlQUFlO1lBQ2YyRDtZQUNBNUI7WUFDQUk7WUFDQUU7WUFDQXFCO1lBQ0FmO1lBRUEsbUJBQW1CO1lBQ25CekM7WUFDQUU7WUFDQXlEO1lBRUEsaUJBQWlCO1lBQ2pCdkQ7WUFDQUM7WUFDQWI7WUFDQU47WUFDQVE7WUFDQVY7UUFDRjtrQkFFQ1A7Ozs7OztBQUdQLEVBQUU7R0F2WVdEO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0cy9hdXRoL0F1dGhQcm92aWRlci50c3g/ODRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEF1dGhDb250ZXh0IGZyb20gJy4vQXV0aENvbnRleHQnO1xuaW1wb3J0IHsgV2FsbGV0U2VydmljZSB9IGZyb20gJy4vV2FsbGV0U2VydmljZSc7XG5pbXBvcnQge1xuICBoYXNXaGl0ZWxpc3RlZEFkZHJlc3NlcyxcbiAgaGFzV2hpdGVsaXN0ZWRBZGRyZXNzZXNBc3luYyxcbiAgaXNBZGRyZXNzQWxsb3dlZCBhcyBpc0FkZHJlc3NJbldoaXRlbGlzdCxcbiAgaXNBZGRyZXNzQWxsb3dlZEFzeW5jXG59IGZyb20gJ0AvY29uZmlnL3doaXRlbGlzdCc7XG5pbXBvcnQgdHlwZSB7IEluamVjdGVkQWNjb3VudFdpdGhNZXRhIH0gZnJvbSAnQHBvbGthZG90L2V4dGVuc2lvbi1pbmplY3QvdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBVc2VyIH0gZnJvbSAnQC90eXBlcy91c2VyJztcblxuZXhwb3J0IGNvbnN0IEF1dGhQcm92aWRlciA9ICh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSA9PiB7XG4gIC8vIEFjY291bnQgYW5kIHdhbGxldCBzdGF0ZXNcbiAgY29uc3QgW3dhbGxldEFkZHJlc3MsIHNldFdhbGxldEFkZHJlc3NdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFthY2NvdW50cywgc2V0QWNjb3VudHNdID0gdXNlU3RhdGU8SW5qZWN0ZWRBY2NvdW50V2l0aE1ldGFbXT4oW10pO1xuICBjb25zdCBbc2VsZWN0ZWRBY2NvdW50LCBzZXRTZWxlY3RlZEFjY291bnRdID0gdXNlU3RhdGU8SW5qZWN0ZWRBY2NvdW50V2l0aE1ldGEgfCBudWxsPihudWxsKTtcblxuICAvLyBVSSBzdGF0ZXNcbiAgY29uc3QgW2lzQ29ubmVjdGluZywgc2V0SXNDb25uZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc2hvd0FjY291bnRTZWxlY3Rvciwgc2V0U2hvd0FjY291bnRTZWxlY3Rvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gQXV0aGVudGljYXRpb24gc3RhdGVzXG4gIGNvbnN0IFtpc0F1dGhlbnRpY2F0ZWQsIHNldElzQXV0aGVudGljYXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0FsbG93ZWQsIHNldElzQWxsb3dlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFt1c2VyLCBzZXRVc2VyXSA9IHVzZVN0YXRlPFVzZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3Rva2VuLCBzZXRUb2tlbl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICAvLyBTaWduYXR1cmUgc3RhdGVzXG4gIGNvbnN0IFt3YXNTaWduYXR1cmVSZWplY3RlZCwgc2V0V2FzU2lnbmF0dXJlUmVqZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNSZXF1ZXN0aW5nU2lnbmF0dXJlLCBzZXRJc1JlcXVlc3RpbmdTaWduYXR1cmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIFB1YmxpYyBtb2RlIGRldGVjdGlvbiAtIHdlJ2xsIHVzZSB0aGUgc3luYyB2ZXJzaW9uIGZvciBpbml0aWFsaXphdGlvbiBidXQgdXBkYXRlIHdpdGggYXN5bmMgbGF0ZXJcbiAgY29uc3QgaXNQdWJsaWNNb2RlID0gIWhhc1doaXRlbGlzdGVkQWRkcmVzc2VzKCk7XG5cbiAgLy8gQ2FsY3VsYXRlIGRlcml2ZWQgc3RhdGVzXG4gIGNvbnN0IGlzV2FsbGV0Q29ubmVjdGVkID0gISFzZWxlY3RlZEFjY291bnQgfHwgISF3YWxsZXRBZGRyZXNzO1xuXG4gIC8vIEluaXRpYWxpemUgYXV0aCBzdGF0ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGluaXRBdXRoID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UncmUgaW4gcHVibGljIG1vZGUgLSB0aGlzIHdpbGwgcG9wdWxhdGUgdGhlIGNhY2hlXG4gICAgICAgIGF3YWl0IGhhc1doaXRlbGlzdGVkQWRkcmVzc2VzQXN5bmMoKTtcblxuICAgICAgICAvLyBSZXN0b3JlIGNvbm5lY3Rpb24gZnJvbSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgIGNvbnN0IHN0b3JlZEFkZHJlc3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsbGV0LWFkZHJlc3MnKTtcbiAgICAgICAgY29uc3Qgc3RvcmVkVG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aC10b2tlbicpO1xuXG4gICAgICAgIGlmIChzdG9yZWRBZGRyZXNzKSB7XG4gICAgICAgICAgc2V0V2FsbGV0QWRkcmVzcyhzdG9yZWRBZGRyZXNzKTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgc3BlY2lmaWMgYWRkcmVzcyBpcyBhbGxvd2VkIGJ5IHRoZSB3aGl0ZWxpc3QgdXNpbmcgdGhlIGFzeW5jIEFQSVxuICAgICAgICAgIGNvbnN0IGFkZHJlc3NJc0FsbG93ZWQgPSBhd2FpdCBpc0FkZHJlc3NBbGxvd2VkQXN5bmMoc3RvcmVkQWRkcmVzcyk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1Jlc3RvcmVkIGFkZHJlc3MgYWxsb3dlZDonLCBhZGRyZXNzSXNBbGxvd2VkLCBzdG9yZWRBZGRyZXNzKTtcblxuICAgICAgICAgIC8vIElmIGFkZHJlc3MgaXMgbm90IGFsbG93ZWQsIGNsZWFyIHN0b3JhZ2UgYW5kIGRvbid0IHByb2NlZWQgd2l0aCBhdXRoXG4gICAgICAgICAgaWYgKCFhZGRyZXNzSXNBbGxvd2VkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1N0b3JlZCB3YWxsZXQgYWRkcmVzcyBpcyBub3QgaW4gd2hpdGVsaXN0LCBjbGVhcmluZyBkYXRhJyk7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnd2FsbGV0LWFkZHJlc3MnKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoLXRva2VuJyk7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlci1kYXRhJyk7XG4gICAgICAgICAgICBzZXRXYWxsZXRBZGRyZXNzKG51bGwpO1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRJc0FsbG93ZWQoYWRkcmVzc0lzQWxsb3dlZCk7XG5cbiAgICAgICAgICAvLyBHZXQgYWNjb3VudHMgaWYgZXh0ZW5zaW9uIGlzIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpc0VuYWJsZWQgPSBhd2FpdCBXYWxsZXRTZXJ2aWNlLmVuYWJsZVdhbGxldCgpO1xuICAgICAgICAgICAgaWYgKGlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICBjb25zdCB3YWxsZXRBY2NvdW50cyA9IGF3YWl0IFdhbGxldFNlcnZpY2UuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgc2V0QWNjb3VudHMod2FsbGV0QWNjb3VudHMpO1xuXG4gICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHN0b3JlZCBhY2NvdW50XG4gICAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSB3YWxsZXRBY2NvdW50cy5maW5kKGFjYyA9PiBhY2MuYWRkcmVzcyA9PT0gc3RvcmVkQWRkcmVzcyk7XG4gICAgICAgICAgICAgIGlmIChhY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRBY2NvdW50KGFjY291bnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byByZXN0b3JlIHdhbGxldCBjb25uZWN0aW9uOicsIGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVzdG9yZSBhdXRoIHN0YXRlIG9ubHkgaWYgYWRkcmVzcyBpcyBhbGxvd2VkXG4gICAgICAgICAgaWYgKHN0b3JlZFRva2VuICYmIGFkZHJlc3NJc0FsbG93ZWQpIHtcbiAgICAgICAgICAgIHNldFRva2VuKHN0b3JlZFRva2VuKTtcbiAgICAgICAgICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB1c2VyIGRhdGEgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXItZGF0YScpO1xuICAgICAgICAgICAgICBpZiAodXNlckRhdGEpIHtcbiAgICAgICAgICAgICAgICBzZXRVc2VyKEpTT04ucGFyc2UodXNlckRhdGEpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byByZXN0b3JlIHVzZXIgZGF0YTonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgYXV0aDonLCBlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaW5pdEF1dGgoKTtcbiAgfSwgW10pO1xuXG4gIC8vIENvbm5lY3Qgd2FsbGV0XG4gIGNvbnN0IGNvbm5lY3QgPSBhc3luYyAoKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgc2V0SXNDb25uZWN0aW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEVuYWJsZSB3YWxsZXQgZXh0ZW5zaW9uXG4gICAgICBjb25zdCBpc0VuYWJsZWQgPSBhd2FpdCBXYWxsZXRTZXJ2aWNlLmVuYWJsZVdhbGxldCgpO1xuICAgICAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgZXh0ZW5zaW9uIG5vdCBmb3VuZCBvciBub3QgZW5hYmxlZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgYWNjb3VudHNcbiAgICAgIGNvbnN0IHdhbGxldEFjY291bnRzID0gYXdhaXQgV2FsbGV0U2VydmljZS5nZXRBY2NvdW50cygpO1xuICAgICAgaWYgKCF3YWxsZXRBY2NvdW50cyB8fCB3YWxsZXRBY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2NvdW50cyBmb3VuZCBpbiB3YWxsZXQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgICBzZXRBY2NvdW50cyh3YWxsZXRBY2NvdW50cyk7XG4gICAgICBzZXRTaG93QWNjb3VudFNlbGVjdG9yKHRydWUpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dhbGxldCBjb25uZWN0aW9uIGVycm9yOicsIGVycik7XG4gICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBjb25uZWN0IHdhbGxldCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0Nvbm5lY3RpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBTZWxlY3QgYWNjb3VudFxuICBjb25zdCBzZWxlY3RBY2NvdW50ID0gYXN5bmMgKGFjY291bnQ6IEluamVjdGVkQWNjb3VudFdpdGhNZXRhKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgY29uc29sZS5sb2coJ0FjY291bnQgc2VsZWN0ZWQ6JywgYWNjb3VudC5hZGRyZXNzKTtcblxuICAgIC8vIFVwZGF0ZSBzdGF0ZSB3aXRoIHNlbGVjdGVkIGFjY291bnRcbiAgICBzZXRTZWxlY3RlZEFjY291bnQoYWNjb3VudCk7XG4gICAgc2V0V2FsbGV0QWRkcmVzcyhhY2NvdW50LmFkZHJlc3MpO1xuICAgIHNldFNob3dBY2NvdW50U2VsZWN0b3IoZmFsc2UpO1xuXG4gICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2VcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnd2FsbGV0LWFkZHJlc3MnLCBhY2NvdW50LmFkZHJlc3MpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBTUEVDSUZJQyBhY2NvdW50IGlzIGFsbG93ZWQgYnkgdGhlIHdoaXRlbGlzdCB1c2luZyB0aGUgYXN5bmMgQVBJXG4gICAgICBjb25zdCBhZGRyZXNzSXNBbGxvd2VkID0gYXdhaXQgaXNBZGRyZXNzQWxsb3dlZEFzeW5jKGFjY291bnQuYWRkcmVzcyk7XG4gICAgICBjb25zb2xlLmxvZygnQWRkcmVzcyBhbGxvd2VkOicsIGFkZHJlc3NJc0FsbG93ZWQpO1xuICAgICAgc2V0SXNBbGxvd2VkKGFkZHJlc3NJc0FsbG93ZWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyB3aGl0ZWxpc3Q6JywgZXJyb3IpO1xuICAgICAgc2V0SXNBbGxvd2VkKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBzaWduYXR1cmUgcmVqZWN0aW9uIHN0YXRlIHdoZW4gc2VsZWN0aW5nIGEgbmV3IGFjY291bnRcbiAgICBzZXRXYXNTaWduYXR1cmVSZWplY3RlZChmYWxzZSk7XG4gIH07XG5cbiAgLy8gU2lnbiBtZXNzYWdlXG4gIGNvbnN0IHNpZ25NZXNzYWdlID0gdXNlQ2FsbGJhY2soYXN5bmMgKG1lc3NhZ2U6IHN0cmluZywgYWNjb3VudE92ZXJyaWRlPzogSW5qZWN0ZWRBY2NvdW50V2l0aE1ldGEpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+ID0+IHtcbiAgICBjb25zdCBhZGRyZXNzVG9Vc2UgPSBhY2NvdW50T3ZlcnJpZGU/LmFkZHJlc3MgfHwgc2VsZWN0ZWRBY2NvdW50Py5hZGRyZXNzIHx8IHdhbGxldEFkZHJlc3M7XG4gICAgaWYgKCFhZGRyZXNzVG9Vc2UpIHJldHVybiBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTaWduaW5nIG1lc3NhZ2UgZm9yIGFkZHJlc3M6JywgYWRkcmVzc1RvVXNlKTtcbiAgICAgIHJldHVybiBhd2FpdCBXYWxsZXRTZXJ2aWNlLnNpZ25NZXNzYWdlKGFkZHJlc3NUb1VzZSwgbWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTaWduYXR1cmUgZXJyb3I6JywgZXJyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdXNlciByZWplY3RlZCB0aGUgc2lnbmF0dXJlXG4gICAgICBjb25zdCBpc1JlamVjdGlvbiA9IGVyciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgIChlcnIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdyZWplY3QnKSB8fFxuICAgICAgICAgZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnY2FuY2VsJykgfHxcbiAgICAgICAgIGVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2RlbmllZCcpIHx8XG4gICAgICAgICBlcnIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCd1c2VyIGNhbmNlbGxlZCcpKTtcblxuICAgICAgaWYgKGlzUmVqZWN0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIHdhc1NpZ25hdHVyZVJlamVjdGVkIHRvIHRydWUnKTtcbiAgICAgICAgc2V0V2FzU2lnbmF0dXJlUmVqZWN0ZWQodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH0sIFtzZWxlY3RlZEFjY291bnQsIHdhbGxldEFkZHJlc3MsIHNldFdhc1NpZ25hdHVyZVJlamVjdGVkXSk7XG5cbiAgLy8gUmVxdWVzdCBzaWduYXR1cmUgZm9yIGF1dGhlbnRpY2F0aW9uXG4gIGNvbnN0IHJlcXVlc3RTaWduYXR1cmUgPSB1c2VDYWxsYmFjayhhc3luYyAoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgaWYgKCFhZGRyZXNzKSByZXR1cm4gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgLy8gQWRkIGNyaXRpY2FsIHdoaXRlbGlzdCBjaGVjayB1c2luZyB0aGUgYXN5bmMgQVBJXG4gICAgICBjb25zdCBhZGRyZXNzSXNBbGxvd2VkID0gYXdhaXQgaXNBZGRyZXNzQWxsb3dlZEFzeW5jKGFkZHJlc3MpO1xuICAgICAgaWYgKCFhZGRyZXNzSXNBbGxvd2VkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpZ25hdHVyZSByZXF1ZXN0IGJsb2NrZWQgLSBhZGRyZXNzIG5vdCBpbiB3aGl0ZWxpc3Q6JywgYWRkcmVzcyk7XG4gICAgICAgIHNldEVycm9yKCdUaGlzIHdhbGxldCBhZGRyZXNzIGlzIG5vdCBhdXRob3JpemVkJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHNpZ25hdHVyZSByZXF1ZXN0IGZvciBhZGRyZXNzOicsIGFkZHJlc3MpO1xuICAgICAgc2V0SXNSZXF1ZXN0aW5nU2lnbmF0dXJlKHRydWUpO1xuICAgICAgc2V0V2FzU2lnbmF0dXJlUmVqZWN0ZWQoZmFsc2UpO1xuXG4gICAgICAvLyBDcmVhdGUgYSB1bmlxdWUgbWVzc2FnZVxuICAgICAgY29uc3QgbWVzc2FnZSA9IGBTaWduIHRoaXMgbWVzc2FnZSB0byBhdXRoZW50aWNhdGUgd2l0aCBEb3dubG9hZCBNYW5hZ2VyOiAke0RhdGUubm93KCl9YDtcblxuICAgICAgLy8gR2V0IHNpZ25hdHVyZSAtIHRoaXMgbWlnaHQgdGhyb3cgaWYgcmVqZWN0ZWRcbiAgICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0aW5nIHNpZ25hdHVyZSBmb3IgbWVzc2FnZTonLCBtZXNzYWdlKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25NZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgICBpZiAoIXNpZ25hdHVyZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ05vIHNpZ25hdHVyZSByZXR1cm5lZCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdTaWduYXR1cmUgcmVjZWl2ZWQsIGF1dGhlbnRpY2F0aW5nLi4uJyk7XG4gICAgICAvLyBJbiBhIHJlYWwgYXBwLCB5b3UnZCB2ZXJpZnkgdGhpcyBzaWduYXR1cmUgb24gdGhlIHNlcnZlclxuICAgICAgY29uc3QgdG9rZW4gPSAnYXV0aC10b2tlbi0nICsgRGF0ZS5ub3coKTsgLy8gU2ltcGxpZmllZCB0b2tlblxuICAgICAgc2V0VG9rZW4odG9rZW4pO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGgtdG9rZW4nLCB0b2tlbik7XG5cbiAgICAgIC8vIFNldCBhdXRoZW50aWNhdGVkIHN0YXRlXG4gICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XG5cbiAgICAgIC8vIENyZWF0ZSB1c2VyIG9iamVjdFxuICAgICAgY29uc3QgdXNlciA9IHtcbiAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgbmFtZTogc2VsZWN0ZWRBY2NvdW50Py5tZXRhPy5uYW1lIHx8IG51bGwsXG4gICAgICAgIGlzQWRtaW46IHRydWUsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICBsYXN0TG9naW5BdDogbmV3IERhdGUoKVxuICAgICAgfTtcblxuICAgICAgc2V0VXNlcih1c2VyKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyLWRhdGEnLCBKU09OLnN0cmluZ2lmeSh1c2VyKSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignU2lnbmF0dXJlIHJlcXVlc3QgZmFpbGVkOicsIGVycik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgd2FzIGEgcmVqZWN0aW9uXG4gICAgICBjb25zdCBpc1JlamVjdGlvbiA9IGVyciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgIChlcnIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdyZWplY3QnKSB8fFxuICAgICAgICAgZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnY2FuY2VsJykgfHxcbiAgICAgICAgIGVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2RlbmllZCcpKTtcblxuICAgICAgaWYgKGlzUmVqZWN0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIHdhc1NpZ25hdHVyZVJlamVjdGVkIHRvIHRydWUnKTtcbiAgICAgICAgc2V0V2FzU2lnbmF0dXJlUmVqZWN0ZWQodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBzaWduIG1lc3NhZ2UnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1JlcXVlc3RpbmdTaWduYXR1cmUoZmFsc2UpO1xuICAgIH1cbiAgfSwgW1xuICAgIHNlbGVjdGVkQWNjb3VudCxcbiAgICBzZXRFcnJvcixcbiAgICBzZXRJc1JlcXVlc3RpbmdTaWduYXR1cmUsXG4gICAgc2V0V2FzU2lnbmF0dXJlUmVqZWN0ZWQsXG4gICAgc2lnbk1lc3NhZ2UsXG4gICAgc2V0VG9rZW4sXG4gICAgc2V0SXNBdXRoZW50aWNhdGVkLFxuICAgIHNldFVzZXJcbiAgXSk7XG5cbiAgLy8gRWZmZWN0IHRvIGF1dG8tdHJpZ2dlciBzaWduYXR1cmUgcmVxdWVzdFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNraXAgaWYgc3RpbGwgbG9hZGluZywgYWxyZWFkeSBhdXRoZW50aWNhdGVkLCByZXF1ZXN0aW5nIHNpZ25hdHVyZSwgb3IgaW4gcHVibGljIG1vZGVcbiAgICAvLyBBbHNvIHNraXAgaWYgc2lnbmF0dXJlIHdhcyBwcmV2aW91c2x5IHJlamVjdGVkIC0gZG9uJ3QgYXV0by1yZXRyeSBhZnRlciByZWplY3Rpb25cbiAgICBpZiAoaXNMb2FkaW5nIHx8IGlzQXV0aGVudGljYXRlZCB8fCBpc1JlcXVlc3RpbmdTaWduYXR1cmUgfHwgaXNQdWJsaWNNb2RlIHx8IHdhc1NpZ25hdHVyZVJlamVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIGNvbm5lY3RlZCB3YWxsZXQgYW5kIGl0J3MgYWxsb3dlZCBidXQgbm90IGF1dGhlbnRpY2F0ZWQsIHJlcXVlc3Qgc2lnbmF0dXJlXG4gICAgaWYgKHNlbGVjdGVkQWNjb3VudCAmJiBpc0FsbG93ZWQgJiYgIWlzQXV0aGVudGljYXRlZCkge1xuICAgICAgY29uc29sZS5sb2coJ1tBVVRIXSBBdXRvLXRyaWdnZXJpbmcgc2lnbmF0dXJlIHJlcXVlc3QgZm9yIGNvbm5lY3RlZCB3YWxsZXQ6Jywgc2VsZWN0ZWRBY2NvdW50LmFkZHJlc3MpO1xuXG4gICAgICAvLyBTaG9ydCBkZWxheSB0byBlbnN1cmUgYWxsIHN0YXRlIGlzIHByb3Blcmx5IHVwZGF0ZWRcbiAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgcmVxdWVzdFNpZ25hdHVyZShzZWxlY3RlZEFjY291bnQuYWRkcmVzcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBhdXRvLXJlcXVlc3Qgc2lnbmF0dXJlOicsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCk7XG5cbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIH1cbiAgfSwgW1xuICAgIHNlbGVjdGVkQWNjb3VudCxcbiAgICBpc0FsbG93ZWQsXG4gICAgaXNBdXRoZW50aWNhdGVkLFxuICAgIGlzTG9hZGluZyxcbiAgICBpc1JlcXVlc3RpbmdTaWduYXR1cmUsXG4gICAgaXNQdWJsaWNNb2RlLFxuICAgIHdhc1NpZ25hdHVyZVJlamVjdGVkLFxuICAgIHJlcXVlc3RTaWduYXR1cmVcbiAgXSk7XG5cbiAgLy8gUmVmcmVzaCBhdXRoIHRva2VuXG4gIGNvbnN0IHJlZnJlc2hBdXRoVG9rZW4gPSBhc3luYyAoKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgaWYgKCFpc0F1dGhlbnRpY2F0ZWQgfHwgIXdhbGxldEFkZHJlc3MpIHJldHVybiBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBWZXJpZnkgd2FsbGV0IGlzIHN0aWxsIGFsbG93ZWQgYmVmb3JlIHJlZnJlc2hpbmcgdG9rZW4gdXNpbmcgdGhlIGFzeW5jIEFQSVxuICAgICAgY29uc3QgYWRkcmVzc0lzQWxsb3dlZCA9IGF3YWl0IGlzQWRkcmVzc0FsbG93ZWRBc3luYyh3YWxsZXRBZGRyZXNzKTtcbiAgICAgIGlmICghYWRkcmVzc0lzQWxsb3dlZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiByZWZyZXNoIGJsb2NrZWQgLSBhZGRyZXNzIG5vdCBpbiB3aGl0ZWxpc3Q6Jywgd2FsbGV0QWRkcmVzcyk7XG4gICAgICAgIGxvZ291dCgpOyAvLyBGb3JjZSBsb2dvdXQgaWYgYWRkcmVzcyBubyBsb25nZXIgYWxsb3dlZFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1Rva2VuID0gJ3JlZnJlc2hlZC10b2tlbi0nICsgRGF0ZS5ub3coKTtcbiAgICAgIHNldFRva2VuKG5ld1Rva2VuKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoLXRva2VuJywgbmV3VG9rZW4pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiByZWZyZXNoIGZhaWxlZDonLCBlcnIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvLyBMb2dvdXRcbiAgY29uc3QgbG9nb3V0ID0gKCkgPT4ge1xuICAgIHNldFNlbGVjdGVkQWNjb3VudChudWxsKTtcbiAgICBzZXRXYWxsZXRBZGRyZXNzKG51bGwpO1xuICAgIHNldElzQXV0aGVudGljYXRlZChmYWxzZSk7XG4gICAgc2V0SXNBbGxvd2VkKGZhbHNlKTtcbiAgICBzZXRVc2VyKG51bGwpO1xuICAgIHNldFRva2VuKG51bGwpO1xuICAgIHNldFdhc1NpZ25hdHVyZVJlamVjdGVkKGZhbHNlKTtcblxuICAgIC8vIENsZWFyIGxvY2FsU3RvcmFnZVxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd3YWxsZXQtYWRkcmVzcycpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoLXRva2VuJyk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXItZGF0YScpO1xuICB9O1xuXG4gIC8vIFJlc2V0IHJlamVjdGlvbiBzdGF0ZVxuICBjb25zdCByZXNldFJlamVjdGlvblN0YXRlID0gKCkgPT4ge1xuICAgIHNldFdhc1NpZ25hdHVyZVJlamVjdGVkKGZhbHNlKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxBdXRoQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgLy8gQWNjb3VudCBzdGF0ZXNcbiAgICAgICAgd2FsbGV0QWRkcmVzcyxcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIHNlbGVjdGVkQWNjb3VudCxcblxuICAgICAgICAvLyBVSSBzdGF0ZXNcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHNob3dBY2NvdW50U2VsZWN0b3IsXG4gICAgICAgIHNldFNob3dBY2NvdW50U2VsZWN0b3IsXG5cbiAgICAgICAgLy8gVXNlciBkYXRhXG4gICAgICAgIHVzZXIsXG4gICAgICAgIHRva2VuLFxuXG4gICAgICAgIC8vIENvcmUgbWV0aG9kc1xuICAgICAgICBsb2dvdXQsXG4gICAgICAgIGNvbm5lY3QsXG4gICAgICAgIHNlbGVjdEFjY291bnQsXG4gICAgICAgIHNpZ25NZXNzYWdlLFxuICAgICAgICByZWZyZXNoQXV0aFRva2VuLFxuICAgICAgICByZXF1ZXN0U2lnbmF0dXJlLFxuXG4gICAgICAgIC8vIFNpZ25hdHVyZSBzdGF0ZXNcbiAgICAgICAgd2FzU2lnbmF0dXJlUmVqZWN0ZWQsXG4gICAgICAgIGlzUmVxdWVzdGluZ1NpZ25hdHVyZSxcbiAgICAgICAgcmVzZXRSZWplY3Rpb25TdGF0ZSxcblxuICAgICAgICAvLyBEZXJpdmVkIHN0YXRlc1xuICAgICAgICBpc1B1YmxpY01vZGUsXG4gICAgICAgIGlzV2FsbGV0Q29ubmVjdGVkLFxuICAgICAgICBpc0F1dGhlbnRpY2F0ZWQsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgaXNBbGxvd2VkLFxuICAgICAgICBpc0Nvbm5lY3RpbmdcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXV0aENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIkF1dGhDb250ZXh0IiwiV2FsbGV0U2VydmljZSIsImhhc1doaXRlbGlzdGVkQWRkcmVzc2VzIiwiaGFzV2hpdGVsaXN0ZWRBZGRyZXNzZXNBc3luYyIsImlzQWRkcmVzc0FsbG93ZWRBc3luYyIsIkF1dGhQcm92aWRlciIsImNoaWxkcmVuIiwid2FsbGV0QWRkcmVzcyIsInNldFdhbGxldEFkZHJlc3MiLCJhY2NvdW50cyIsInNldEFjY291bnRzIiwic2VsZWN0ZWRBY2NvdW50Iiwic2V0U2VsZWN0ZWRBY2NvdW50IiwiaXNDb25uZWN0aW5nIiwic2V0SXNDb25uZWN0aW5nIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsInNob3dBY2NvdW50U2VsZWN0b3IiLCJzZXRTaG93QWNjb3VudFNlbGVjdG9yIiwiaXNBdXRoZW50aWNhdGVkIiwic2V0SXNBdXRoZW50aWNhdGVkIiwiaXNBbGxvd2VkIiwic2V0SXNBbGxvd2VkIiwidXNlciIsInNldFVzZXIiLCJ0b2tlbiIsInNldFRva2VuIiwid2FzU2lnbmF0dXJlUmVqZWN0ZWQiLCJzZXRXYXNTaWduYXR1cmVSZWplY3RlZCIsImlzUmVxdWVzdGluZ1NpZ25hdHVyZSIsInNldElzUmVxdWVzdGluZ1NpZ25hdHVyZSIsImlzUHVibGljTW9kZSIsImlzV2FsbGV0Q29ubmVjdGVkIiwiaW5pdEF1dGgiLCJzdG9yZWRBZGRyZXNzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInN0b3JlZFRva2VuIiwiYWRkcmVzc0lzQWxsb3dlZCIsImNvbnNvbGUiLCJsb2ciLCJ3YXJuIiwicmVtb3ZlSXRlbSIsImlzRW5hYmxlZCIsImVuYWJsZVdhbGxldCIsIndhbGxldEFjY291bnRzIiwiZ2V0QWNjb3VudHMiLCJhY2NvdW50IiwiZmluZCIsImFjYyIsImFkZHJlc3MiLCJlcnIiLCJ1c2VyRGF0YSIsIkpTT04iLCJwYXJzZSIsImUiLCJjb25uZWN0IiwiRXJyb3IiLCJsZW5ndGgiLCJtZXNzYWdlIiwic2VsZWN0QWNjb3VudCIsInNldEl0ZW0iLCJzaWduTWVzc2FnZSIsImFjY291bnRPdmVycmlkZSIsImFkZHJlc3NUb1VzZSIsImlzUmVqZWN0aW9uIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsInJlcXVlc3RTaWduYXR1cmUiLCJEYXRlIiwibm93Iiwic2lnbmF0dXJlIiwiaWQiLCJuYW1lIiwibWV0YSIsImlzQWRtaW4iLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJsYXN0TG9naW5BdCIsInN0cmluZ2lmeSIsInRpbWVyIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJlZnJlc2hBdXRoVG9rZW4iLCJsb2dvdXQiLCJuZXdUb2tlbiIsInJlc2V0UmVqZWN0aW9uU3RhdGUiLCJQcm92aWRlciIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/auth/AuthProvider.tsx\n"));

/***/ })

});