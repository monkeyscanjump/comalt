"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/contexts/auth/AuthProvider.tsx":
/*!********************************************!*\
  !*** ./src/contexts/auth/AuthProvider.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthContext */ \"(app-pages-browser)/./src/contexts/auth/AuthContext.tsx\");\n/* harmony import */ var _WalletService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WalletService */ \"(app-pages-browser)/./src/contexts/auth/WalletService.ts\");\n/* harmony import */ var _config_whitelist__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/config/whitelist */ \"(app-pages-browser)/./src/config/whitelist.ts\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst AuthProvider = (param)=>{\n    let { children } = param;\n    var _selectedAccount_address;\n    _s();\n    // Account and wallet states\n    const [walletAddress, setWalletAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [accounts, setAccounts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedAccount, setSelectedAccount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // UI states\n    const [isConnecting, setIsConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showAccountSelector, setShowAccountSelector] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Authentication states\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isAllowed, setIsAllowed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [token, setToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Signature states\n    const [wasSignatureRejected, setWasSignatureRejected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isRequestingSignature, setIsRequestingSignature] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Public mode detection\n    const isPublicMode = !(0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.hasWhitelistedAddresses)();\n    // Calculate derived states\n    const isWalletConnected = !!selectedAccount || !!walletAddress;\n    // Initialize auth state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const initAuth = async ()=>{\n            try {\n                // Restore connection from localStorage if available\n                const storedAddress = localStorage.getItem(\"wallet-address\");\n                const storedToken = localStorage.getItem(\"auth-token\");\n                if (storedAddress) {\n                    setWalletAddress(storedAddress);\n                    // Get accounts if extension is available\n                    try {\n                        const isEnabled = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.enableWallet();\n                        if (isEnabled) {\n                            const walletAccounts = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.getAccounts();\n                            setAccounts(walletAccounts);\n                            // Find the stored account\n                            const account = walletAccounts.find((acc)=>acc.address === storedAddress);\n                            if (account) {\n                                setSelectedAccount(account);\n                                // We set isAllowed here too to ensure the auto-signature effect can run\n                                setIsAllowed(isPublicMode || (0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.hasWhitelistedAddresses)());\n                            }\n                        }\n                    } catch (err) {\n                        console.warn(\"Failed to restore wallet connection:\", err);\n                    }\n                    // Restore auth state\n                    if (storedToken) {\n                        setToken(storedToken);\n                        setIsAuthenticated(true);\n                        setIsAllowed(true);\n                        try {\n                            // Optionally restore user data if you have it\n                            const userData = localStorage.getItem(\"user-data\");\n                            if (userData) {\n                                setUser(JSON.parse(userData));\n                            }\n                        } catch (e) {\n                            console.warn(\"Failed to restore user data:\", e);\n                        }\n                    }\n                }\n            } catch (err) {\n                console.error(\"Error initializing auth:\", err);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        initAuth();\n    }, []);\n    // NEW EFFECT: Automatically trigger signature request when wallet is connected but not authenticated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Skip if still loading, already authenticated, requesting signature, or in public mode\n        if (isLoading || isAuthenticated || isRequestingSignature || isPublicMode) {\n            return;\n        }\n        // If we have a connected wallet and it's allowed but not authenticated, request signature\n        if (selectedAccount && isAllowed && !isAuthenticated) {\n            console.log(\"[AUTH] Auto-triggering signature request for connected wallet:\", selectedAccount.address);\n            // Short delay to ensure all state is properly updated\n            const timer = setTimeout(async ()=>{\n                try {\n                    await requestSignature(selectedAccount.address);\n                } catch (err) {\n                    console.error(\"Failed to auto-request signature:\", err);\n                }\n            }, 300);\n            return ()=>clearTimeout(timer);\n        }\n    }, [\n        selectedAccount,\n        isAllowed,\n        isAuthenticated,\n        isLoading,\n        isRequestingSignature,\n        isPublicMode\n    ]);\n    // Connect wallet\n    const connect = async ()=>{\n        setIsConnecting(true);\n        setError(null);\n        try {\n            // Enable wallet extension\n            const isEnabled = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.enableWallet();\n            if (!isEnabled) {\n                throw new Error(\"Wallet extension not found or not enabled\");\n            }\n            // Get accounts\n            const walletAccounts = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.getAccounts();\n            if (!walletAccounts || walletAccounts.length === 0) {\n                throw new Error(\"No accounts found in wallet\");\n            }\n            // Update state\n            setAccounts(walletAccounts);\n            setShowAccountSelector(true);\n            return true;\n        } catch (err) {\n            console.error(\"Wallet connection error:\", err);\n            setError(err instanceof Error ? err.message : \"Failed to connect wallet\");\n            return false;\n        } finally{\n            setIsConnecting(false);\n        }\n    };\n    // Select account\n    const selectAccount = async (account)=>{\n        console.log(\"Account selected:\", account.address);\n        // Update state with selected account\n        setSelectedAccount(account);\n        setWalletAddress(account.address);\n        setShowAccountSelector(false);\n        // Save to localStorage\n        localStorage.setItem(\"wallet-address\", account.address);\n        // Check if the account is allowed\n        const allowed = isPublicMode || (0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.hasWhitelistedAddresses)();\n        setIsAllowed(allowed);\n    // NOTE: We no longer need to manually trigger requestSignature here\n    // The useEffect we added above will handle this automatically\n    };\n    // Sign message\n    const signMessage = async (message, accountOverride)=>{\n        const addressToUse = (accountOverride === null || accountOverride === void 0 ? void 0 : accountOverride.address) || (selectedAccount === null || selectedAccount === void 0 ? void 0 : selectedAccount.address) || walletAddress;\n        if (!addressToUse) return null;\n        try {\n            console.log(\"Signing message for address:\", addressToUse);\n            return await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.signMessage(addressToUse, message);\n        } catch (err) {\n            console.error(\"Signature error:\", err);\n            // Check if user rejected the signature\n            const isRejection = err instanceof Error && (err.message.toLowerCase().includes(\"reject\") || err.message.toLowerCase().includes(\"cancel\") || err.message.toLowerCase().includes(\"denied\") || err.message.toLowerCase().includes(\"user cancelled\"));\n            if (isRejection) {\n                console.log(\"Setting wasSignatureRejected to true\");\n                setWasSignatureRejected(true);\n            }\n            throw err;\n        }\n    };\n    // Request signature for authentication\n    const requestSignature = async (address)=>{\n        if (!address) return false;\n        console.log(\"Starting signature request for address:\", address);\n        setIsRequestingSignature(true);\n        setWasSignatureRejected(false);\n        try {\n            var _selectedAccount_meta;\n            // Create a unique message\n            const message = \"Sign this message to authenticate with Download Manager: \".concat(Date.now());\n            // Get signature - this might throw if rejected\n            console.log(\"Requesting signature for message:\", message);\n            const signature = await signMessage(message);\n            if (!signature) {\n                console.warn(\"No signature returned\");\n                return false;\n            }\n            console.log(\"Signature received, authenticating...\");\n            // In a real app, you'd verify this signature on the server\n            // For demo, we'll just set a token\n            const demoToken = \"demo-auth-token-\" + Date.now();\n            setToken(demoToken);\n            localStorage.setItem(\"auth-token\", demoToken);\n            // Set authenticated state\n            setIsAuthenticated(true);\n            // Create demo user\n            const demoUser = {\n                id: \"1\",\n                address,\n                name: (selectedAccount === null || selectedAccount === void 0 ? void 0 : (_selectedAccount_meta = selectedAccount.meta) === null || _selectedAccount_meta === void 0 ? void 0 : _selectedAccount_meta.name) || null,\n                isAdmin: true,\n                createdAt: new Date(),\n                updatedAt: new Date(),\n                lastLoginAt: new Date()\n            };\n            setUser(demoUser);\n            localStorage.setItem(\"user-data\", JSON.stringify(demoUser));\n            return true;\n        } catch (err) {\n            console.error(\"Signature request failed:\", err);\n            // Check if this was a rejection\n            const isRejection = err instanceof Error && (err.message.toLowerCase().includes(\"reject\") || err.message.toLowerCase().includes(\"cancel\") || err.message.toLowerCase().includes(\"denied\"));\n            if (isRejection) {\n                console.log(\"Setting wasSignatureRejected to true\");\n                setWasSignatureRejected(true);\n            } else {\n                setError(err instanceof Error ? err.message : \"Failed to sign message\");\n            }\n            return false;\n        } finally{\n            setIsRequestingSignature(false);\n        }\n    };\n    // Refresh auth token\n    const refreshAuthToken = async ()=>{\n        // In a real app, this would refresh the token with the server\n        // For demo, we'll just generate a new token\n        if (!isAuthenticated || !walletAddress) return false;\n        try {\n            const newToken = \"refreshed-token-\" + Date.now();\n            setToken(newToken);\n            localStorage.setItem(\"auth-token\", newToken);\n            return true;\n        } catch (err) {\n            console.error(\"Token refresh failed:\", err);\n            return false;\n        }\n    };\n    // Logout\n    const logout = ()=>{\n        setSelectedAccount(null);\n        setWalletAddress(null);\n        setIsAuthenticated(false);\n        setIsAllowed(false);\n        setUser(null);\n        setToken(null);\n        // Clear localStorage\n        localStorage.removeItem(\"wallet-address\");\n        localStorage.removeItem(\"auth-token\");\n        localStorage.removeItem(\"user-data\");\n    };\n    // Reset rejection state\n    const resetRejectionState = ()=>{\n        setWasSignatureRejected(false);\n    };\n    // Debug state\n    console.log(\"[AUTH STATE]\", {\n        isWalletConnected,\n        isAuthenticated,\n        isAllowed,\n        wasSignatureRejected,\n        walletAddress: (walletAddress === null || walletAddress === void 0 ? void 0 : walletAddress.slice(0, 8)) + \"...\",\n        account: (selectedAccount === null || selectedAccount === void 0 ? void 0 : (_selectedAccount_address = selectedAccount.address) === null || _selectedAccount_address === void 0 ? void 0 : _selectedAccount_address.slice(0, 8)) + \"...\"\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_AuthContext__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Provider, {\n        value: {\n            // Account states\n            walletAddress,\n            accounts,\n            selectedAccount,\n            // UI states\n            error,\n            showAccountSelector,\n            setShowAccountSelector,\n            // User data\n            user,\n            token,\n            // Core methods\n            logout,\n            connect,\n            selectAccount,\n            signMessage,\n            refreshAuthToken,\n            requestSignature,\n            // Signature states\n            wasSignatureRejected,\n            isRequestingSignature,\n            resetRejectionState,\n            // Derived states\n            isPublicMode,\n            isWalletConnected,\n            isAuthenticated,\n            isLoading,\n            isAllowed,\n            isConnecting\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\crist\\\\monkeyscanjump\\\\download-manager\\\\src\\\\contexts\\\\auth\\\\AuthProvider.tsx\",\n        lineNumber: 314,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AuthProvider, \"p202UMbLtbWP78v8tUbUMqPJJ14=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9hdXRoL0F1dGhQcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRW1EO0FBQ1g7QUFDUTtBQUNhO0FBSXRELE1BQU1NLGVBQWU7UUFBQyxFQUFFQyxRQUFRLEVBQWlDO1FBNFMzREM7O0lBM1NYLDRCQUE0QjtJQUM1QixNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHVCwrQ0FBUUEsQ0FBZ0I7SUFDbEUsTUFBTSxDQUFDVSxVQUFVQyxZQUFZLEdBQUdYLCtDQUFRQSxDQUE0QixFQUFFO0lBQ3RFLE1BQU0sQ0FBQ08saUJBQWlCSyxtQkFBbUIsR0FBR1osK0NBQVFBLENBQWlDO0lBRXZGLFlBQVk7SUFDWixNQUFNLENBQUNhLGNBQWNDLGdCQUFnQixHQUFHZCwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUNlLFdBQVdDLGFBQWEsR0FBR2hCLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ2lCLE9BQU9DLFNBQVMsR0FBR2xCLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUNtQixxQkFBcUJDLHVCQUF1QixHQUFHcEIsK0NBQVFBLENBQUM7SUFFL0Qsd0JBQXdCO0lBQ3hCLE1BQU0sQ0FBQ3FCLGlCQUFpQkMsbUJBQW1CLEdBQUd0QiwrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNLENBQUN1QixXQUFXQyxhQUFhLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUN5QixNQUFNQyxRQUFRLEdBQUcxQiwrQ0FBUUEsQ0FBYztJQUM5QyxNQUFNLENBQUMyQixPQUFPQyxTQUFTLEdBQUc1QiwrQ0FBUUEsQ0FBZ0I7SUFFbEQsbUJBQW1CO0lBQ25CLE1BQU0sQ0FBQzZCLHNCQUFzQkMsd0JBQXdCLEdBQUc5QiwrQ0FBUUEsQ0FBQztJQUNqRSxNQUFNLENBQUMrQix1QkFBdUJDLHlCQUF5QixHQUFHaEMsK0NBQVFBLENBQUM7SUFFbkUsd0JBQXdCO0lBQ3hCLE1BQU1pQyxlQUFl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QnBELGFBQWFvRCxVQUFVLENBQUM7SUFDMUI7SUFFQSx3QkFBd0I7SUFDeEIsTUFBTUMsc0JBQXNCO1FBQzFCNUQsd0JBQXdCO0lBQzFCO0lBRUEsY0FBYztJQUNkbUIsUUFBUU0sR0FBRyxDQUFDLGdCQUFnQjtRQUMxQnJCO1FBQ0FiO1FBQ0FFO1FBQ0FNO1FBQ0FyQixlQUFlQSxDQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWVtRixLQUFLLENBQUMsR0FBRyxNQUFLO1FBQzVDL0MsU0FBU3JDLENBQUFBLDRCQUFBQSx1Q0FBQUEsMkJBQUFBLGdCQUFpQndDLE9BQU8sY0FBeEJ4QywrQ0FBQUEseUJBQTBCb0YsS0FBSyxDQUFDLEdBQUcsTUFBSztJQUNuRDtJQUVBLHFCQUNFLDhEQUFDekYsb0RBQVdBLENBQUMwRixRQUFRO1FBQ25CQyxPQUFPO1lBQ0wsaUJBQWlCO1lBQ2pCckY7WUFDQUU7WUFDQUg7WUFFQSxZQUFZO1lBQ1pVO1lBQ0FFO1lBQ0FDO1lBRUEsWUFBWTtZQUNaSztZQUNBRTtZQUVBLGVBQWU7WUFDZjZEO1lBQ0E1QjtZQUNBSTtZQUNBRztZQUNBbUI7WUFDQTVCO1lBRUEsbUJBQW1CO1lBQ25CN0I7WUFDQUU7WUFDQTJEO1lBRUEsaUJBQWlCO1lBQ2pCekQ7WUFDQUM7WUFDQWI7WUFDQU47WUFDQVE7WUFDQVY7UUFDRjtrQkFFQ1A7Ozs7OztBQUdQLEVBQUU7R0F6VldEO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0cy9hdXRoL0F1dGhQcm92aWRlci50c3g/ODRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQXV0aENvbnRleHQgZnJvbSAnLi9BdXRoQ29udGV4dCc7XG5pbXBvcnQgeyBXYWxsZXRTZXJ2aWNlIH0gZnJvbSAnLi9XYWxsZXRTZXJ2aWNlJztcbmltcG9ydCB7IGhhc1doaXRlbGlzdGVkQWRkcmVzc2VzIH0gZnJvbSAnQC9jb25maWcvd2hpdGVsaXN0JztcbmltcG9ydCB0eXBlIHsgSW5qZWN0ZWRBY2NvdW50V2l0aE1ldGEgfSBmcm9tICdAcG9sa2Fkb3QvZXh0ZW5zaW9uLWluamVjdC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7IFVzZXIgfSBmcm9tICdAL3R5cGVzL3VzZXInO1xuXG5leHBvcnQgY29uc3QgQXV0aFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pID0+IHtcbiAgLy8gQWNjb3VudCBhbmQgd2FsbGV0IHN0YXRlc1xuICBjb25zdCBbd2FsbGV0QWRkcmVzcywgc2V0V2FsbGV0QWRkcmVzc10gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2FjY291bnRzLCBzZXRBY2NvdW50c10gPSB1c2VTdGF0ZTxJbmplY3RlZEFjY291bnRXaXRoTWV0YVtdPihbXSk7XG4gIGNvbnN0IFtzZWxlY3RlZEFjY291bnQsIHNldFNlbGVjdGVkQWNjb3VudF0gPSB1c2VTdGF0ZTxJbmplY3RlZEFjY291bnRXaXRoTWV0YSB8IG51bGw+KG51bGwpO1xuXG4gIC8vIFVJIHN0YXRlc1xuICBjb25zdCBbaXNDb25uZWN0aW5nLCBzZXRJc0Nvbm5lY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzaG93QWNjb3VudFNlbGVjdG9yLCBzZXRTaG93QWNjb3VudFNlbGVjdG9yXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBBdXRoZW50aWNhdGlvbiBzdGF0ZXNcbiAgY29uc3QgW2lzQXV0aGVudGljYXRlZCwgc2V0SXNBdXRoZW50aWNhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzQWxsb3dlZCwgc2V0SXNBbGxvd2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbdG9rZW4sIHNldFRva2VuXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIFNpZ25hdHVyZSBzdGF0ZXNcbiAgY29uc3QgW3dhc1NpZ25hdHVyZVJlamVjdGVkLCBzZXRXYXNTaWduYXR1cmVSZWplY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc1JlcXVlc3RpbmdTaWduYXR1cmUsIHNldElzUmVxdWVzdGluZ1NpZ25hdHVyZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gUHVibGljIG1vZGUgZGV0ZWN0aW9uXG4gIGNvbnN0IGlzUHVibGljTW9kZSA9ICFoYXNXaGl0ZWxpc3RlZEFkZHJlc3NlcygpO1xuXG4gIC8vIENhbGN1bGF0ZSBkZXJpdmVkIHN0YXRlc1xuICBjb25zdCBpc1dhbGxldENvbm5lY3RlZCA9ICEhc2VsZWN0ZWRBY2NvdW50IHx8ICEhd2FsbGV0QWRkcmVzcztcblxuICAvLyBJbml0aWFsaXplIGF1dGggc3RhdGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpbml0QXV0aCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFJlc3RvcmUgY29ubmVjdGlvbiBmcm9tIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgY29uc3Qgc3RvcmVkQWRkcmVzcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxsZXQtYWRkcmVzcycpO1xuICAgICAgICBjb25zdCBzdG9yZWRUb2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoLXRva2VuJyk7XG5cbiAgICAgICAgaWYgKHN0b3JlZEFkZHJlc3MpIHtcbiAgICAgICAgICBzZXRXYWxsZXRBZGRyZXNzKHN0b3JlZEFkZHJlc3MpO1xuXG4gICAgICAgICAgLy8gR2V0IGFjY291bnRzIGlmIGV4dGVuc2lvbiBpcyBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNFbmFibGVkID0gYXdhaXQgV2FsbGV0U2VydmljZS5lbmFibGVXYWxsZXQoKTtcbiAgICAgICAgICAgIGlmIChpc0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0QWNjb3VudHMgPSBhd2FpdCBXYWxsZXRTZXJ2aWNlLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICAgIHNldEFjY291bnRzKHdhbGxldEFjY291bnRzKTtcblxuICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBzdG9yZWQgYWNjb3VudFxuICAgICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gd2FsbGV0QWNjb3VudHMuZmluZChhY2MgPT4gYWNjLmFkZHJlc3MgPT09IHN0b3JlZEFkZHJlc3MpO1xuICAgICAgICAgICAgICBpZiAoYWNjb3VudCkge1xuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkQWNjb3VudChhY2NvdW50KTtcbiAgICAgICAgICAgICAgICAvLyBXZSBzZXQgaXNBbGxvd2VkIGhlcmUgdG9vIHRvIGVuc3VyZSB0aGUgYXV0by1zaWduYXR1cmUgZWZmZWN0IGNhbiBydW5cbiAgICAgICAgICAgICAgICBzZXRJc0FsbG93ZWQoaXNQdWJsaWNNb2RlIHx8IGhhc1doaXRlbGlzdGVkQWRkcmVzc2VzKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byByZXN0b3JlIHdhbGxldCBjb25uZWN0aW9uOicsIGVycik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVzdG9yZSBhdXRoIHN0YXRlXG4gICAgICAgICAgaWYgKHN0b3JlZFRva2VuKSB7XG4gICAgICAgICAgICBzZXRUb2tlbihzdG9yZWRUb2tlbik7XG4gICAgICAgICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XG4gICAgICAgICAgICBzZXRJc0FsbG93ZWQodHJ1ZSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIE9wdGlvbmFsbHkgcmVzdG9yZSB1c2VyIGRhdGEgaWYgeW91IGhhdmUgaXRcbiAgICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlci1kYXRhJyk7XG4gICAgICAgICAgICAgIGlmICh1c2VyRGF0YSkge1xuICAgICAgICAgICAgICAgIHNldFVzZXIoSlNPTi5wYXJzZSh1c2VyRGF0YSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJlc3RvcmUgdXNlciBkYXRhOicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBhdXRoOicsIGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0QXV0aCgpO1xuICB9LCBbXSk7XG5cbiAgLy8gTkVXIEVGRkVDVDogQXV0b21hdGljYWxseSB0cmlnZ2VyIHNpZ25hdHVyZSByZXF1ZXN0IHdoZW4gd2FsbGV0IGlzIGNvbm5lY3RlZCBidXQgbm90IGF1dGhlbnRpY2F0ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTa2lwIGlmIHN0aWxsIGxvYWRpbmcsIGFscmVhZHkgYXV0aGVudGljYXRlZCwgcmVxdWVzdGluZyBzaWduYXR1cmUsIG9yIGluIHB1YmxpYyBtb2RlXG4gICAgaWYgKGlzTG9hZGluZyB8fCBpc0F1dGhlbnRpY2F0ZWQgfHwgaXNSZXF1ZXN0aW5nU2lnbmF0dXJlIHx8IGlzUHVibGljTW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgYSBjb25uZWN0ZWQgd2FsbGV0IGFuZCBpdCdzIGFsbG93ZWQgYnV0IG5vdCBhdXRoZW50aWNhdGVkLCByZXF1ZXN0IHNpZ25hdHVyZVxuICAgIGlmIChzZWxlY3RlZEFjY291bnQgJiYgaXNBbGxvd2VkICYmICFpc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbQVVUSF0gQXV0by10cmlnZ2VyaW5nIHNpZ25hdHVyZSByZXF1ZXN0IGZvciBjb25uZWN0ZWQgd2FsbGV0OicsIHNlbGVjdGVkQWNjb3VudC5hZGRyZXNzKTtcblxuICAgICAgLy8gU2hvcnQgZGVsYXkgdG8gZW5zdXJlIGFsbCBzdGF0ZSBpcyBwcm9wZXJseSB1cGRhdGVkXG4gICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHJlcXVlc3RTaWduYXR1cmUoc2VsZWN0ZWRBY2NvdW50LmFkZHJlc3MpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYXV0by1yZXF1ZXN0IHNpZ25hdHVyZTonLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuXG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB9XG4gIH0sIFtzZWxlY3RlZEFjY291bnQsIGlzQWxsb3dlZCwgaXNBdXRoZW50aWNhdGVkLCBpc0xvYWRpbmcsIGlzUmVxdWVzdGluZ1NpZ25hdHVyZSwgaXNQdWJsaWNNb2RlXSk7XG5cbiAgLy8gQ29ubmVjdCB3YWxsZXRcbiAgY29uc3QgY29ubmVjdCA9IGFzeW5jICgpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICBzZXRJc0Nvbm5lY3RpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gRW5hYmxlIHdhbGxldCBleHRlbnNpb25cbiAgICAgIGNvbnN0IGlzRW5hYmxlZCA9IGF3YWl0IFdhbGxldFNlcnZpY2UuZW5hYmxlV2FsbGV0KCk7XG4gICAgICBpZiAoIWlzRW5hYmxlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBleHRlbnNpb24gbm90IGZvdW5kIG9yIG5vdCBlbmFibGVkJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBhY2NvdW50c1xuICAgICAgY29uc3Qgd2FsbGV0QWNjb3VudHMgPSBhd2FpdCBXYWxsZXRTZXJ2aWNlLmdldEFjY291bnRzKCk7XG4gICAgICBpZiAoIXdhbGxldEFjY291bnRzIHx8IHdhbGxldEFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY291bnRzIGZvdW5kIGluIHdhbGxldCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgIHNldEFjY291bnRzKHdhbGxldEFjY291bnRzKTtcbiAgICAgIHNldFNob3dBY2NvdW50U2VsZWN0b3IodHJ1ZSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignV2FsbGV0IGNvbm5lY3Rpb24gZXJyb3I6JywgZXJyKTtcbiAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGNvbm5lY3Qgd2FsbGV0Jyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzQ29ubmVjdGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbGVjdCBhY2NvdW50XG4gIGNvbnN0IHNlbGVjdEFjY291bnQgPSBhc3luYyAoYWNjb3VudDogSW5qZWN0ZWRBY2NvdW50V2l0aE1ldGEpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBjb25zb2xlLmxvZygnQWNjb3VudCBzZWxlY3RlZDonLCBhY2NvdW50LmFkZHJlc3MpO1xuXG4gICAgLy8gVXBkYXRlIHN0YXRlIHdpdGggc2VsZWN0ZWQgYWNjb3VudFxuICAgIHNldFNlbGVjdGVkQWNjb3VudChhY2NvdW50KTtcbiAgICBzZXRXYWxsZXRBZGRyZXNzKGFjY291bnQuYWRkcmVzcyk7XG4gICAgc2V0U2hvd0FjY291bnRTZWxlY3RvcihmYWxzZSk7XG5cbiAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd3YWxsZXQtYWRkcmVzcycsIGFjY291bnQuYWRkcmVzcyk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgYWNjb3VudCBpcyBhbGxvd2VkXG4gICAgY29uc3QgYWxsb3dlZCA9IGlzUHVibGljTW9kZSB8fCBoYXNXaGl0ZWxpc3RlZEFkZHJlc3NlcygpO1xuICAgIHNldElzQWxsb3dlZChhbGxvd2VkKTtcblxuICAgIC8vIE5PVEU6IFdlIG5vIGxvbmdlciBuZWVkIHRvIG1hbnVhbGx5IHRyaWdnZXIgcmVxdWVzdFNpZ25hdHVyZSBoZXJlXG4gICAgLy8gVGhlIHVzZUVmZmVjdCB3ZSBhZGRlZCBhYm92ZSB3aWxsIGhhbmRsZSB0aGlzIGF1dG9tYXRpY2FsbHlcbiAgfTtcblxuICAvLyBTaWduIG1lc3NhZ2VcbiAgY29uc3Qgc2lnbk1lc3NhZ2UgPSBhc3luYyAobWVzc2FnZTogc3RyaW5nLCBhY2NvdW50T3ZlcnJpZGU/OiBJbmplY3RlZEFjY291bnRXaXRoTWV0YSk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4gPT4ge1xuICAgIGNvbnN0IGFkZHJlc3NUb1VzZSA9IGFjY291bnRPdmVycmlkZT8uYWRkcmVzcyB8fCBzZWxlY3RlZEFjY291bnQ/LmFkZHJlc3MgfHwgd2FsbGV0QWRkcmVzcztcbiAgICBpZiAoIWFkZHJlc3NUb1VzZSkgcmV0dXJuIG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ1NpZ25pbmcgbWVzc2FnZSBmb3IgYWRkcmVzczonLCBhZGRyZXNzVG9Vc2UpO1xuICAgICAgcmV0dXJuIGF3YWl0IFdhbGxldFNlcnZpY2Uuc2lnbk1lc3NhZ2UoYWRkcmVzc1RvVXNlLCBtZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpZ25hdHVyZSBlcnJvcjonLCBlcnIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB1c2VyIHJlamVjdGVkIHRoZSBzaWduYXR1cmVcbiAgICAgIGNvbnN0IGlzUmVqZWN0aW9uID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgKGVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3JlamVjdCcpIHx8XG4gICAgICAgICBlcnIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdjYW5jZWwnKSB8fFxuICAgICAgICAgZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZGVuaWVkJykgfHxcbiAgICAgICAgIGVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3VzZXIgY2FuY2VsbGVkJykpO1xuXG4gICAgICBpZiAoaXNSZWplY3Rpb24pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1NldHRpbmcgd2FzU2lnbmF0dXJlUmVqZWN0ZWQgdG8gdHJ1ZScpO1xuICAgICAgICBzZXRXYXNTaWduYXR1cmVSZWplY3RlZCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXF1ZXN0IHNpZ25hdHVyZSBmb3IgYXV0aGVudGljYXRpb25cbiAgY29uc3QgcmVxdWVzdFNpZ25hdHVyZSA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICBpZiAoIWFkZHJlc3MpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBzaWduYXR1cmUgcmVxdWVzdCBmb3IgYWRkcmVzczonLCBhZGRyZXNzKTtcbiAgICBzZXRJc1JlcXVlc3RpbmdTaWduYXR1cmUodHJ1ZSk7XG4gICAgc2V0V2FzU2lnbmF0dXJlUmVqZWN0ZWQoZmFsc2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBtZXNzYWdlXG4gICAgICBjb25zdCBtZXNzYWdlID0gYFNpZ24gdGhpcyBtZXNzYWdlIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIERvd25sb2FkIE1hbmFnZXI6ICR7RGF0ZS5ub3coKX1gO1xuXG4gICAgICAvLyBHZXQgc2lnbmF0dXJlIC0gdGhpcyBtaWdodCB0aHJvdyBpZiByZWplY3RlZFxuICAgICAgY29uc29sZS5sb2coJ1JlcXVlc3Rpbmcgc2lnbmF0dXJlIGZvciBtZXNzYWdlOicsIG1lc3NhZ2UpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbk1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgIGlmICghc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTm8gc2lnbmF0dXJlIHJldHVybmVkJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coJ1NpZ25hdHVyZSByZWNlaXZlZCwgYXV0aGVudGljYXRpbmcuLi4nKTtcbiAgICAgIC8vIEluIGEgcmVhbCBhcHAsIHlvdSdkIHZlcmlmeSB0aGlzIHNpZ25hdHVyZSBvbiB0aGUgc2VydmVyXG4gICAgICAvLyBGb3IgZGVtbywgd2UnbGwganVzdCBzZXQgYSB0b2tlblxuICAgICAgY29uc3QgZGVtb1Rva2VuID0gJ2RlbW8tYXV0aC10b2tlbi0nICsgRGF0ZS5ub3coKTtcbiAgICAgIHNldFRva2VuKGRlbW9Ub2tlbik7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYXV0aC10b2tlbicsIGRlbW9Ub2tlbik7XG5cbiAgICAgIC8vIFNldCBhdXRoZW50aWNhdGVkIHN0YXRlXG4gICAgICBzZXRJc0F1dGhlbnRpY2F0ZWQodHJ1ZSk7XG5cbiAgICAgIC8vIENyZWF0ZSBkZW1vIHVzZXJcbiAgICAgIGNvbnN0IGRlbW9Vc2VyID0ge1xuICAgICAgICBpZDogJzEnLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBuYW1lOiBzZWxlY3RlZEFjY291bnQ/Lm1ldGE/Lm5hbWUgfHwgbnVsbCxcbiAgICAgICAgaXNBZG1pbjogdHJ1ZSxcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIGxhc3RMb2dpbkF0OiBuZXcgRGF0ZSgpXG4gICAgICB9O1xuXG4gICAgICBzZXRVc2VyKGRlbW9Vc2VyKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyLWRhdGEnLCBKU09OLnN0cmluZ2lmeShkZW1vVXNlcikpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpZ25hdHVyZSByZXF1ZXN0IGZhaWxlZDonLCBlcnIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHdhcyBhIHJlamVjdGlvblxuICAgICAgY29uc3QgaXNSZWplY3Rpb24gPSBlcnIgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAoZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygncmVqZWN0JykgfHxcbiAgICAgICAgIGVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2NhbmNlbCcpIHx8XG4gICAgICAgICBlcnIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdkZW5pZWQnKSk7XG5cbiAgICAgIGlmIChpc1JlamVjdGlvbikge1xuICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZyB3YXNTaWduYXR1cmVSZWplY3RlZCB0byB0cnVlJyk7XG4gICAgICAgIHNldFdhc1NpZ25hdHVyZVJlamVjdGVkKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gc2lnbiBtZXNzYWdlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNSZXF1ZXN0aW5nU2lnbmF0dXJlKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVmcmVzaCBhdXRoIHRva2VuXG4gIGNvbnN0IHJlZnJlc2hBdXRoVG9rZW4gPSBhc3luYyAoKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgLy8gSW4gYSByZWFsIGFwcCwgdGhpcyB3b3VsZCByZWZyZXNoIHRoZSB0b2tlbiB3aXRoIHRoZSBzZXJ2ZXJcbiAgICAvLyBGb3IgZGVtbywgd2UnbGwganVzdCBnZW5lcmF0ZSBhIG5ldyB0b2tlblxuICAgIGlmICghaXNBdXRoZW50aWNhdGVkIHx8ICF3YWxsZXRBZGRyZXNzKSByZXR1cm4gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV3VG9rZW4gPSAncmVmcmVzaGVkLXRva2VuLScgKyBEYXRlLm5vdygpO1xuICAgICAgc2V0VG9rZW4obmV3VG9rZW4pO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGgtdG9rZW4nLCBuZXdUb2tlbik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkOicsIGVycik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIExvZ291dFxuICBjb25zdCBsb2dvdXQgPSAoKSA9PiB7XG4gICAgc2V0U2VsZWN0ZWRBY2NvdW50KG51bGwpO1xuICAgIHNldFdhbGxldEFkZHJlc3MobnVsbCk7XG4gICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcbiAgICBzZXRJc0FsbG93ZWQoZmFsc2UpO1xuICAgIHNldFVzZXIobnVsbCk7XG4gICAgc2V0VG9rZW4obnVsbCk7XG5cbiAgICAvLyBDbGVhciBsb2NhbFN0b3JhZ2VcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnd2FsbGV0LWFkZHJlc3MnKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnYXV0aC10b2tlbicpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd1c2VyLWRhdGEnKTtcbiAgfTtcblxuICAvLyBSZXNldCByZWplY3Rpb24gc3RhdGVcbiAgY29uc3QgcmVzZXRSZWplY3Rpb25TdGF0ZSA9ICgpID0+IHtcbiAgICBzZXRXYXNTaWduYXR1cmVSZWplY3RlZChmYWxzZSk7XG4gIH07XG5cbiAgLy8gRGVidWcgc3RhdGVcbiAgY29uc29sZS5sb2coJ1tBVVRIIFNUQVRFXScsIHtcbiAgICBpc1dhbGxldENvbm5lY3RlZCxcbiAgICBpc0F1dGhlbnRpY2F0ZWQsXG4gICAgaXNBbGxvd2VkLFxuICAgIHdhc1NpZ25hdHVyZVJlamVjdGVkLFxuICAgIHdhbGxldEFkZHJlc3M6IHdhbGxldEFkZHJlc3M/LnNsaWNlKDAsIDgpICsgJy4uLicsXG4gICAgYWNjb3VudDogc2VsZWN0ZWRBY2NvdW50Py5hZGRyZXNzPy5zbGljZSgwLCA4KSArICcuLi4nLFxuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxBdXRoQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgLy8gQWNjb3VudCBzdGF0ZXNcbiAgICAgICAgd2FsbGV0QWRkcmVzcyxcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIHNlbGVjdGVkQWNjb3VudCxcblxuICAgICAgICAvLyBVSSBzdGF0ZXNcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHNob3dBY2NvdW50U2VsZWN0b3IsXG4gICAgICAgIHNldFNob3dBY2NvdW50U2VsZWN0b3IsXG5cbiAgICAgICAgLy8gVXNlciBkYXRhXG4gICAgICAgIHVzZXIsXG4gICAgICAgIHRva2VuLFxuXG4gICAgICAgIC8vIENvcmUgbWV0aG9kc1xuICAgICAgICBsb2dvdXQsXG4gICAgICAgIGNvbm5lY3QsXG4gICAgICAgIHNlbGVjdEFjY291bnQsXG4gICAgICAgIHNpZ25NZXNzYWdlLFxuICAgICAgICByZWZyZXNoQXV0aFRva2VuLFxuICAgICAgICByZXF1ZXN0U2lnbmF0dXJlLFxuXG4gICAgICAgIC8vIFNpZ25hdHVyZSBzdGF0ZXNcbiAgICAgICAgd2FzU2lnbmF0dXJlUmVqZWN0ZWQsXG4gICAgICAgIGlzUmVxdWVzdGluZ1NpZ25hdHVyZSxcbiAgICAgICAgcmVzZXRSZWplY3Rpb25TdGF0ZSxcblxuICAgICAgICAvLyBEZXJpdmVkIHN0YXRlc1xuICAgICAgICBpc1B1YmxpY01vZGUsXG4gICAgICAgIGlzV2FsbGV0Q29ubmVjdGVkLFxuICAgICAgICBpc0F1dGhlbnRpY2F0ZWQsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgaXNBbGxvd2VkLFxuICAgICAgICBpc0Nvbm5lY3RpbmdcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXV0aENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJBdXRoQ29udGV4dCIsIldhbGxldFNlcnZpY2UiLCJoYXNXaGl0ZWxpc3RlZEFkZHJlc3NlcyIsIkF1dGhQcm92aWRlciIsImNoaWxkcmVuIiwic2VsZWN0ZWRBY2NvdW50Iiwid2FsbGV0QWRkcmVzcyIsInNldFdhbGxldEFkZHJlc3MiLCJhY2NvdW50cyIsInNldEFjY291bnRzIiwic2V0U2VsZWN0ZWRBY2NvdW50IiwiaXNDb25uZWN0aW5nIiwic2V0SXNDb25uZWN0aW5nIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsInNob3dBY2NvdW50U2VsZWN0b3IiLCJzZXRTaG93QWNjb3VudFNlbGVjdG9yIiwiaXNBdXRoZW50aWNhdGVkIiwic2V0SXNBdXRoZW50aWNhdGVkIiwiaXNBbGxvd2VkIiwic2V0SXNBbGxvd2VkIiwidXNlciIsInNldFVzZXIiLCJ0b2tlbiIsInNldFRva2VuIiwid2FzU2lnbmF0dXJlUmVqZWN0ZWQiLCJzZXRXYXNTaWduYXR1cmVSZWplY3RlZCIsImlzUmVxdWVzdGluZ1NpZ25hdHVyZSIsInNldElzUmVxdWVzdGluZ1NpZ25hdHVyZSIsImlzUHVibGljTW9kZSIsImlzV2FsbGV0Q29ubmVjdGVkIiwiaW5pdEF1dGgiLCJzdG9yZWRBZGRyZXNzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInN0b3JlZFRva2VuIiwiaXNFbmFibGVkIiwiZW5hYmxlV2FsbGV0Iiwid2FsbGV0QWNjb3VudHMiLCJnZXRBY2NvdW50cyIsImFjY291bnQiLCJmaW5kIiwiYWNjIiwiYWRkcmVzcyIsImVyciIsImNvbnNvbGUiLCJ3YXJuIiwidXNlckRhdGEiLCJKU09OIiwicGFyc2UiLCJlIiwibG9nIiwidGltZXIiLCJzZXRUaW1lb3V0IiwicmVxdWVzdFNpZ25hdHVyZSIsImNsZWFyVGltZW91dCIsImNvbm5lY3QiLCJFcnJvciIsImxlbmd0aCIsIm1lc3NhZ2UiLCJzZWxlY3RBY2NvdW50Iiwic2V0SXRlbSIsImFsbG93ZWQiLCJzaWduTWVzc2FnZSIsImFjY291bnRPdmVycmlkZSIsImFkZHJlc3NUb1VzZSIsImlzUmVqZWN0aW9uIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsIkRhdGUiLCJub3ciLCJzaWduYXR1cmUiLCJkZW1vVG9rZW4iLCJkZW1vVXNlciIsImlkIiwibmFtZSIsIm1ldGEiLCJpc0FkbWluIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwibGFzdExvZ2luQXQiLCJzdHJpbmdpZnkiLCJyZWZyZXNoQXV0aFRva2VuIiwibmV3VG9rZW4iLCJsb2dvdXQiLCJyZW1vdmVJdGVtIiwicmVzZXRSZWplY3Rpb25TdGF0ZSIsInNsaWNlIiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/auth/AuthProvider.tsx\n"));

/***/ })

});