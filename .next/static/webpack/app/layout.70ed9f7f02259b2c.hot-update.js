"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/contexts/auth/AuthProvider.tsx":
/*!********************************************!*\
  !*** ./src/contexts/auth/AuthProvider.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthContext */ \"(app-pages-browser)/./src/contexts/auth/AuthContext.tsx\");\n/* harmony import */ var _WalletService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WalletService */ \"(app-pages-browser)/./src/contexts/auth/WalletService.ts\");\n/* harmony import */ var _config_whitelist__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/config/whitelist */ \"(app-pages-browser)/./src/config/whitelist.ts\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst AuthProvider = (param)=>{\n    let { children } = param;\n    _s();\n    // Account and wallet states\n    const [walletAddress, setWalletAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [accounts, setAccounts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedAccount, setSelectedAccount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // UI states\n    const [isConnecting, setIsConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showAccountSelector, setShowAccountSelector] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Authentication states\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isAllowed, setIsAllowed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [token, setToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Signature states\n    const [wasSignatureRejected, setWasSignatureRejected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isRequestingSignature, setIsRequestingSignature] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Public mode detection\n    const isPublicMode = !(0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.hasWhitelistedAddresses)();\n    // Calculate derived states\n    const isWalletConnected = !!selectedAccount || !!walletAddress;\n    // Initialize auth state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const initAuth = async ()=>{\n            try {\n                // Restore connection from localStorage if available\n                const storedAddress = localStorage.getItem(\"wallet-address\");\n                const storedToken = localStorage.getItem(\"auth-token\");\n                if (storedAddress) {\n                    setWalletAddress(storedAddress);\n                    // Get accounts if extension is available\n                    try {\n                        const isEnabled = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.enableWallet();\n                        if (isEnabled) {\n                            const walletAccounts = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.getAccounts();\n                            setAccounts(walletAccounts);\n                            // Find the stored account\n                            const account = walletAccounts.find((acc)=>acc.address === storedAddress);\n                            if (account) {\n                                setSelectedAccount(account);\n                                // We set isAllowed here too to ensure the auto-signature effect can run\n                                setIsAllowed(isPublicMode || (0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.hasWhitelistedAddresses)());\n                            }\n                        }\n                    } catch (err) {\n                        console.warn(\"Failed to restore wallet connection:\", err);\n                    }\n                    // Restore auth state\n                    if (storedToken) {\n                        setToken(storedToken);\n                        setIsAuthenticated(true);\n                        setIsAllowed(true);\n                        try {\n                            // Optionally restore user data if you have it\n                            const userData = localStorage.getItem(\"user-data\");\n                            if (userData) {\n                                setUser(JSON.parse(userData));\n                            }\n                        } catch (e) {\n                            console.warn(\"Failed to restore user data:\", e);\n                        }\n                    }\n                }\n            } catch (err) {\n                console.error(\"Error initializing auth:\", err);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        initAuth();\n    }, [\n        isPublicMode\n    ]);\n    // Connect wallet\n    const connect = async ()=>{\n        setIsConnecting(true);\n        setError(null);\n        try {\n            // Enable wallet extension\n            const isEnabled = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.enableWallet();\n            if (!isEnabled) {\n                throw new Error(\"Wallet extension not found or not enabled\");\n            }\n            // Get accounts\n            const walletAccounts = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.getAccounts();\n            if (!walletAccounts || walletAccounts.length === 0) {\n                throw new Error(\"No accounts found in wallet\");\n            }\n            // Update state\n            setAccounts(walletAccounts);\n            setShowAccountSelector(true);\n            return true;\n        } catch (err) {\n            console.error(\"Wallet connection error:\", err);\n            setError(err instanceof Error ? err.message : \"Failed to connect wallet\");\n            return false;\n        } finally{\n            setIsConnecting(false);\n        }\n    };\n    // Select account\n    const selectAccount = async (account)=>{\n        console.log(\"Account selected:\", account.address);\n        // Update state with selected account\n        setSelectedAccount(account);\n        setWalletAddress(account.address);\n        setShowAccountSelector(false);\n        // Save to localStorage\n        localStorage.setItem(\"wallet-address\", account.address);\n        // IMPORTANT FIX: Check if the SPECIFIC account is allowed by the whitelist\n        const isAddressAllowed = isPublicMode || (0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.isAddressAllowed)(account.address);\n        setIsAllowed(isAddressAllowed);\n        console.log(\"Address allowed:\", isAddressAllowed);\n        // Reset signature rejection state when selecting a new account\n        setWasSignatureRejected(false);\n    };\n    // Sign message\n    const signMessage = async (message, accountOverride)=>{\n        const addressToUse = (accountOverride === null || accountOverride === void 0 ? void 0 : accountOverride.address) || (selectedAccount === null || selectedAccount === void 0 ? void 0 : selectedAccount.address) || walletAddress;\n        if (!addressToUse) return null;\n        try {\n            console.log(\"Signing message for address:\", addressToUse);\n            return await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.signMessage(addressToUse, message);\n        } catch (err) {\n            console.error(\"Signature error:\", err);\n            // Check if user rejected the signature\n            const isRejection = err instanceof Error && (err.message.toLowerCase().includes(\"reject\") || err.message.toLowerCase().includes(\"cancel\") || err.message.toLowerCase().includes(\"denied\") || err.message.toLowerCase().includes(\"user cancelled\"));\n            if (isRejection) {\n                console.log(\"Setting wasSignatureRejected to true\");\n                setWasSignatureRejected(true);\n            }\n            throw err;\n        }\n    };\n    // Request signature for authentication\n    const requestSignature = async (address)=>{\n        if (!address) return false;\n        console.log(\"Starting signature request for address:\", address);\n        setIsRequestingSignature(true);\n        setWasSignatureRejected(false);\n        try {\n            var _selectedAccount_meta;\n            // Create a unique message\n            const message = \"Sign this message to authenticate with Download Manager: \".concat(Date.now());\n            // Get signature - this might throw if rejected\n            console.log(\"Requesting signature for message:\", message);\n            const signature = await signMessage(message);\n            if (!signature) {\n                console.warn(\"No signature returned\");\n                return false;\n            }\n            console.log(\"Signature received, authenticating...\");\n            // In a real app, you'd verify this signature on the server\n            const token = \"auth-token-\" + Date.now(); // Simplified token\n            setToken(token);\n            localStorage.setItem(\"auth-token\", token);\n            // Set authenticated state\n            setIsAuthenticated(true);\n            // Create user object\n            const user = {\n                id: \"1\",\n                address,\n                name: (selectedAccount === null || selectedAccount === void 0 ? void 0 : (_selectedAccount_meta = selectedAccount.meta) === null || _selectedAccount_meta === void 0 ? void 0 : _selectedAccount_meta.name) || null,\n                isAdmin: true,\n                createdAt: new Date(),\n                updatedAt: new Date(),\n                lastLoginAt: new Date()\n            };\n            setUser(user);\n            localStorage.setItem(\"user-data\", JSON.stringify(user));\n            return true;\n        } catch (err) {\n            console.error(\"Signature request failed:\", err);\n            // Check if this was a rejection\n            const isRejection = err instanceof Error && (err.message.toLowerCase().includes(\"reject\") || err.message.toLowerCase().includes(\"cancel\") || err.message.toLowerCase().includes(\"denied\"));\n            if (isRejection) {\n                console.log(\"Setting wasSignatureRejected to true\");\n                setWasSignatureRejected(true);\n            } else {\n                setError(err instanceof Error ? err.message : \"Failed to sign message\");\n            }\n            return false;\n        } finally{\n            setIsRequestingSignature(false);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Skip if still loading, already authenticated, requesting signature, or in public mode\n        // Also skip if signature was previously rejected - don't auto-retry after rejection\n        if (isLoading || isAuthenticated || isRequestingSignature || isPublicMode || wasSignatureRejected) {\n            return;\n        }\n        // If we have a connected wallet and it's allowed but not authenticated, request signature\n        if (selectedAccount && isAllowed && !isAuthenticated) {\n            console.log(\"[AUTH] Auto-triggering signature request for connected wallet:\", selectedAccount.address);\n            // Short delay to ensure all state is properly updated\n            const timer = setTimeout(async ()=>{\n                try {\n                    await requestSignature(selectedAccount.address);\n                } catch (err) {\n                    console.error(\"Failed to auto-request signature:\", err);\n                }\n            }, 300);\n            return ()=>clearTimeout(timer);\n        }\n    }, [\n        selectedAccount,\n        isAllowed,\n        isAuthenticated,\n        isLoading,\n        isRequestingSignature,\n        isPublicMode,\n        wasSignatureRejected,\n        requestSignature\n    ]);\n    // Refresh auth token\n    const refreshAuthToken = async ()=>{\n        if (!isAuthenticated || !walletAddress) return false;\n        try {\n            const newToken = \"refreshed-token-\" + Date.now();\n            setToken(newToken);\n            localStorage.setItem(\"auth-token\", newToken);\n            return true;\n        } catch (err) {\n            console.error(\"Token refresh failed:\", err);\n            return false;\n        }\n    };\n    // Logout\n    const logout = ()=>{\n        setSelectedAccount(null);\n        setWalletAddress(null);\n        setIsAuthenticated(false);\n        setIsAllowed(false);\n        setUser(null);\n        setToken(null);\n        setWasSignatureRejected(false);\n        // Clear localStorage\n        localStorage.removeItem(\"wallet-address\");\n        localStorage.removeItem(\"auth-token\");\n        localStorage.removeItem(\"user-data\");\n    };\n    // Reset rejection state\n    const resetRejectionState = ()=>{\n        setWasSignatureRejected(false);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_AuthContext__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Provider, {\n        value: {\n            // Account states\n            walletAddress,\n            accounts,\n            selectedAccount,\n            // UI states\n            error,\n            showAccountSelector,\n            setShowAccountSelector,\n            // User data\n            user,\n            token,\n            // Core methods\n            logout,\n            connect,\n            selectAccount,\n            signMessage,\n            refreshAuthToken,\n            requestSignature,\n            // Signature states\n            wasSignatureRejected,\n            isRequestingSignature,\n            resetRejectionState,\n            // Derived states\n            isPublicMode,\n            isWalletConnected,\n            isAuthenticated,\n            isLoading,\n            isAllowed,\n            isConnecting\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\crist\\\\monkeyscanjump\\\\download-manager\\\\src\\\\contexts\\\\auth\\\\AuthProvider.tsx\",\n        lineNumber: 304,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AuthProvider, \"p202UMbLtbWP78v8tUbUMqPJJ14=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9hdXRoL0F1dGhQcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRW1EO0FBQ1g7QUFDUTtBQUN1RDtBQUloRyxNQUFNUSxlQUFlO1FBQUMsRUFBRUMsUUFBUSxFQUFpQzs7SUFDdEUsNEJBQTRCO0lBQzVCLE1BQU0sQ0FBQ0MsZUFBZUMsaUJBQWlCLEdBQUdWLCtDQUFRQSxDQUFnQjtJQUNsRSxNQUFNLENBQUNXLFVBQVVDLFlBQVksR0FBR1osK0NBQVFBLENBQTRCLEVBQUU7SUFDdEUsTUFBTSxDQUFDYSxpQkFBaUJDLG1CQUFtQixHQUFHZCwrQ0FBUUEsQ0FBaUM7SUFFdkYsWUFBWTtJQUNaLE1BQU0sQ0FBQ2UsY0FBY0MsZ0JBQWdCLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUNpQixXQUFXQyxhQUFhLEdBQUdsQiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNtQixPQUFPQyxTQUFTLEdBQUdwQiwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTSxDQUFDcUIscUJBQXFCQyx1QkFBdUIsR0FBR3RCLCtDQUFRQSxDQUFDO0lBRS9ELHdCQUF3QjtJQUN4QixNQUFNLENBQUN1QixpQkFBaUJDLG1CQUFtQixHQUFHeEIsK0NBQVFBLENBQUM7SUFDdkQsTUFBTSxDQUFDeUIsV0FBV0MsYUFBYSxHQUFHMUIsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDMkIsTUFBTUMsUUFBUSxHQUFHNUIsK0NBQVFBLENBQWM7SUFDOUMsTUFBTSxDQUFDNkIsT0FBT0MsU0FBUyxHQUFHOUIsK0NBQVFBLENBQWdCO0lBRWxELG1CQUFtQjtJQUNuQixNQUFNLENBQUMrQixzQkFBc0JDLHdCQUF3QixHQUFHaEMsK0NBQVFBLENBQUM7SUFDakUsTUFBTSxDQUFDaUMsdUJBQXVCQyx5QkFBeUIsR0FBR2xDLCtDQUFRQSxDQUFDO0lBRW5FLHdCQUF3QjtJQUN4QixNQUFNbUMsZUFBZSxDQUFD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O1FBRXhCLHFCQUFxQjtRQUNyQk8sYUFBYWlELFVBQVUsQ0FBQztRQUN4QmpELGFBQWFpRCxVQUFVLENBQUM7UUFDeEJqRCxhQUFhaUQsVUFBVSxDQUFDO0lBQzFCO0lBRUEsd0JBQXdCO0lBQ3hCLE1BQU1DLHNCQUFzQjtRQUMxQnpELHdCQUF3QjtJQUMxQjtJQUVBLHFCQUNFLDhEQUFDOUIsb0RBQVdBLENBQUN3RixRQUFRO1FBQ25CQyxPQUFPO1lBQ0wsaUJBQWlCO1lBQ2pCbEY7WUFDQUU7WUFDQUU7WUFFQSxZQUFZO1lBQ1pNO1lBQ0FFO1lBQ0FDO1lBRUEsWUFBWTtZQUNaSztZQUNBRTtZQUVBLGVBQWU7WUFDZjBEO1lBQ0E5QjtZQUNBSTtZQUNBRztZQUNBcUI7WUFDQWY7WUFFQSxtQkFBbUI7WUFDbkJ2QztZQUNBRTtZQUNBd0Q7WUFFQSxpQkFBaUI7WUFDakJ0RDtZQUNBQztZQUNBYjtZQUNBTjtZQUNBUTtZQUNBVjtRQUNGO2tCQUVDUDs7Ozs7O0FBR1AsRUFBRTtHQS9VV0Q7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHRzL2F1dGgvQXV0aFByb3ZpZGVyLnRzeD84NGY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBBdXRoQ29udGV4dCBmcm9tICcuL0F1dGhDb250ZXh0JztcbmltcG9ydCB7IFdhbGxldFNlcnZpY2UgfSBmcm9tICcuL1dhbGxldFNlcnZpY2UnO1xuaW1wb3J0IHsgaGFzV2hpdGVsaXN0ZWRBZGRyZXNzZXMsIGlzQWRkcmVzc0FsbG93ZWQgYXMgaXNBZGRyZXNzSW5XaGl0ZWxpc3QgfSBmcm9tICdAL2NvbmZpZy93aGl0ZWxpc3QnO1xuaW1wb3J0IHR5cGUgeyBJbmplY3RlZEFjY291bnRXaXRoTWV0YSB9IGZyb20gJ0Bwb2xrYWRvdC9leHRlbnNpb24taW5qZWN0L3R5cGVzJztcbmltcG9ydCB0eXBlIHsgVXNlciB9IGZyb20gJ0AvdHlwZXMvdXNlcic7XG5cbmV4cG9ydCBjb25zdCBBdXRoUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkgPT4ge1xuICAvLyBBY2NvdW50IGFuZCB3YWxsZXQgc3RhdGVzXG4gIGNvbnN0IFt3YWxsZXRBZGRyZXNzLCBzZXRXYWxsZXRBZGRyZXNzXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbYWNjb3VudHMsIHNldEFjY291bnRzXSA9IHVzZVN0YXRlPEluamVjdGVkQWNjb3VudFdpdGhNZXRhW10+KFtdKTtcbiAgY29uc3QgW3NlbGVjdGVkQWNjb3VudCwgc2V0U2VsZWN0ZWRBY2NvdW50XSA9IHVzZVN0YXRlPEluamVjdGVkQWNjb3VudFdpdGhNZXRhIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gVUkgc3RhdGVzXG4gIGNvbnN0IFtpc0Nvbm5lY3RpbmcsIHNldElzQ29ubmVjdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3Nob3dBY2NvdW50U2VsZWN0b3IsIHNldFNob3dBY2NvdW50U2VsZWN0b3JdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIEF1dGhlbnRpY2F0aW9uIHN0YXRlc1xuICBjb25zdCBbaXNBdXRoZW50aWNhdGVkLCBzZXRJc0F1dGhlbnRpY2F0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNBbGxvd2VkLCBzZXRJc0FsbG93ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTxVc2VyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFt0b2tlbiwgc2V0VG9rZW5dID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gU2lnbmF0dXJlIHN0YXRlc1xuICBjb25zdCBbd2FzU2lnbmF0dXJlUmVqZWN0ZWQsIHNldFdhc1NpZ25hdHVyZVJlamVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzUmVxdWVzdGluZ1NpZ25hdHVyZSwgc2V0SXNSZXF1ZXN0aW5nU2lnbmF0dXJlXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBQdWJsaWMgbW9kZSBkZXRlY3Rpb25cbiAgY29uc3QgaXNQdWJsaWNNb2RlID0gIWhhc1doaXRlbGlzdGVkQWRkcmVzc2VzKCk7XG5cbiAgLy8gQ2FsY3VsYXRlIGRlcml2ZWQgc3RhdGVzXG4gIGNvbnN0IGlzV2FsbGV0Q29ubmVjdGVkID0gISFzZWxlY3RlZEFjY291bnQgfHwgISF3YWxsZXRBZGRyZXNzO1xuXG4gIC8vIEluaXRpYWxpemUgYXV0aCBzdGF0ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGluaXRBdXRoID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gUmVzdG9yZSBjb25uZWN0aW9uIGZyb20gbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBzdG9yZWRBZGRyZXNzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGxldC1hZGRyZXNzJyk7XG4gICAgICAgIGNvbnN0IHN0b3JlZFRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGgtdG9rZW4nKTtcblxuICAgICAgICBpZiAoc3RvcmVkQWRkcmVzcykge1xuICAgICAgICAgIHNldFdhbGxldEFkZHJlc3Moc3RvcmVkQWRkcmVzcyk7XG5cbiAgICAgICAgICAvLyBHZXQgYWNjb3VudHMgaWYgZXh0ZW5zaW9uIGlzIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpc0VuYWJsZWQgPSBhd2FpdCBXYWxsZXRTZXJ2aWNlLmVuYWJsZVdhbGxldCgpO1xuICAgICAgICAgICAgaWYgKGlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICBjb25zdCB3YWxsZXRBY2NvdW50cyA9IGF3YWl0IFdhbGxldFNlcnZpY2UuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgc2V0QWNjb3VudHMod2FsbGV0QWNjb3VudHMpO1xuXG4gICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHN0b3JlZCBhY2NvdW50XG4gICAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSB3YWxsZXRBY2NvdW50cy5maW5kKGFjYyA9PiBhY2MuYWRkcmVzcyA9PT0gc3RvcmVkQWRkcmVzcyk7XG4gICAgICAgICAgICAgIGlmIChhY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRBY2NvdW50KGFjY291bnQpO1xuICAgICAgICAgICAgICAgIC8vIFdlIHNldCBpc0FsbG93ZWQgaGVyZSB0b28gdG8gZW5zdXJlIHRoZSBhdXRvLXNpZ25hdHVyZSBlZmZlY3QgY2FuIHJ1blxuICAgICAgICAgICAgICAgIHNldElzQWxsb3dlZChpc1B1YmxpY01vZGUgfHwgaGFzV2hpdGVsaXN0ZWRBZGRyZXNzZXMoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJlc3RvcmUgd2FsbGV0IGNvbm5lY3Rpb246JywgZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXN0b3JlIGF1dGggc3RhdGVcbiAgICAgICAgICBpZiAoc3RvcmVkVG9rZW4pIHtcbiAgICAgICAgICAgIHNldFRva2VuKHN0b3JlZFRva2VuKTtcbiAgICAgICAgICAgIHNldElzQXV0aGVudGljYXRlZCh0cnVlKTtcbiAgICAgICAgICAgIHNldElzQWxsb3dlZCh0cnVlKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gT3B0aW9uYWxseSByZXN0b3JlIHVzZXIgZGF0YSBpZiB5b3UgaGF2ZSBpdFxuICAgICAgICAgICAgICBjb25zdCB1c2VyRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd1c2VyLWRhdGEnKTtcbiAgICAgICAgICAgICAgaWYgKHVzZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgc2V0VXNlcihKU09OLnBhcnNlKHVzZXJEYXRhKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVzdG9yZSB1c2VyIGRhdGE6JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGF1dGg6JywgZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGluaXRBdXRoKCk7XG4gIH0sIFtpc1B1YmxpY01vZGVdKTtcblxuICAvLyBDb25uZWN0IHdhbGxldFxuICBjb25zdCBjb25uZWN0ID0gYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIHNldElzQ29ubmVjdGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBFbmFibGUgd2FsbGV0IGV4dGVuc2lvblxuICAgICAgY29uc3QgaXNFbmFibGVkID0gYXdhaXQgV2FsbGV0U2VydmljZS5lbmFibGVXYWxsZXQoKTtcbiAgICAgIGlmICghaXNFbmFibGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IGV4dGVuc2lvbiBub3QgZm91bmQgb3Igbm90IGVuYWJsZWQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGFjY291bnRzXG4gICAgICBjb25zdCB3YWxsZXRBY2NvdW50cyA9IGF3YWl0IFdhbGxldFNlcnZpY2UuZ2V0QWNjb3VudHMoKTtcbiAgICAgIGlmICghd2FsbGV0QWNjb3VudHMgfHwgd2FsbGV0QWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjb3VudHMgZm91bmQgaW4gd2FsbGV0Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgc2V0QWNjb3VudHMod2FsbGV0QWNjb3VudHMpO1xuICAgICAgc2V0U2hvd0FjY291bnRTZWxlY3Rvcih0cnVlKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdXYWxsZXQgY29ubmVjdGlvbiBlcnJvcjonLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gY29ubmVjdCB3YWxsZXQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU2VsZWN0IGFjY291bnRcbiAgY29uc3Qgc2VsZWN0QWNjb3VudCA9IGFzeW5jIChhY2NvdW50OiBJbmplY3RlZEFjY291bnRXaXRoTWV0YSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGNvbnNvbGUubG9nKCdBY2NvdW50IHNlbGVjdGVkOicsIGFjY291bnQuYWRkcmVzcyk7XG5cbiAgICAvLyBVcGRhdGUgc3RhdGUgd2l0aCBzZWxlY3RlZCBhY2NvdW50XG4gICAgc2V0U2VsZWN0ZWRBY2NvdW50KGFjY291bnQpO1xuICAgIHNldFdhbGxldEFkZHJlc3MoYWNjb3VudC5hZGRyZXNzKTtcbiAgICBzZXRTaG93QWNjb3VudFNlbGVjdG9yKGZhbHNlKTtcblxuICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dhbGxldC1hZGRyZXNzJywgYWNjb3VudC5hZGRyZXNzKTtcblxuICAgIC8vIElNUE9SVEFOVCBGSVg6IENoZWNrIGlmIHRoZSBTUEVDSUZJQyBhY2NvdW50IGlzIGFsbG93ZWQgYnkgdGhlIHdoaXRlbGlzdFxuICAgIGNvbnN0IGlzQWRkcmVzc0FsbG93ZWQgPSBpc1B1YmxpY01vZGUgfHwgaXNBZGRyZXNzSW5XaGl0ZWxpc3QoYWNjb3VudC5hZGRyZXNzKTtcbiAgICBzZXRJc0FsbG93ZWQoaXNBZGRyZXNzQWxsb3dlZCk7XG5cbiAgICBjb25zb2xlLmxvZygnQWRkcmVzcyBhbGxvd2VkOicsIGlzQWRkcmVzc0FsbG93ZWQpO1xuXG4gICAgLy8gUmVzZXQgc2lnbmF0dXJlIHJlamVjdGlvbiBzdGF0ZSB3aGVuIHNlbGVjdGluZyBhIG5ldyBhY2NvdW50XG4gICAgc2V0V2FzU2lnbmF0dXJlUmVqZWN0ZWQoZmFsc2UpO1xuICB9O1xuXG4gIC8vIFNpZ24gbWVzc2FnZVxuICBjb25zdCBzaWduTWVzc2FnZSA9IGFzeW5jIChtZXNzYWdlOiBzdHJpbmcsIGFjY291bnRPdmVycmlkZT86IEluamVjdGVkQWNjb3VudFdpdGhNZXRhKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiA9PiB7XG4gICAgY29uc3QgYWRkcmVzc1RvVXNlID0gYWNjb3VudE92ZXJyaWRlPy5hZGRyZXNzIHx8IHNlbGVjdGVkQWNjb3VudD8uYWRkcmVzcyB8fCB3YWxsZXRBZGRyZXNzO1xuICAgIGlmICghYWRkcmVzc1RvVXNlKSByZXR1cm4gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnU2lnbmluZyBtZXNzYWdlIGZvciBhZGRyZXNzOicsIGFkZHJlc3NUb1VzZSk7XG4gICAgICByZXR1cm4gYXdhaXQgV2FsbGV0U2VydmljZS5zaWduTWVzc2FnZShhZGRyZXNzVG9Vc2UsIG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignU2lnbmF0dXJlIGVycm9yOicsIGVycik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHVzZXIgcmVqZWN0ZWQgdGhlIHNpZ25hdHVyZVxuICAgICAgY29uc3QgaXNSZWplY3Rpb24gPSBlcnIgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAoZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygncmVqZWN0JykgfHxcbiAgICAgICAgIGVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2NhbmNlbCcpIHx8XG4gICAgICAgICBlcnIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdkZW5pZWQnKSB8fFxuICAgICAgICAgZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndXNlciBjYW5jZWxsZWQnKSk7XG5cbiAgICAgIGlmIChpc1JlamVjdGlvbikge1xuICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZyB3YXNTaWduYXR1cmVSZWplY3RlZCB0byB0cnVlJyk7XG4gICAgICAgIHNldFdhc1NpZ25hdHVyZVJlamVjdGVkKHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlcXVlc3Qgc2lnbmF0dXJlIGZvciBhdXRoZW50aWNhdGlvblxuICBjb25zdCByZXF1ZXN0U2lnbmF0dXJlID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGlmICghYWRkcmVzcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIHNpZ25hdHVyZSByZXF1ZXN0IGZvciBhZGRyZXNzOicsIGFkZHJlc3MpO1xuICAgIHNldElzUmVxdWVzdGluZ1NpZ25hdHVyZSh0cnVlKTtcbiAgICBzZXRXYXNTaWduYXR1cmVSZWplY3RlZChmYWxzZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gQ3JlYXRlIGEgdW5pcXVlIG1lc3NhZ2VcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgU2lnbiB0aGlzIG1lc3NhZ2UgdG8gYXV0aGVudGljYXRlIHdpdGggRG93bmxvYWQgTWFuYWdlcjogJHtEYXRlLm5vdygpfWA7XG5cbiAgICAgIC8vIEdldCBzaWduYXR1cmUgLSB0aGlzIG1pZ2h0IHRocm93IGlmIHJlamVjdGVkXG4gICAgICBjb25zb2xlLmxvZygnUmVxdWVzdGluZyBzaWduYXR1cmUgZm9yIG1lc3NhZ2U6JywgbWVzc2FnZSk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzaWduTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgaWYgKCFzaWduYXR1cmUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBzaWduYXR1cmUgcmV0dXJuZWQnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnU2lnbmF0dXJlIHJlY2VpdmVkLCBhdXRoZW50aWNhdGluZy4uLicpO1xuICAgICAgLy8gSW4gYSByZWFsIGFwcCwgeW91J2QgdmVyaWZ5IHRoaXMgc2lnbmF0dXJlIG9uIHRoZSBzZXJ2ZXJcbiAgICAgIGNvbnN0IHRva2VuID0gJ2F1dGgtdG9rZW4tJyArIERhdGUubm93KCk7IC8vIFNpbXBsaWZpZWQgdG9rZW5cbiAgICAgIHNldFRva2VuKHRva2VuKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhdXRoLXRva2VuJywgdG9rZW4pO1xuXG4gICAgICAvLyBTZXQgYXV0aGVudGljYXRlZCBzdGF0ZVxuICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKHRydWUpO1xuXG4gICAgICAvLyBDcmVhdGUgdXNlciBvYmplY3RcbiAgICAgIGNvbnN0IHVzZXIgPSB7XG4gICAgICAgIGlkOiAnMScsXG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIG5hbWU6IHNlbGVjdGVkQWNjb3VudD8ubWV0YT8ubmFtZSB8fCBudWxsLFxuICAgICAgICBpc0FkbWluOiB0cnVlLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgbGFzdExvZ2luQXQ6IG5ldyBEYXRlKClcbiAgICAgIH07XG5cbiAgICAgIHNldFVzZXIodXNlcik7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndXNlci1kYXRhJywgSlNPTi5zdHJpbmdpZnkodXNlcikpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpZ25hdHVyZSByZXF1ZXN0IGZhaWxlZDonLCBlcnIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHdhcyBhIHJlamVjdGlvblxuICAgICAgY29uc3QgaXNSZWplY3Rpb24gPSBlcnIgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAoZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygncmVqZWN0JykgfHxcbiAgICAgICAgIGVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2NhbmNlbCcpIHx8XG4gICAgICAgICBlcnIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdkZW5pZWQnKSk7XG5cbiAgICAgIGlmIChpc1JlamVjdGlvbikge1xuICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZyB3YXNTaWduYXR1cmVSZWplY3RlZCB0byB0cnVlJyk7XG4gICAgICAgIHNldFdhc1NpZ25hdHVyZVJlamVjdGVkKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gc2lnbiBtZXNzYWdlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNSZXF1ZXN0aW5nU2lnbmF0dXJlKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTa2lwIGlmIHN0aWxsIGxvYWRpbmcsIGFscmVhZHkgYXV0aGVudGljYXRlZCwgcmVxdWVzdGluZyBzaWduYXR1cmUsIG9yIGluIHB1YmxpYyBtb2RlXG4gICAgLy8gQWxzbyBza2lwIGlmIHNpZ25hdHVyZSB3YXMgcHJldmlvdXNseSByZWplY3RlZCAtIGRvbid0IGF1dG8tcmV0cnkgYWZ0ZXIgcmVqZWN0aW9uXG4gICAgaWYgKGlzTG9hZGluZyB8fCBpc0F1dGhlbnRpY2F0ZWQgfHwgaXNSZXF1ZXN0aW5nU2lnbmF0dXJlIHx8IGlzUHVibGljTW9kZSB8fCB3YXNTaWduYXR1cmVSZWplY3RlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgYSBjb25uZWN0ZWQgd2FsbGV0IGFuZCBpdCdzIGFsbG93ZWQgYnV0IG5vdCBhdXRoZW50aWNhdGVkLCByZXF1ZXN0IHNpZ25hdHVyZVxuICAgIGlmIChzZWxlY3RlZEFjY291bnQgJiYgaXNBbGxvd2VkICYmICFpc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbQVVUSF0gQXV0by10cmlnZ2VyaW5nIHNpZ25hdHVyZSByZXF1ZXN0IGZvciBjb25uZWN0ZWQgd2FsbGV0OicsIHNlbGVjdGVkQWNjb3VudC5hZGRyZXNzKTtcblxuICAgICAgLy8gU2hvcnQgZGVsYXkgdG8gZW5zdXJlIGFsbCBzdGF0ZSBpcyBwcm9wZXJseSB1cGRhdGVkXG4gICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHJlcXVlc3RTaWduYXR1cmUoc2VsZWN0ZWRBY2NvdW50LmFkZHJlc3MpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYXV0by1yZXF1ZXN0IHNpZ25hdHVyZTonLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuXG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB9XG4gIH0sIFtzZWxlY3RlZEFjY291bnQsIGlzQWxsb3dlZCwgaXNBdXRoZW50aWNhdGVkLCBpc0xvYWRpbmcsIGlzUmVxdWVzdGluZ1NpZ25hdHVyZSwgaXNQdWJsaWNNb2RlLCB3YXNTaWduYXR1cmVSZWplY3RlZCwgcmVxdWVzdFNpZ25hdHVyZV0pO1xuXG4gIC8vIFJlZnJlc2ggYXV0aCB0b2tlblxuICBjb25zdCByZWZyZXNoQXV0aFRva2VuID0gYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGlmICghaXNBdXRoZW50aWNhdGVkIHx8ICF3YWxsZXRBZGRyZXNzKSByZXR1cm4gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV3VG9rZW4gPSAncmVmcmVzaGVkLXRva2VuLScgKyBEYXRlLm5vdygpO1xuICAgICAgc2V0VG9rZW4obmV3VG9rZW4pO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGgtdG9rZW4nLCBuZXdUb2tlbik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkOicsIGVycik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIExvZ291dFxuICBjb25zdCBsb2dvdXQgPSAoKSA9PiB7XG4gICAgc2V0U2VsZWN0ZWRBY2NvdW50KG51bGwpO1xuICAgIHNldFdhbGxldEFkZHJlc3MobnVsbCk7XG4gICAgc2V0SXNBdXRoZW50aWNhdGVkKGZhbHNlKTtcbiAgICBzZXRJc0FsbG93ZWQoZmFsc2UpO1xuICAgIHNldFVzZXIobnVsbCk7XG4gICAgc2V0VG9rZW4obnVsbCk7XG4gICAgc2V0V2FzU2lnbmF0dXJlUmVqZWN0ZWQoZmFsc2UpO1xuXG4gICAgLy8gQ2xlYXIgbG9jYWxTdG9yYWdlXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3dhbGxldC1hZGRyZXNzJyk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2F1dGgtdG9rZW4nKTtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlci1kYXRhJyk7XG4gIH07XG5cbiAgLy8gUmVzZXQgcmVqZWN0aW9uIHN0YXRlXG4gIGNvbnN0IHJlc2V0UmVqZWN0aW9uU3RhdGUgPSAoKSA9PiB7XG4gICAgc2V0V2FzU2lnbmF0dXJlUmVqZWN0ZWQoZmFsc2UpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEF1dGhDb250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICAvLyBBY2NvdW50IHN0YXRlc1xuICAgICAgICB3YWxsZXRBZGRyZXNzLFxuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgc2VsZWN0ZWRBY2NvdW50LFxuXG4gICAgICAgIC8vIFVJIHN0YXRlc1xuICAgICAgICBlcnJvcixcbiAgICAgICAgc2hvd0FjY291bnRTZWxlY3RvcixcbiAgICAgICAgc2V0U2hvd0FjY291bnRTZWxlY3RvcixcblxuICAgICAgICAvLyBVc2VyIGRhdGFcbiAgICAgICAgdXNlcixcbiAgICAgICAgdG9rZW4sXG5cbiAgICAgICAgLy8gQ29yZSBtZXRob2RzXG4gICAgICAgIGxvZ291dCxcbiAgICAgICAgY29ubmVjdCxcbiAgICAgICAgc2VsZWN0QWNjb3VudCxcbiAgICAgICAgc2lnbk1lc3NhZ2UsXG4gICAgICAgIHJlZnJlc2hBdXRoVG9rZW4sXG4gICAgICAgIHJlcXVlc3RTaWduYXR1cmUsXG5cbiAgICAgICAgLy8gU2lnbmF0dXJlIHN0YXRlc1xuICAgICAgICB3YXNTaWduYXR1cmVSZWplY3RlZCxcbiAgICAgICAgaXNSZXF1ZXN0aW5nU2lnbmF0dXJlLFxuICAgICAgICByZXNldFJlamVjdGlvblN0YXRlLFxuXG4gICAgICAgIC8vIERlcml2ZWQgc3RhdGVzXG4gICAgICAgIGlzUHVibGljTW9kZSxcbiAgICAgICAgaXNXYWxsZXRDb25uZWN0ZWQsXG4gICAgICAgIGlzQXV0aGVudGljYXRlZCxcbiAgICAgICAgaXNMb2FkaW5nLFxuICAgICAgICBpc0FsbG93ZWQsXG4gICAgICAgIGlzQ29ubmVjdGluZ1xuICAgICAgfX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9BdXRoQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIkF1dGhDb250ZXh0IiwiV2FsbGV0U2VydmljZSIsImhhc1doaXRlbGlzdGVkQWRkcmVzc2VzIiwiaXNBZGRyZXNzQWxsb3dlZCIsImlzQWRkcmVzc0luV2hpdGVsaXN0IiwiQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ3YWxsZXRBZGRyZXNzIiwic2V0V2FsbGV0QWRkcmVzcyIsImFjY291bnRzIiwic2V0QWNjb3VudHMiLCJzZWxlY3RlZEFjY291bnQiLCJzZXRTZWxlY3RlZEFjY291bnQiLCJpc0Nvbm5lY3RpbmciLCJzZXRJc0Nvbm5lY3RpbmciLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwic2hvd0FjY291bnRTZWxlY3RvciIsInNldFNob3dBY2NvdW50U2VsZWN0b3IiLCJpc0F1dGhlbnRpY2F0ZWQiLCJzZXRJc0F1dGhlbnRpY2F0ZWQiLCJpc0FsbG93ZWQiLCJzZXRJc0FsbG93ZWQiLCJ1c2VyIiwic2V0VXNlciIsInRva2VuIiwic2V0VG9rZW4iLCJ3YXNTaWduYXR1cmVSZWplY3RlZCIsInNldFdhc1NpZ25hdHVyZVJlamVjdGVkIiwiaXNSZXF1ZXN0aW5nU2lnbmF0dXJlIiwic2V0SXNSZXF1ZXN0aW5nU2lnbmF0dXJlIiwiaXNQdWJsaWNNb2RlIiwiaXNXYWxsZXRDb25uZWN0ZWQiLCJpbml0QXV0aCIsInN0b3JlZEFkZHJlc3MiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic3RvcmVkVG9rZW4iLCJpc0VuYWJsZWQiLCJlbmFibGVXYWxsZXQiLCJ3YWxsZXRBY2NvdW50cyIsImdldEFjY291bnRzIiwiYWNjb3VudCIsImZpbmQiLCJhY2MiLCJhZGRyZXNzIiwiZXJyIiwiY29uc29sZSIsIndhcm4iLCJ1c2VyRGF0YSIsIkpTT04iLCJwYXJzZSIsImUiLCJjb25uZWN0IiwiRXJyb3IiLCJsZW5ndGgiLCJtZXNzYWdlIiwic2VsZWN0QWNjb3VudCIsImxvZyIsInNldEl0ZW0iLCJzaWduTWVzc2FnZSIsImFjY291bnRPdmVycmlkZSIsImFkZHJlc3NUb1VzZSIsImlzUmVqZWN0aW9uIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsInJlcXVlc3RTaWduYXR1cmUiLCJEYXRlIiwibm93Iiwic2lnbmF0dXJlIiwiaWQiLCJuYW1lIiwibWV0YSIsImlzQWRtaW4iLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJsYXN0TG9naW5BdCIsInN0cmluZ2lmeSIsInRpbWVyIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJlZnJlc2hBdXRoVG9rZW4iLCJuZXdUb2tlbiIsImxvZ291dCIsInJlbW92ZUl0ZW0iLCJyZXNldFJlamVjdGlvblN0YXRlIiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/auth/AuthProvider.tsx\n"));

/***/ })

});