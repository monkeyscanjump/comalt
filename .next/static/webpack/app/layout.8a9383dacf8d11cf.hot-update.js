"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/config/whitelist.ts":
/*!*********************************!*\
  !*** ./src/config/whitelist.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALLOWED_ADDRESSES: function() { return /* binding */ ALLOWED_ADDRESSES; },\n/* harmony export */   hasWhitelistedAddresses: function() { return /* binding */ hasWhitelistedAddresses; },\n/* harmony export */   hasWhitelistedAddressesAsync: function() { return /* binding */ hasWhitelistedAddressesAsync; },\n/* harmony export */   isAddressAllowed: function() { return /* binding */ isAddressAllowed; },\n/* harmony export */   isAddressAllowedAsync: function() { return /* binding */ isAddressAllowedAsync; }\n/* harmony export */ });\n/**\n * Whitelist configuration\n * This uses server-side API calls to check whitelist status securely\n */ // Cache for public mode status\nlet publicModeCache = {\n    value: null,\n    timestamp: 0\n};\n// Cache for address validation results\nconst addressValidationCache = new Map();\n// Cache TTL in milliseconds (5 minutes)\nconst CACHE_TTL = 5 * 60 * 1000;\n/**\n * Check if any addresses are configured in the whitelist\n */ async function hasWhitelistedAddressesAsync() {\n    try {\n        // Check cache first\n        const now = Date.now();\n        if (publicModeCache.value !== null && now - publicModeCache.timestamp < CACHE_TTL) {\n            return !publicModeCache.value;\n        }\n        const response = await fetch(\"/api/auth/check-mode/\");\n        if (!response.ok) {\n            console.error(\"Error checking whitelist mode:\", await response.text());\n            throw new Error(\"Failed to check whitelist mode\");\n        }\n        const data = await response.json();\n        console.log(\"Public mode check response:\", data);\n        // Update cache\n        publicModeCache = {\n            value: data.isPublicMode,\n            timestamp: now\n        };\n        return !data.isPublicMode;\n    } catch (error) {\n        console.error(\"Error checking whitelist mode:\", error);\n        // Assume restricted mode by default for safety\n        return true;\n    }\n}\n/**\n * Synchronous version that uses cached result\n */ function hasWhitelistedAddresses() {\n    // Use cached value if available and not expired\n    const now = Date.now();\n    if (publicModeCache.value !== null && now - publicModeCache.timestamp < CACHE_TTL) {\n        return !publicModeCache.value;\n    }\n    // Trigger async check to update cache\n    hasWhitelistedAddressesAsync().catch(console.error);\n    // Default to restricted mode for safety if no cached data\n    return publicModeCache.value === null ? true : !publicModeCache.value;\n}\n/**\n * Check if a wallet address is allowed to access the application\n */ async function isAddressAllowedAsync(address) {\n    if (!address) return false;\n    try {\n        // Check cache first\n        const now = Date.now();\n        const cached = addressValidationCache.get(address);\n        if (cached && now - cached.timestamp < CACHE_TTL) {\n            return cached.isAllowed;\n        }\n        // If we have a definitive public mode cache and it's true, all addresses are allowed\n        if (publicModeCache.value === true && now - publicModeCache.timestamp < CACHE_TTL) {\n            addressValidationCache.set(address, {\n                isAllowed: true,\n                timestamp: now\n            });\n            return true;\n        }\n        const response = await fetch(\"/api/auth/validate-address/\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                address\n            })\n        });\n        if (!response.ok) {\n            console.error(\"Error validating address:\", await response.text());\n            throw new Error(\"Failed to validate address\");\n        }\n        const data = await response.json();\n        console.log(\"Address validation response:\", data);\n        // Cache result\n        addressValidationCache.set(address, {\n            isAllowed: data.isAllowed,\n            timestamp: now\n        });\n        return data.isAllowed;\n    } catch (error) {\n        console.error(\"Error validating address:\", error);\n        return false; // Default to not allowed for safety\n    }\n}\n/**\n * Synchronous version that uses cached result\n */ function isAddressAllowed(address) {\n    if (!address) return false;\n    const now = Date.now();\n    // Use cached value if available and not expired\n    const cached = addressValidationCache.get(address);\n    if (cached && now - cached.timestamp < CACHE_TTL) {\n        return cached.isAllowed;\n    }\n    // If we have a definitive public mode cache and it's true, all addresses are allowed\n    if (publicModeCache.value === true && now - publicModeCache.timestamp < CACHE_TTL) {\n        addressValidationCache.set(address, {\n            isAllowed: true,\n            timestamp: now\n        });\n        return true;\n    }\n    // Trigger async check to update cache\n    isAddressAllowedAsync(address).catch(console.error);\n    // Default to not allowed if we have no cached data yet\n    return false;\n}\n// Empty array for backward compatibility\nconst ALLOWED_ADDRESSES = [];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb25maWcvd2hpdGVsaXN0LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBRUQsK0JBQStCO0FBQy9CLElBQUlBLGtCQUFnRTtJQUNsRUMsT0FBTztJQUNQQyxXQUFXO0FBQ2I7QUFFQSx1Q0FBdUM7QUFDdkMsTUFBTUMseUJBQXlCLElBQUlDO0FBRW5DLHdDQUF3QztBQUN4QyxNQUFNQyxZQUFZLElBQUksS0FBSztBQUUzQjs7Q0FFQyxHQUNNLGVBQWVDO0lBQ3BCLElBQUk7UUFDRixvQkFBb0I7UUFDcEIsTUFBTUMsTUFBTUMsS0FBS0QsR0FBRztRQUNwQixJQUFJUCxnQkFBZ0JDLEtBQUssS0FBSyxRQUFRLE1BQU9ELGdCQUFnQkUsU0FBUyxHQUFJRyxXQUFXO1lBQ25GLE9BQU8sQ0FBQ0wsZ0JBQWdCQyxLQUFLO1FBQy9CO1FBRUEsTUFBTVEsV0FBVyxNQUFNQyxNQUFNO1FBQzdCLElBQUksQ0FBQ0QsU0FBU0UsRUFBRSxFQUFFO1lBQ2hCQyxRQUFRQyxLQUFLLENBQUMsa0NBQWtDLE1BQU1KLFNBQVNLLElBQUk7WUFDbkUsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsTUFBTUMsT0FBTyxNQUFNUCxTQUFTUSxJQUFJO1FBQ2hDTCxRQUFRTSxHQUFHLENBQUMsK0JBQStCRjtRQUUzQyxlQUFlO1FBQ2ZoQixrQkFBa0I7WUFDaEJDLE9BQU9lLEtBQUtHLFlBQVk7WUFDeEJqQixXQUFXSztRQUNiO1FBRUEsT0FBTyxDQUFDUyxLQUFLRyxZQUFZO0lBQzNCLEVBQUUsT0FBT04sT0FBTztRQUNkRCxRQUFRQyxLQUFLLENBQUMsa0NBQWtDQTtRQUNoRCwrQ0FBK0M7UUFDL0MsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNPO0lBQ2QsZ0RBQWdEO0lBQ2hELE1BQU1iLE1BQU1DLEtBQUtELEdBQUc7SUFDcEIsSUFBSVAsZ0JBQWdCQyxLQUFLLEtBQUssUUFBUSxNQUFPRCxnQkFBZ0JFLFNBQVMsR0FBSUcsV0FBVztRQUNuRixPQUFPLENBQUNMLGdCQUFnQkMsS0FBSztJQUMvQjtJQUVBLHNDQUFzQztJQUN0Q0ssK0JBQStCZSxLQUFLLENBQUNULFFBQVFDLEtBQUs7SUFFbEQsMERBQTBEO0lBQzFELE9BQU9iLGdCQUFnQkMsS0FBSyxLQUFLLE9BQU8sT0FBTyxDQUFDRCxnQkFBZ0JDLEtBQUs7QUFDdkU7QUFFQTs7Q0FFQyxHQUNNLGVBQWVxQixzQkFBc0JDLE9BQWtDO0lBQzVFLElBQUksQ0FBQ0EsU0FBUyxPQUFPO0lBRXJCLElBQUk7UUFDRixvQkFBb0I7UUFDcEIsTUFBTWhCLE1BQU1DLEtBQUtELEdBQUc7UUFDcEIsTUFBTWlCLFNBQVNyQix1QkFBdUJzQixHQUFHLENBQUNGO1FBQzFDLElBQUlDLFVBQVUsTUFBT0EsT0FBT3RCLFNBQVMsR0FBSUcsV0FBVztZQUNsRCxPQUFPbUIsT0FBT0UsU0FBUztRQUN6QjtRQUVBLHFGQUFxRjtRQUNyRixJQUFJMUIsZ0JBQWdCQyxLQUFLLEtBQUssUUFBUSxNQUFPRCxnQkFBZ0JFLFNBQVMsR0FBSUcsV0FBVztZQUNuRkYsdUJBQXVCd0IsR0FBRyxDQUFDSixTQUFTO2dCQUFFRyxXQUFXO2dCQUFNeEIsV0FBV0s7WUFBSTtZQUN0RSxPQUFPO1FBQ1Q7UUFFQSxNQUFNRSxXQUFXLE1BQU1DLE1BQU0sK0JBQStCO1lBQzFEa0IsUUFBUTtZQUNSQyxTQUFTO2dCQUFFLGdCQUFnQjtZQUFtQjtZQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO2dCQUFFVDtZQUFRO1FBQ2pDO1FBRUEsSUFBSSxDQUFDZCxTQUFTRSxFQUFFLEVBQUU7WUFDaEJDLFFBQVFDLEtBQUssQ0FBQyw2QkFBNkIsTUFBTUosU0FBU0ssSUFBSTtZQUM5RCxNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFFQSxNQUFNQyxPQUFPLE1BQU1QLFNBQVNRLElBQUk7UUFDaENMLFFBQVFNLEdBQUcsQ0FBQyxnQ0FBZ0NGO1FBRTVDLGVBQWU7UUFDZmIsdUJBQXVCd0IsR0FBRyxDQUFDSixTQUFTO1lBQ2xDRyxXQUFXVixLQUFLVSxTQUFTO1lBQ3pCeEIsV0FBV0s7UUFDYjtRQUVBLE9BQU9TLEtBQUtVLFNBQVM7SUFDdkIsRUFBRSxPQUFPYixPQUFPO1FBQ2RELFFBQVFDLEtBQUssQ0FBQyw2QkFBNkJBO1FBQzNDLE9BQU8sT0FBTyxvQ0FBb0M7SUFDcEQ7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU29CLGlCQUFpQlYsT0FBa0M7SUFDakUsSUFBSSxDQUFDQSxTQUFTLE9BQU87SUFFckIsTUFBTWhCLE1BQU1DLEtBQUtELEdBQUc7SUFFcEIsZ0RBQWdEO0lBQ2hELE1BQU1pQixTQUFTckIsdUJBQXVCc0IsR0FBRyxDQUFDRjtJQUMxQyxJQUFJQyxVQUFVLE1BQU9BLE9BQU90QixTQUFTLEdBQUlHLFdBQVc7UUFDbEQsT0FBT21CLE9BQU9FLFNBQVM7SUFDekI7SUFFQSxxRkFBcUY7SUFDckYsSUFBSTFCLGdCQUFnQkMsS0FBSyxLQUFLLFFBQVEsTUFBT0QsZ0JBQWdCRSxTQUFTLEdBQUlHLFdBQVc7UUFDbkZGLHVCQUF1QndCLEdBQUcsQ0FBQ0osU0FBUztZQUFFRyxXQUFXO1lBQU14QixXQUFXSztRQUFJO1FBQ3RFLE9BQU87SUFDVDtJQUVBLHNDQUFzQztJQUN0Q2Usc0JBQXNCQyxTQUFTRixLQUFLLENBQUNULFFBQVFDLEtBQUs7SUFFbEQsdURBQXVEO0lBQ3ZELE9BQU87QUFDVDtBQUVBLHlDQUF5QztBQUNsQyxNQUFNcUIsb0JBQXVDLEVBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29uZmlnL3doaXRlbGlzdC50cz9iNGMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV2hpdGVsaXN0IGNvbmZpZ3VyYXRpb25cbiAqIFRoaXMgdXNlcyBzZXJ2ZXItc2lkZSBBUEkgY2FsbHMgdG8gY2hlY2sgd2hpdGVsaXN0IHN0YXR1cyBzZWN1cmVseVxuICovXG5cbi8vIENhY2hlIGZvciBwdWJsaWMgbW9kZSBzdGF0dXNcbmxldCBwdWJsaWNNb2RlQ2FjaGU6IHsgdmFsdWU6IGJvb2xlYW4gfCBudWxsOyB0aW1lc3RhbXA6IG51bWJlciB9ID0ge1xuICB2YWx1ZTogbnVsbCxcbiAgdGltZXN0YW1wOiAwXG59O1xuXG4vLyBDYWNoZSBmb3IgYWRkcmVzcyB2YWxpZGF0aW9uIHJlc3VsdHNcbmNvbnN0IGFkZHJlc3NWYWxpZGF0aW9uQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgeyBpc0FsbG93ZWQ6IGJvb2xlYW47IHRpbWVzdGFtcDogbnVtYmVyIH0+KCk7XG5cbi8vIENhY2hlIFRUTCBpbiBtaWxsaXNlY29uZHMgKDUgbWludXRlcylcbmNvbnN0IENBQ0hFX1RUTCA9IDUgKiA2MCAqIDEwMDA7XG5cbi8qKlxuICogQ2hlY2sgaWYgYW55IGFkZHJlc3NlcyBhcmUgY29uZmlndXJlZCBpbiB0aGUgd2hpdGVsaXN0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYXNXaGl0ZWxpc3RlZEFkZHJlc3Nlc0FzeW5jKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAocHVibGljTW9kZUNhY2hlLnZhbHVlICE9PSBudWxsICYmIChub3cgLSBwdWJsaWNNb2RlQ2FjaGUudGltZXN0YW1wKSA8IENBQ0hFX1RUTCkge1xuICAgICAgcmV0dXJuICFwdWJsaWNNb2RlQ2FjaGUudmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9hdXRoL2NoZWNrLW1vZGUvJyk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgd2hpdGVsaXN0IG1vZGU6JywgYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNoZWNrIHdoaXRlbGlzdCBtb2RlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zb2xlLmxvZygnUHVibGljIG1vZGUgY2hlY2sgcmVzcG9uc2U6JywgZGF0YSk7XG5cbiAgICAvLyBVcGRhdGUgY2FjaGVcbiAgICBwdWJsaWNNb2RlQ2FjaGUgPSB7XG4gICAgICB2YWx1ZTogZGF0YS5pc1B1YmxpY01vZGUsXG4gICAgICB0aW1lc3RhbXA6IG5vd1xuICAgIH07XG5cbiAgICByZXR1cm4gIWRhdGEuaXNQdWJsaWNNb2RlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHdoaXRlbGlzdCBtb2RlOicsIGVycm9yKTtcbiAgICAvLyBBc3N1bWUgcmVzdHJpY3RlZCBtb2RlIGJ5IGRlZmF1bHQgZm9yIHNhZmV0eVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogU3luY2hyb25vdXMgdmVyc2lvbiB0aGF0IHVzZXMgY2FjaGVkIHJlc3VsdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzV2hpdGVsaXN0ZWRBZGRyZXNzZXMoKTogYm9vbGVhbiB7XG4gIC8vIFVzZSBjYWNoZWQgdmFsdWUgaWYgYXZhaWxhYmxlIGFuZCBub3QgZXhwaXJlZFxuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICBpZiAocHVibGljTW9kZUNhY2hlLnZhbHVlICE9PSBudWxsICYmIChub3cgLSBwdWJsaWNNb2RlQ2FjaGUudGltZXN0YW1wKSA8IENBQ0hFX1RUTCkge1xuICAgIHJldHVybiAhcHVibGljTW9kZUNhY2hlLnZhbHVlO1xuICB9XG5cbiAgLy8gVHJpZ2dlciBhc3luYyBjaGVjayB0byB1cGRhdGUgY2FjaGVcbiAgaGFzV2hpdGVsaXN0ZWRBZGRyZXNzZXNBc3luYygpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuXG4gIC8vIERlZmF1bHQgdG8gcmVzdHJpY3RlZCBtb2RlIGZvciBzYWZldHkgaWYgbm8gY2FjaGVkIGRhdGFcbiAgcmV0dXJuIHB1YmxpY01vZGVDYWNoZS52YWx1ZSA9PT0gbnVsbCA/IHRydWUgOiAhcHVibGljTW9kZUNhY2hlLnZhbHVlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgd2FsbGV0IGFkZHJlc3MgaXMgYWxsb3dlZCB0byBhY2Nlc3MgdGhlIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc0FkZHJlc3NBbGxvd2VkQXN5bmMoYWRkcmVzczogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBpZiAoIWFkZHJlc3MpIHJldHVybiBmYWxzZTtcblxuICB0cnkge1xuICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBjYWNoZWQgPSBhZGRyZXNzVmFsaWRhdGlvbkNhY2hlLmdldChhZGRyZXNzKTtcbiAgICBpZiAoY2FjaGVkICYmIChub3cgLSBjYWNoZWQudGltZXN0YW1wKSA8IENBQ0hFX1RUTCkge1xuICAgICAgcmV0dXJuIGNhY2hlZC5pc0FsbG93ZWQ7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIGRlZmluaXRpdmUgcHVibGljIG1vZGUgY2FjaGUgYW5kIGl0J3MgdHJ1ZSwgYWxsIGFkZHJlc3NlcyBhcmUgYWxsb3dlZFxuICAgIGlmIChwdWJsaWNNb2RlQ2FjaGUudmFsdWUgPT09IHRydWUgJiYgKG5vdyAtIHB1YmxpY01vZGVDYWNoZS50aW1lc3RhbXApIDwgQ0FDSEVfVFRMKSB7XG4gICAgICBhZGRyZXNzVmFsaWRhdGlvbkNhY2hlLnNldChhZGRyZXNzLCB7IGlzQWxsb3dlZDogdHJ1ZSwgdGltZXN0YW1wOiBub3cgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2F1dGgvdmFsaWRhdGUtYWRkcmVzcy8nLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBhZGRyZXNzIH0pXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2YWxpZGF0aW5nIGFkZHJlc3M6JywgYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHZhbGlkYXRlIGFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnNvbGUubG9nKCdBZGRyZXNzIHZhbGlkYXRpb24gcmVzcG9uc2U6JywgZGF0YSk7XG5cbiAgICAvLyBDYWNoZSByZXN1bHRcbiAgICBhZGRyZXNzVmFsaWRhdGlvbkNhY2hlLnNldChhZGRyZXNzLCB7XG4gICAgICBpc0FsbG93ZWQ6IGRhdGEuaXNBbGxvd2VkLFxuICAgICAgdGltZXN0YW1wOiBub3dcbiAgICB9KTtcblxuICAgIHJldHVybiBkYXRhLmlzQWxsb3dlZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2YWxpZGF0aW5nIGFkZHJlc3M6JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTsgLy8gRGVmYXVsdCB0byBub3QgYWxsb3dlZCBmb3Igc2FmZXR5XG4gIH1cbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91cyB2ZXJzaW9uIHRoYXQgdXNlcyBjYWNoZWQgcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3NBbGxvd2VkKGFkZHJlc3M6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgaWYgKCFhZGRyZXNzKSByZXR1cm4gZmFsc2U7XG5cbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAvLyBVc2UgY2FjaGVkIHZhbHVlIGlmIGF2YWlsYWJsZSBhbmQgbm90IGV4cGlyZWRcbiAgY29uc3QgY2FjaGVkID0gYWRkcmVzc1ZhbGlkYXRpb25DYWNoZS5nZXQoYWRkcmVzcyk7XG4gIGlmIChjYWNoZWQgJiYgKG5vdyAtIGNhY2hlZC50aW1lc3RhbXApIDwgQ0FDSEVfVFRMKSB7XG4gICAgcmV0dXJuIGNhY2hlZC5pc0FsbG93ZWQ7XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIGEgZGVmaW5pdGl2ZSBwdWJsaWMgbW9kZSBjYWNoZSBhbmQgaXQncyB0cnVlLCBhbGwgYWRkcmVzc2VzIGFyZSBhbGxvd2VkXG4gIGlmIChwdWJsaWNNb2RlQ2FjaGUudmFsdWUgPT09IHRydWUgJiYgKG5vdyAtIHB1YmxpY01vZGVDYWNoZS50aW1lc3RhbXApIDwgQ0FDSEVfVFRMKSB7XG4gICAgYWRkcmVzc1ZhbGlkYXRpb25DYWNoZS5zZXQoYWRkcmVzcywgeyBpc0FsbG93ZWQ6IHRydWUsIHRpbWVzdGFtcDogbm93IH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVHJpZ2dlciBhc3luYyBjaGVjayB0byB1cGRhdGUgY2FjaGVcbiAgaXNBZGRyZXNzQWxsb3dlZEFzeW5jKGFkZHJlc3MpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuXG4gIC8vIERlZmF1bHQgdG8gbm90IGFsbG93ZWQgaWYgd2UgaGF2ZSBubyBjYWNoZWQgZGF0YSB5ZXRcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBFbXB0eSBhcnJheSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuZXhwb3J0IGNvbnN0IEFMTE9XRURfQUREUkVTU0VTOiByZWFkb25seSBzdHJpbmdbXSA9IFtdO1xuIl0sIm5hbWVzIjpbInB1YmxpY01vZGVDYWNoZSIsInZhbHVlIiwidGltZXN0YW1wIiwiYWRkcmVzc1ZhbGlkYXRpb25DYWNoZSIsIk1hcCIsIkNBQ0hFX1RUTCIsImhhc1doaXRlbGlzdGVkQWRkcmVzc2VzQXN5bmMiLCJub3ciLCJEYXRlIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiY29uc29sZSIsImVycm9yIiwidGV4dCIsIkVycm9yIiwiZGF0YSIsImpzb24iLCJsb2ciLCJpc1B1YmxpY01vZGUiLCJoYXNXaGl0ZWxpc3RlZEFkZHJlc3NlcyIsImNhdGNoIiwiaXNBZGRyZXNzQWxsb3dlZEFzeW5jIiwiYWRkcmVzcyIsImNhY2hlZCIsImdldCIsImlzQWxsb3dlZCIsInNldCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImlzQWRkcmVzc0FsbG93ZWQiLCJBTExPV0VEX0FERFJFU1NFUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/config/whitelist.ts\n"));

/***/ })

});