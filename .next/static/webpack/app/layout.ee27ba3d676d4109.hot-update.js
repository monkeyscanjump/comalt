"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/config/constants.ts":
/*!*********************************!*\
  !*** ./src/config/constants.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APP_CONSTANTS: function() { return /* binding */ APP_CONSTANTS; },\n/* harmony export */   WALLET_CONSTANTS: function() { return /* binding */ WALLET_CONSTANTS; }\n/* harmony export */ });\nconst WALLET_CONSTANTS = {\n    STORAGE_KEY: \"wallet-account\",\n    JSON_PATH: \"wallet.json\"\n};\nconst APP_CONSTANTS = {\n    APP_NAME: \"comAlt\",\n    VERSION: \"1.0.0\"\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb25maWcvY29uc3RhbnRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU8sTUFBTUEsbUJBQW1CO0lBQzlCQyxhQUFhO0lBQ2JDLFdBQVc7QUFDYixFQUFFO0FBRUssTUFBTUMsZ0JBQWdCO0lBQzNCQyxVQUFVO0lBQ1ZDLFNBQVM7QUFDWCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb25maWcvY29uc3RhbnRzLnRzPzYxYzkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFdBTExFVF9DT05TVEFOVFMgPSB7XG4gIFNUT1JBR0VfS0VZOiAnd2FsbGV0LWFjY291bnQnLFxuICBKU09OX1BBVEg6ICd3YWxsZXQuanNvbicsXG59O1xuXG5leHBvcnQgY29uc3QgQVBQX0NPTlNUQU5UUyA9IHtcbiAgQVBQX05BTUU6ICdjb21BbHQnLFxuICBWRVJTSU9OOiAnMS4wLjAnLFxufTtcbiJdLCJuYW1lcyI6WyJXQUxMRVRfQ09OU1RBTlRTIiwiU1RPUkFHRV9LRVkiLCJKU09OX1BBVEgiLCJBUFBfQ09OU1RBTlRTIiwiQVBQX05BTUUiLCJWRVJTSU9OIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/config/constants.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/config/index.ts":
/*!*****************************!*\
  !*** ./src/config/index.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: function() { return /* binding */ config; }\n/* harmony export */ });\n/* harmony import */ var _utils_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/env */ \"(app-pages-browser)/./src/utils/env.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./src/config/constants.ts\");\n\n\nconst config = {\n    api: {\n        baseUrl: (0,_utils_env__WEBPACK_IMPORTED_MODULE_0__.getPublicEnv)(\"API_URL\", \"\"),\n        polkadotUrl: (0,_utils_env__WEBPACK_IMPORTED_MODULE_0__.getEnvVariable)(\"POLKADOT_API_URL\", \"https://rpc.polkadot.io\")\n    },\n    wallet: {\n        storageKey: _constants__WEBPACK_IMPORTED_MODULE_1__.WALLET_CONSTANTS.STORAGE_KEY,\n        jsonPath: _constants__WEBPACK_IMPORTED_MODULE_1__.WALLET_CONSTANTS.JSON_PATH\n    },\n    app: {\n        name: (0,_utils_env__WEBPACK_IMPORTED_MODULE_0__.getPublicEnv)(\"APP_NAME\", _constants__WEBPACK_IMPORTED_MODULE_1__.APP_CONSTANTS.APP_NAME),\n        version: (0,_utils_env__WEBPACK_IMPORTED_MODULE_0__.getPublicEnv)(\"APP_VERSION\", _constants__WEBPACK_IMPORTED_MODULE_1__.APP_CONSTANTS.VERSION)\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb25maWcvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJEO0FBQ0c7QUFFdkQsTUFBTUksU0FBUztJQUNwQkMsS0FBSztRQUNIQyxTQUFTTix3REFBWUEsQ0FBQyxXQUFXO1FBQ2pDTyxhQUFhTiwwREFBY0EsQ0FBQyxvQkFBb0I7SUFDbEQ7SUFDQU8sUUFBUTtRQUNOQyxZQUFZUCx3REFBZ0JBLENBQUNRLFdBQVc7UUFDeENDLFVBQVVULHdEQUFnQkEsQ0FBQ1UsU0FBUztJQUN0QztJQUNBQyxLQUFLO1FBQ0hDLE1BQU1kLHdEQUFZQSxDQUFDLFlBQVlHLHFEQUFhQSxDQUFDWSxRQUFRO1FBQ3JEQyxTQUFTaEIsd0RBQVlBLENBQUMsZUFBZUcscURBQWFBLENBQUNjLE9BQU87SUFDNUQ7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb25maWcvaW5kZXgudHM/ZGE5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRQdWJsaWNFbnYsIGdldEVudlZhcmlhYmxlIH0gZnJvbSAnQC91dGlscy9lbnYnO1xuaW1wb3J0IHsgV0FMTEVUX0NPTlNUQU5UUywgQVBQX0NPTlNUQU5UUyB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IHtcbiAgYXBpOiB7XG4gICAgYmFzZVVybDogZ2V0UHVibGljRW52KCdBUElfVVJMJywgJycpLFxuICAgIHBvbGthZG90VXJsOiBnZXRFbnZWYXJpYWJsZSgnUE9MS0FET1RfQVBJX1VSTCcsICdodHRwczovL3JwYy5wb2xrYWRvdC5pbycpXG4gIH0sXG4gIHdhbGxldDoge1xuICAgIHN0b3JhZ2VLZXk6IFdBTExFVF9DT05TVEFOVFMuU1RPUkFHRV9LRVksXG4gICAganNvblBhdGg6IFdBTExFVF9DT05TVEFOVFMuSlNPTl9QQVRILFxuICB9LFxuICBhcHA6IHtcbiAgICBuYW1lOiBnZXRQdWJsaWNFbnYoJ0FQUF9OQU1FJywgQVBQX0NPTlNUQU5UUy5BUFBfTkFNRSksXG4gICAgdmVyc2lvbjogZ2V0UHVibGljRW52KCdBUFBfVkVSU0lPTicsIEFQUF9DT05TVEFOVFMuVkVSU0lPTiksXG4gIH1cbn07XG4iXSwibmFtZXMiOlsiZ2V0UHVibGljRW52IiwiZ2V0RW52VmFyaWFibGUiLCJXQUxMRVRfQ09OU1RBTlRTIiwiQVBQX0NPTlNUQU5UUyIsImNvbmZpZyIsImFwaSIsImJhc2VVcmwiLCJwb2xrYWRvdFVybCIsIndhbGxldCIsInN0b3JhZ2VLZXkiLCJTVE9SQUdFX0tFWSIsImpzb25QYXRoIiwiSlNPTl9QQVRIIiwiYXBwIiwibmFtZSIsIkFQUF9OQU1FIiwidmVyc2lvbiIsIlZFUlNJT04iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/config/index.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/contexts/auth/AuthProvider.tsx":
/*!********************************************!*\
  !*** ./src/contexts/auth/AuthProvider.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthContext */ \"(app-pages-browser)/./src/contexts/auth/AuthContext.tsx\");\n/* harmony import */ var _WalletService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WalletService */ \"(app-pages-browser)/./src/contexts/auth/WalletService.ts\");\n/* harmony import */ var _config_whitelist__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/config/whitelist */ \"(app-pages-browser)/./src/config/whitelist.ts\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst AuthProvider = (param)=>{\n    let { children } = param;\n    _s();\n    // Account and wallet states\n    const [walletAddress, setWalletAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [accounts, setAccounts] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [selectedAccount, setSelectedAccount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // UI states\n    const [isConnecting, setIsConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [showAccountSelector, setShowAccountSelector] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Authentication states\n    const [isAuthenticated, setIsAuthenticated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isAllowed, setIsAllowed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [token, setToken] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Signature states\n    const [wasSignatureRejected, setWasSignatureRejected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isRequestingSignature, setIsRequestingSignature] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Public mode detection\n    const isPublicMode = !(0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.hasWhitelistedAddresses)();\n    // Calculate derived states\n    const isWalletConnected = !!selectedAccount || !!walletAddress;\n    // Initialize auth state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const initAuth = async ()=>{\n            try {\n                // Restore connection from localStorage if available\n                const storedAddress = localStorage.getItem(\"wallet-address\");\n                const storedToken = localStorage.getItem(\"auth-token\");\n                if (storedAddress) {\n                    setWalletAddress(storedAddress);\n                    // Get accounts if extension is available\n                    try {\n                        const isEnabled = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.enableWallet();\n                        if (isEnabled) {\n                            const walletAccounts = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.getAccounts();\n                            setAccounts(walletAccounts);\n                            // Find the stored account\n                            const account = walletAccounts.find((acc)=>acc.address === storedAddress);\n                            if (account) {\n                                setSelectedAccount(account);\n                            }\n                        }\n                    } catch (err) {\n                        console.warn(\"Failed to restore wallet connection:\", err);\n                    }\n                    // Restore auth state\n                    if (storedToken) {\n                        setToken(storedToken);\n                        setIsAuthenticated(true);\n                        setIsAllowed(true);\n                        try {\n                            // Optionally restore user data if you have it\n                            const userData = localStorage.getItem(\"user-data\");\n                            if (userData) {\n                                setUser(JSON.parse(userData));\n                            }\n                        } catch (e) {\n                            console.warn(\"Failed to restore user data:\", e);\n                        }\n                    }\n                }\n            } catch (err) {\n                console.error(\"Error initializing auth:\", err);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        initAuth();\n    }, []);\n    // Connect wallet\n    const connect = async ()=>{\n        setIsConnecting(true);\n        setError(null);\n        try {\n            // Enable wallet extension\n            const isEnabled = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.enableWallet();\n            if (!isEnabled) {\n                throw new Error(\"Wallet extension not found or not enabled\");\n            }\n            // Get accounts\n            const walletAccounts = await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.getAccounts();\n            if (!walletAccounts || walletAccounts.length === 0) {\n                throw new Error(\"No accounts found in wallet\");\n            }\n            // Update state\n            setAccounts(walletAccounts);\n            setShowAccountSelector(true);\n            return true;\n        } catch (err) {\n            console.error(\"Wallet connection error:\", err);\n            setError(err instanceof Error ? err.message : \"Failed to connect wallet\");\n            return false;\n        } finally{\n            setIsConnecting(false);\n        }\n    };\n    // Select account\n    const selectAccount = async (account)=>{\n        setSelectedAccount(account);\n        setWalletAddress(account.address);\n        setShowAccountSelector(false);\n        // Save to localStorage\n        localStorage.setItem(\"wallet-address\", account.address);\n        // Check if the account is allowed\n        const allowed = isPublicMode || (0,_config_whitelist__WEBPACK_IMPORTED_MODULE_4__.hasWhitelistedAddresses)();\n        setIsAllowed(allowed);\n        if (allowed) {\n            // Request signature\n            try {\n                const success = await requestSignature(account.address);\n                if (!success) {\n                    console.warn(\"Signature request failed or was rejected\");\n                }\n            } catch (err) {\n                console.error(\"Error during signature request:\", err);\n                setError(err instanceof Error ? err.message : \"Authentication failed\");\n            }\n        }\n    };\n    // Sign message\n    const signMessage = async (message, accountOverride)=>{\n        const addressToUse = (accountOverride === null || accountOverride === void 0 ? void 0 : accountOverride.address) || (selectedAccount === null || selectedAccount === void 0 ? void 0 : selectedAccount.address) || walletAddress;\n        if (!addressToUse) return null;\n        try {\n            return await _WalletService__WEBPACK_IMPORTED_MODULE_3__.WalletService.signMessage(addressToUse, message);\n        } catch (err) {\n            console.error(\"Signature error:\", err);\n            // Check if user rejected\n            if (err instanceof Error && err.message.includes(\"reject\")) {\n                setWasSignatureRejected(true);\n            }\n            throw err;\n        }\n    };\n    // Request signature for authentication\n    const requestSignature = async (address)=>{\n        if (!address) return false;\n        setIsRequestingSignature(true);\n        setWasSignatureRejected(false);\n        try {\n            var _selectedAccount_meta;\n            // Create a unique message\n            const message = \"Sign this message to authenticate with Download Manager: \".concat(Date.now());\n            // Get signature\n            const signature = await signMessage(message);\n            if (!signature) return false;\n            // In a real app, you'd verify this signature on the server\n            // For demo, we'll just set a token\n            const demoToken = \"demo-auth-token-\" + Date.now();\n            setToken(demoToken);\n            localStorage.setItem(\"auth-token\", demoToken);\n            // Set authenticated state\n            setIsAuthenticated(true);\n            // Create demo user\n            const demoUser = {\n                id: \"1\",\n                address,\n                isAdmin: true,\n                username: (selectedAccount === null || selectedAccount === void 0 ? void 0 : (_selectedAccount_meta = selectedAccount.meta) === null || _selectedAccount_meta === void 0 ? void 0 : _selectedAccount_meta.name) || \"User\"\n            };\n            setUser(demoUser);\n            localStorage.setItem(\"user-data\", JSON.stringify(demoUser));\n            return true;\n        } catch (err) {\n            console.error(\"Signature request failed:\", err);\n            return false;\n        } finally{\n            setIsRequestingSignature(false);\n        }\n    };\n    // Refresh auth token\n    const refreshAuthToken = async ()=>{\n        // In a real app, this would refresh the token with the server\n        // For demo, we'll just generate a new token\n        if (!isAuthenticated || !walletAddress) return false;\n        try {\n            const newToken = \"refreshed-token-\" + Date.now();\n            setToken(newToken);\n            localStorage.setItem(\"auth-token\", newToken);\n            return true;\n        } catch (err) {\n            console.error(\"Token refresh failed:\", err);\n            return false;\n        }\n    };\n    // Logout\n    const logout = ()=>{\n        setSelectedAccount(null);\n        setWalletAddress(null);\n        setIsAuthenticated(false);\n        setIsAllowed(false);\n        setUser(null);\n        setToken(null);\n        // Clear localStorage\n        localStorage.removeItem(\"wallet-address\");\n        localStorage.removeItem(\"auth-token\");\n        localStorage.removeItem(\"user-data\");\n    };\n    // Reset rejection state\n    const resetRejectionState = ()=>{\n        setWasSignatureRejected(false);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_AuthContext__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Provider, {\n        value: {\n            // Account states\n            walletAddress,\n            accounts,\n            selectedAccount,\n            // UI states\n            error,\n            showAccountSelector,\n            setShowAccountSelector,\n            // User data\n            user,\n            token,\n            // Core methods\n            logout,\n            connect,\n            selectAccount,\n            signMessage,\n            refreshAuthToken,\n            requestSignature,\n            // Signature states\n            wasSignatureRejected,\n            isRequestingSignature,\n            resetRejectionState,\n            // Derived states\n            isPublicMode,\n            isWalletConnected,\n            isAuthenticated,\n            isLoading,\n            isAllowed,\n            isConnecting\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\crist\\\\monkeyscanjump\\\\download-manager\\\\src\\\\contexts\\\\auth\\\\AuthProvider.tsx\",\n        lineNumber: 252,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AuthProvider, \"5ZyDRWWtJ2mNA+6ABUIrbFatU80=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9hdXRoL0F1dGhQcm92aWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRW1EO0FBQ1g7QUFDUTtBQUNhO0FBSXRELE1BQU1NLGVBQWU7UUFBQyxFQUFFQyxRQUFRLEVBQWlDOztJQUN0RSw0QkFBNEI7SUFDNUIsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR1IsK0NBQVFBLENBQWdCO0lBQ2xFLE1BQU0sQ0FBQ1MsVUFBVUMsWUFBWSxHQUFHViwrQ0FBUUEsQ0FBNEIsRUFBRTtJQUN0RSxNQUFNLENBQUNXLGlCQUFpQkMsbUJBQW1CLEdBQUdaLCtDQUFRQSxDQUFpQztJQUV2RixZQUFZO0lBQ1osTUFBTSxDQUFDYSxjQUFjQyxnQkFBZ0IsR0FBR2QsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDZSxXQUFXQyxhQUFhLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNpQixPQUFPQyxTQUFTLEdBQUdsQiwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTSxDQUFDbUIscUJBQXFCQyx1QkFBdUIsR0FBR3BCLCtDQUFRQSxDQUFDO0lBRS9ELHdCQUF3QjtJQUN4QixNQUFNLENBQUNxQixpQkFBaUJDLG1CQUFtQixHQUFHdEIsK0NBQVFBLENBQUM7SUFDdkQsTUFBTSxDQUFDdUIsV0FBV0MsYUFBYSxHQUFHeEIsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDeUIsTUFBTUMsUUFBUSxHQUFHMUIsK0NBQVFBLENBQWM7SUFDOUMsTUFBTSxDQUFDMkIsT0FBT0MsU0FBUyxHQUFHNUIsK0NBQVFBLENBQWdCO0lBRWxELG1CQUFtQjtJQUNuQixNQUFNLENBQUM2QixzQkFBc0JDLHdCQUF3QixHQUFHOUIsK0NBQVFBLENBQUM7SUFDakUsTUFBTSxDQUFDK0IsdUJBQXVCQyx5QkFBeUIsR0FBR2hDLCtDQUFRQSxDQUFDO0lBRW5FLHdCQUF3QjtJQUN4QixNQUFNaUMsZUFBZSxDQUFDN0Is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QjlFO1lBQ0FFO1lBQ0FFO1lBRUEsWUFBWTtZQUNaTTtZQUNBRTtZQUNBQztZQUVBLFlBQVk7WUFDWks7WUFDQUU7WUFFQSxlQUFlO1lBQ2ZzRDtZQUNBMUI7WUFDQUk7WUFDQUs7WUFDQWU7WUFDQWhCO1lBRUEsbUJBQW1CO1lBQ25CbEM7WUFDQUU7WUFDQW9EO1lBRUEsaUJBQWlCO1lBQ2pCbEQ7WUFDQUM7WUFDQWI7WUFDQU47WUFDQVE7WUFDQVY7UUFDRjtrQkFFQ1A7Ozs7OztBQUdQLEVBQUU7R0EzUldEO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0cy9hdXRoL0F1dGhQcm92aWRlci50c3g/ODRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQXV0aENvbnRleHQgZnJvbSAnLi9BdXRoQ29udGV4dCc7XG5pbXBvcnQgeyBXYWxsZXRTZXJ2aWNlIH0gZnJvbSAnLi9XYWxsZXRTZXJ2aWNlJztcbmltcG9ydCB7IGhhc1doaXRlbGlzdGVkQWRkcmVzc2VzIH0gZnJvbSAnQC9jb25maWcvd2hpdGVsaXN0JztcbmltcG9ydCB0eXBlIHsgSW5qZWN0ZWRBY2NvdW50V2l0aE1ldGEgfSBmcm9tICdAcG9sa2Fkb3QvZXh0ZW5zaW9uLWluamVjdC90eXBlcyc7XG5pbXBvcnQgdHlwZSB7IFVzZXIgfSBmcm9tICdAL3R5cGVzL3VzZXInO1xuXG5leHBvcnQgY29uc3QgQXV0aFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pID0+IHtcbiAgLy8gQWNjb3VudCBhbmQgd2FsbGV0IHN0YXRlc1xuICBjb25zdCBbd2FsbGV0QWRkcmVzcywgc2V0V2FsbGV0QWRkcmVzc10gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2FjY291bnRzLCBzZXRBY2NvdW50c10gPSB1c2VTdGF0ZTxJbmplY3RlZEFjY291bnRXaXRoTWV0YVtdPihbXSk7XG4gIGNvbnN0IFtzZWxlY3RlZEFjY291bnQsIHNldFNlbGVjdGVkQWNjb3VudF0gPSB1c2VTdGF0ZTxJbmplY3RlZEFjY291bnRXaXRoTWV0YSB8IG51bGw+KG51bGwpO1xuXG4gIC8vIFVJIHN0YXRlc1xuICBjb25zdCBbaXNDb25uZWN0aW5nLCBzZXRJc0Nvbm5lY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzaG93QWNjb3VudFNlbGVjdG9yLCBzZXRTaG93QWNjb3VudFNlbGVjdG9yXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBBdXRoZW50aWNhdGlvbiBzdGF0ZXNcbiAgY29uc3QgW2lzQXV0aGVudGljYXRlZCwgc2V0SXNBdXRoZW50aWNhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzQWxsb3dlZCwgc2V0SXNBbGxvd2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGU8VXNlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbdG9rZW4sIHNldFRva2VuXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIFNpZ25hdHVyZSBzdGF0ZXNcbiAgY29uc3QgW3dhc1NpZ25hdHVyZVJlamVjdGVkLCBzZXRXYXNTaWduYXR1cmVSZWplY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc1JlcXVlc3RpbmdTaWduYXR1cmUsIHNldElzUmVxdWVzdGluZ1NpZ25hdHVyZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gUHVibGljIG1vZGUgZGV0ZWN0aW9uXG4gIGNvbnN0IGlzUHVibGljTW9kZSA9ICFoYXNXaGl0ZWxpc3RlZEFkZHJlc3NlcygpO1xuXG4gIC8vIENhbGN1bGF0ZSBkZXJpdmVkIHN0YXRlc1xuICBjb25zdCBpc1dhbGxldENvbm5lY3RlZCA9ICEhc2VsZWN0ZWRBY2NvdW50IHx8ICEhd2FsbGV0QWRkcmVzcztcblxuICAvLyBJbml0aWFsaXplIGF1dGggc3RhdGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpbml0QXV0aCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFJlc3RvcmUgY29ubmVjdGlvbiBmcm9tIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgY29uc3Qgc3RvcmVkQWRkcmVzcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxsZXQtYWRkcmVzcycpO1xuICAgICAgICBjb25zdCBzdG9yZWRUb2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoLXRva2VuJyk7XG5cbiAgICAgICAgaWYgKHN0b3JlZEFkZHJlc3MpIHtcbiAgICAgICAgICBzZXRXYWxsZXRBZGRyZXNzKHN0b3JlZEFkZHJlc3MpO1xuXG4gICAgICAgICAgLy8gR2V0IGFjY291bnRzIGlmIGV4dGVuc2lvbiBpcyBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNFbmFibGVkID0gYXdhaXQgV2FsbGV0U2VydmljZS5lbmFibGVXYWxsZXQoKTtcbiAgICAgICAgICAgIGlmIChpc0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0QWNjb3VudHMgPSBhd2FpdCBXYWxsZXRTZXJ2aWNlLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICAgIHNldEFjY291bnRzKHdhbGxldEFjY291bnRzKTtcblxuICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBzdG9yZWQgYWNjb3VudFxuICAgICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gd2FsbGV0QWNjb3VudHMuZmluZChhY2MgPT4gYWNjLmFkZHJlc3MgPT09IHN0b3JlZEFkZHJlc3MpO1xuICAgICAgICAgICAgICBpZiAoYWNjb3VudCkge1xuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkQWNjb3VudChhY2NvdW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcmVzdG9yZSB3YWxsZXQgY29ubmVjdGlvbjonLCBlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlc3RvcmUgYXV0aCBzdGF0ZVxuICAgICAgICAgIGlmIChzdG9yZWRUb2tlbikge1xuICAgICAgICAgICAgc2V0VG9rZW4oc3RvcmVkVG9rZW4pO1xuICAgICAgICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKHRydWUpO1xuICAgICAgICAgICAgc2V0SXNBbGxvd2VkKHRydWUpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBPcHRpb25hbGx5IHJlc3RvcmUgdXNlciBkYXRhIGlmIHlvdSBoYXZlIGl0XG4gICAgICAgICAgICAgIGNvbnN0IHVzZXJEYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXItZGF0YScpO1xuICAgICAgICAgICAgICBpZiAodXNlckRhdGEpIHtcbiAgICAgICAgICAgICAgICBzZXRVc2VyKEpTT04ucGFyc2UodXNlckRhdGEpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byByZXN0b3JlIHVzZXIgZGF0YTonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgYXV0aDonLCBlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaW5pdEF1dGgoKTtcbiAgfSwgW10pO1xuXG4gIC8vIENvbm5lY3Qgd2FsbGV0XG4gIGNvbnN0IGNvbm5lY3QgPSBhc3luYyAoKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgc2V0SXNDb25uZWN0aW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEVuYWJsZSB3YWxsZXQgZXh0ZW5zaW9uXG4gICAgICBjb25zdCBpc0VuYWJsZWQgPSBhd2FpdCBXYWxsZXRTZXJ2aWNlLmVuYWJsZVdhbGxldCgpO1xuICAgICAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgZXh0ZW5zaW9uIG5vdCBmb3VuZCBvciBub3QgZW5hYmxlZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgYWNjb3VudHNcbiAgICAgIGNvbnN0IHdhbGxldEFjY291bnRzID0gYXdhaXQgV2FsbGV0U2VydmljZS5nZXRBY2NvdW50cygpO1xuICAgICAgaWYgKCF3YWxsZXRBY2NvdW50cyB8fCB3YWxsZXRBY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY2NvdW50cyBmb3VuZCBpbiB3YWxsZXQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgICBzZXRBY2NvdW50cyh3YWxsZXRBY2NvdW50cyk7XG4gICAgICBzZXRTaG93QWNjb3VudFNlbGVjdG9yKHRydWUpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1dhbGxldCBjb25uZWN0aW9uIGVycm9yOicsIGVycik7XG4gICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBjb25uZWN0IHdhbGxldCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0Nvbm5lY3RpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBTZWxlY3QgYWNjb3VudFxuICBjb25zdCBzZWxlY3RBY2NvdW50ID0gYXN5bmMgKGFjY291bnQ6IEluamVjdGVkQWNjb3VudFdpdGhNZXRhKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgc2V0U2VsZWN0ZWRBY2NvdW50KGFjY291bnQpO1xuICAgIHNldFdhbGxldEFkZHJlc3MoYWNjb3VudC5hZGRyZXNzKTtcbiAgICBzZXRTaG93QWNjb3VudFNlbGVjdG9yKGZhbHNlKTtcblxuICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dhbGxldC1hZGRyZXNzJywgYWNjb3VudC5hZGRyZXNzKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBhY2NvdW50IGlzIGFsbG93ZWRcbiAgICBjb25zdCBhbGxvd2VkID0gaXNQdWJsaWNNb2RlIHx8IGhhc1doaXRlbGlzdGVkQWRkcmVzc2VzKCk7XG4gICAgc2V0SXNBbGxvd2VkKGFsbG93ZWQpO1xuXG4gICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgIC8vIFJlcXVlc3Qgc2lnbmF0dXJlXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgcmVxdWVzdFNpZ25hdHVyZShhY2NvdW50LmFkZHJlc3MpO1xuICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1NpZ25hdHVyZSByZXF1ZXN0IGZhaWxlZCBvciB3YXMgcmVqZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBzaWduYXR1cmUgcmVxdWVzdDonLCBlcnIpO1xuICAgICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBTaWduIG1lc3NhZ2VcbiAgY29uc3Qgc2lnbk1lc3NhZ2UgPSBhc3luYyAobWVzc2FnZTogc3RyaW5nLCBhY2NvdW50T3ZlcnJpZGU/OiBJbmplY3RlZEFjY291bnRXaXRoTWV0YSk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4gPT4ge1xuICAgIGNvbnN0IGFkZHJlc3NUb1VzZSA9IGFjY291bnRPdmVycmlkZT8uYWRkcmVzcyB8fCBzZWxlY3RlZEFjY291bnQ/LmFkZHJlc3MgfHwgd2FsbGV0QWRkcmVzcztcbiAgICBpZiAoIWFkZHJlc3NUb1VzZSkgcmV0dXJuIG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IFdhbGxldFNlcnZpY2Uuc2lnbk1lc3NhZ2UoYWRkcmVzc1RvVXNlLCBtZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpZ25hdHVyZSBlcnJvcjonLCBlcnIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB1c2VyIHJlamVjdGVkXG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ3JlamVjdCcpKSB7XG4gICAgICAgIHNldFdhc1NpZ25hdHVyZVJlamVjdGVkKHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlcXVlc3Qgc2lnbmF0dXJlIGZvciBhdXRoZW50aWNhdGlvblxuICBjb25zdCByZXF1ZXN0U2lnbmF0dXJlID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGlmICghYWRkcmVzcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgc2V0SXNSZXF1ZXN0aW5nU2lnbmF0dXJlKHRydWUpO1xuICAgIHNldFdhc1NpZ25hdHVyZVJlamVjdGVkKGZhbHNlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgYSB1bmlxdWUgbWVzc2FnZVxuICAgICAgY29uc3QgbWVzc2FnZSA9IGBTaWduIHRoaXMgbWVzc2FnZSB0byBhdXRoZW50aWNhdGUgd2l0aCBEb3dubG9hZCBNYW5hZ2VyOiAke0RhdGUubm93KCl9YDtcblxuICAgICAgLy8gR2V0IHNpZ25hdHVyZVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICBpZiAoIXNpZ25hdHVyZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBJbiBhIHJlYWwgYXBwLCB5b3UnZCB2ZXJpZnkgdGhpcyBzaWduYXR1cmUgb24gdGhlIHNlcnZlclxuICAgICAgLy8gRm9yIGRlbW8sIHdlJ2xsIGp1c3Qgc2V0IGEgdG9rZW5cbiAgICAgIGNvbnN0IGRlbW9Ub2tlbiA9ICdkZW1vLWF1dGgtdG9rZW4tJyArIERhdGUubm93KCk7XG4gICAgICBzZXRUb2tlbihkZW1vVG9rZW4pO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGgtdG9rZW4nLCBkZW1vVG9rZW4pO1xuXG4gICAgICAvLyBTZXQgYXV0aGVudGljYXRlZCBzdGF0ZVxuICAgICAgc2V0SXNBdXRoZW50aWNhdGVkKHRydWUpO1xuXG4gICAgICAvLyBDcmVhdGUgZGVtbyB1c2VyXG4gICAgICBjb25zdCBkZW1vVXNlciA9IHtcbiAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgaXNBZG1pbjogdHJ1ZSxcbiAgICAgICAgdXNlcm5hbWU6IHNlbGVjdGVkQWNjb3VudD8ubWV0YT8ubmFtZSB8fCAnVXNlcidcbiAgICAgIH07XG4gICAgICBzZXRVc2VyKGRlbW9Vc2VyKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VyLWRhdGEnLCBKU09OLnN0cmluZ2lmeShkZW1vVXNlcikpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1NpZ25hdHVyZSByZXF1ZXN0IGZhaWxlZDonLCBlcnIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1JlcXVlc3RpbmdTaWduYXR1cmUoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWZyZXNoIGF1dGggdG9rZW5cbiAgY29uc3QgcmVmcmVzaEF1dGhUb2tlbiA9IGFzeW5jICgpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAvLyBJbiBhIHJlYWwgYXBwLCB0aGlzIHdvdWxkIHJlZnJlc2ggdGhlIHRva2VuIHdpdGggdGhlIHNlcnZlclxuICAgIC8vIEZvciBkZW1vLCB3ZSdsbCBqdXN0IGdlbmVyYXRlIGEgbmV3IHRva2VuXG4gICAgaWYgKCFpc0F1dGhlbnRpY2F0ZWQgfHwgIXdhbGxldEFkZHJlc3MpIHJldHVybiBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXdUb2tlbiA9ICdyZWZyZXNoZWQtdG9rZW4tJyArIERhdGUubm93KCk7XG4gICAgICBzZXRUb2tlbihuZXdUb2tlbik7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYXV0aC10b2tlbicsIG5ld1Rva2VuKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gcmVmcmVzaCBmYWlsZWQ6JywgZXJyKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gTG9nb3V0XG4gIGNvbnN0IGxvZ291dCA9ICgpID0+IHtcbiAgICBzZXRTZWxlY3RlZEFjY291bnQobnVsbCk7XG4gICAgc2V0V2FsbGV0QWRkcmVzcyhudWxsKTtcbiAgICBzZXRJc0F1dGhlbnRpY2F0ZWQoZmFsc2UpO1xuICAgIHNldElzQWxsb3dlZChmYWxzZSk7XG4gICAgc2V0VXNlcihudWxsKTtcbiAgICBzZXRUb2tlbihudWxsKTtcblxuICAgIC8vIENsZWFyIGxvY2FsU3RvcmFnZVxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd3YWxsZXQtYWRkcmVzcycpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoLXRva2VuJyk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXItZGF0YScpO1xuICB9O1xuXG4gIC8vIFJlc2V0IHJlamVjdGlvbiBzdGF0ZVxuICBjb25zdCByZXNldFJlamVjdGlvblN0YXRlID0gKCkgPT4ge1xuICAgIHNldFdhc1NpZ25hdHVyZVJlamVjdGVkKGZhbHNlKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxBdXRoQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgLy8gQWNjb3VudCBzdGF0ZXNcbiAgICAgICAgd2FsbGV0QWRkcmVzcyxcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIHNlbGVjdGVkQWNjb3VudCxcblxuICAgICAgICAvLyBVSSBzdGF0ZXNcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHNob3dBY2NvdW50U2VsZWN0b3IsXG4gICAgICAgIHNldFNob3dBY2NvdW50U2VsZWN0b3IsXG5cbiAgICAgICAgLy8gVXNlciBkYXRhXG4gICAgICAgIHVzZXIsXG4gICAgICAgIHRva2VuLFxuXG4gICAgICAgIC8vIENvcmUgbWV0aG9kc1xuICAgICAgICBsb2dvdXQsXG4gICAgICAgIGNvbm5lY3QsXG4gICAgICAgIHNlbGVjdEFjY291bnQsXG4gICAgICAgIHNpZ25NZXNzYWdlLFxuICAgICAgICByZWZyZXNoQXV0aFRva2VuLFxuICAgICAgICByZXF1ZXN0U2lnbmF0dXJlLFxuXG4gICAgICAgIC8vIFNpZ25hdHVyZSBzdGF0ZXNcbiAgICAgICAgd2FzU2lnbmF0dXJlUmVqZWN0ZWQsXG4gICAgICAgIGlzUmVxdWVzdGluZ1NpZ25hdHVyZSxcbiAgICAgICAgcmVzZXRSZWplY3Rpb25TdGF0ZSxcblxuICAgICAgICAvLyBEZXJpdmVkIHN0YXRlc1xuICAgICAgICBpc1B1YmxpY01vZGUsXG4gICAgICAgIGlzV2FsbGV0Q29ubmVjdGVkLFxuICAgICAgICBpc0F1dGhlbnRpY2F0ZWQsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgaXNBbGxvd2VkLFxuICAgICAgICBpc0Nvbm5lY3RpbmdcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQXV0aENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJBdXRoQ29udGV4dCIsIldhbGxldFNlcnZpY2UiLCJoYXNXaGl0ZWxpc3RlZEFkZHJlc3NlcyIsIkF1dGhQcm92aWRlciIsImNoaWxkcmVuIiwid2FsbGV0QWRkcmVzcyIsInNldFdhbGxldEFkZHJlc3MiLCJhY2NvdW50cyIsInNldEFjY291bnRzIiwic2VsZWN0ZWRBY2NvdW50Iiwic2V0U2VsZWN0ZWRBY2NvdW50IiwiaXNDb25uZWN0aW5nIiwic2V0SXNDb25uZWN0aW5nIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsInNob3dBY2NvdW50U2VsZWN0b3IiLCJzZXRTaG93QWNjb3VudFNlbGVjdG9yIiwiaXNBdXRoZW50aWNhdGVkIiwic2V0SXNBdXRoZW50aWNhdGVkIiwiaXNBbGxvd2VkIiwic2V0SXNBbGxvd2VkIiwidXNlciIsInNldFVzZXIiLCJ0b2tlbiIsInNldFRva2VuIiwid2FzU2lnbmF0dXJlUmVqZWN0ZWQiLCJzZXRXYXNTaWduYXR1cmVSZWplY3RlZCIsImlzUmVxdWVzdGluZ1NpZ25hdHVyZSIsInNldElzUmVxdWVzdGluZ1NpZ25hdHVyZSIsImlzUHVibGljTW9kZSIsImlzV2FsbGV0Q29ubmVjdGVkIiwiaW5pdEF1dGgiLCJzdG9yZWRBZGRyZXNzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInN0b3JlZFRva2VuIiwiaXNFbmFibGVkIiwiZW5hYmxlV2FsbGV0Iiwid2FsbGV0QWNjb3VudHMiLCJnZXRBY2NvdW50cyIsImFjY291bnQiLCJmaW5kIiwiYWNjIiwiYWRkcmVzcyIsImVyciIsImNvbnNvbGUiLCJ3YXJuIiwidXNlckRhdGEiLCJKU09OIiwicGFyc2UiLCJlIiwiY29ubmVjdCIsIkVycm9yIiwibGVuZ3RoIiwibWVzc2FnZSIsInNlbGVjdEFjY291bnQiLCJzZXRJdGVtIiwiYWxsb3dlZCIsInN1Y2Nlc3MiLCJyZXF1ZXN0U2lnbmF0dXJlIiwic2lnbk1lc3NhZ2UiLCJhY2NvdW50T3ZlcnJpZGUiLCJhZGRyZXNzVG9Vc2UiLCJpbmNsdWRlcyIsIkRhdGUiLCJub3ciLCJzaWduYXR1cmUiLCJkZW1vVG9rZW4iLCJkZW1vVXNlciIsImlkIiwiaXNBZG1pbiIsInVzZXJuYW1lIiwibWV0YSIsIm5hbWUiLCJzdHJpbmdpZnkiLCJyZWZyZXNoQXV0aFRva2VuIiwibmV3VG9rZW4iLCJsb2dvdXQiLCJyZW1vdmVJdGVtIiwicmVzZXRSZWplY3Rpb25TdGF0ZSIsIlByb3ZpZGVyIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/auth/AuthProvider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/contexts/auth/WalletService.ts":
/*!********************************************!*\
  !*** ./src/contexts/auth/WalletService.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletService: function() { return /* binding */ WalletService; }\n/* harmony export */ });\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/config */ \"(app-pages-browser)/./src/config/index.ts\");\n/* harmony import */ var _lib_polkadot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/polkadot */ \"(app-pages-browser)/./src/lib/polkadot.ts\");\n\n\nclass WalletService {\n    /**\n   * Check if wallet extension is available without requesting permissions\n   */ static async isAvailable() {\n        if (false) {}\n        return (0,_lib_polkadot__WEBPACK_IMPORTED_MODULE_1__.isExtensionAvailable)();\n    }\n    /**\n   * Enable wallet extension\n   */ static async enableWallet() {\n        let appName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _config__WEBPACK_IMPORTED_MODULE_0__.config.app.name;\n        if (false) {}\n        try {\n            const extensions = await (0,_lib_polkadot__WEBPACK_IMPORTED_MODULE_1__.web3Enable)(appName);\n            this.initialized = extensions.length > 0;\n            if (this.initialized) {\n                // Start monitoring accounts after successful initialization\n                this.startAccountsMonitoring();\n            }\n            return this.initialized;\n        } catch (error) {\n            console.error(\"Failed to enable wallet:\", error);\n            return false;\n        }\n    }\n    /**\n   * Get accounts from wallet\n   * If the wallet isn't enabled yet, this will enable it first\n   */ static async getAccounts() {\n        if (false) {}\n        try {\n            // Ensure wallet is enabled\n            if (!this.initialized) {\n                const enabled = await this.enableWallet();\n                if (!enabled) return [];\n            }\n            // Use proper empty options object\n            const accounts = await (0,_lib_polkadot__WEBPACK_IMPORTED_MODULE_1__.web3Accounts)({});\n            this.lastKnownAccounts = accounts;\n            return accounts;\n        } catch (error) {\n            console.error(\"Failed to get accounts:\", error);\n            return [];\n        }\n    }\n    /**\n   * Sign a message with wallet\n   * Ensures proper message formatting for consistent signing\n   */ static async signMessage(address, message) {\n        if ( false || !_lib_polkadot__WEBPACK_IMPORTED_MODULE_1__.web3SignMessage) return null;\n        try {\n            // Ensure wallet is enabled\n            if (!this.initialized) {\n                const enabled = await this.enableWallet();\n                if (!enabled) return null;\n            }\n            // Prepare message for consistent signing format\n            const formattedMessage = (0,_lib_polkadot__WEBPACK_IMPORTED_MODULE_1__.prepareMessage)(message);\n            // Use proper parameters for web3SignMessage\n            return await (0,_lib_polkadot__WEBPACK_IMPORTED_MODULE_1__.web3SignMessage)({\n                address,\n                message: formattedMessage,\n                // Add an empty callback function to satisfy the interface\n                callbackFn: ()=>{}\n            });\n        } catch (error) {\n            // Track whether this was a user rejection\n            const isRejection = error instanceof Error && (error.message.includes(\"Rejected by user\") || error.message.toLowerCase().includes(\"cancel\") || error.message.toLowerCase().includes(\"reject\"));\n            // Rethrow with rejection info\n            if (isRejection) {\n                throw new Error(\"WALLET_REJECTION: \".concat(error.message));\n            }\n            throw error;\n        }\n    }\n    /**\n   * Start monitoring wallet accounts\n   * This keeps lastKnownAccounts up to date and can notify listeners of changes\n   */ static startAccountsMonitoring() {\n        if (false) {}\n        // Clear any existing subscription\n        if (this.accountsSubscription) {\n            this.accountsSubscription();\n            this.accountsSubscription = null;\n        }\n        // Start a new subscription\n        (0,_lib_polkadot__WEBPACK_IMPORTED_MODULE_1__.web3AccountsSubscribe)((accounts)=>{\n            this.lastKnownAccounts = accounts;\n            this.notifyAccountsChanged(accounts);\n        }).then((unsubscribe)=>{\n            this.accountsSubscription = unsubscribe;\n        }).catch((error)=>{\n            console.error(\"Failed to subscribe to accounts:\", error);\n        });\n    }\n    /**\n   * Stop monitoring wallet accounts\n   */ static stopAccountsMonitoring() {\n        if (this.accountsSubscription) {\n            this.accountsSubscription();\n            this.accountsSubscription = null;\n        }\n    }\n    /**\n   * Get the last known accounts without making a new request\n   */ static getCachedAccounts() {\n        return this.lastKnownAccounts;\n    }\n    /**\n   * Subscribe to account changes\n   * Returns a function to unsubscribe\n   */ static subscribeToAccountChanges(callback) {\n        this.accountListeners.add(callback);\n        // If we already have accounts, notify immediately\n        if (this.lastKnownAccounts.length > 0) {\n            setTimeout(()=>callback(this.lastKnownAccounts), 0);\n        }\n        return ()=>{\n            this.accountListeners.delete(callback);\n        };\n    }\n    /**\n   * Notify all listeners about account changes\n   */ static notifyAccountsChanged(accounts) {\n        this.accountListeners.forEach((listener)=>{\n            try {\n                listener(accounts);\n            } catch (error) {\n                console.error(\"Error in account change listener:\", error);\n            }\n        });\n    }\n}\n// Track initialization state\nWalletService.initialized = false;\nWalletService.accountsSubscription = null;\nWalletService.lastKnownAccounts = [];\n// Account change listeners\nWalletService.accountListeners = new Set();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9hdXRoL1dhbGxldFNlcnZpY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ2tDO0FBUVY7QUFFakIsTUFBTU87SUFNWDs7R0FFQyxHQUNELGFBQWFDLGNBQWdDO1FBQzNDLElBQUksS0FBa0IsRUFBYSxFQUFhO1FBQ2hELE9BQU9ILG1FQUFvQkE7SUFDN0I7SUFFQTs7R0FFQyxHQUNELGFBQWFJLGVBQWtFO1lBQXJEQyxVQUFBQSxpRUFBa0JWLDJDQUFNQSxDQUFDVyxHQUFHLENBQUNDLElBQUk7UUFDekQsSUFBSSxLQUFrQixFQUFhLEVBQWE7UUFFaEQsSUFBSTtZQUNGLE1BQU1DLGFBQWEsTUFBTVoseURBQVVBLENBQUNTO1lBQ3BDLElBQUksQ0FBQ0ksV0FBVyxHQUFHRCxXQUFXRSxNQUFNLEdBQUc7WUFFdkMsSUFBSSxJQUFJLENBQUNELFdBQVcsRUFBRTtnQkFDcEIsNERBQTREO2dCQUM1RCxJQUFJLENBQUNFLHVCQUF1QjtZQUM5QjtZQUVBLE9BQU8sSUFBSSxDQUFDRixXQUFXO1FBQ3pCLEVBQUUsT0FBT0csT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsNEJBQTRCQTtZQUMxQyxPQUFPO1FBQ1Q7SUFDRjtJQUVBOzs7R0FHQyxHQUNELGFBQWFFLGNBQWtEO1FBQzdELElBQUksS0FBa0IsRUFBYSxFQUFVO1FBRTdDLElBQUk7WUFDRiwyQkFBMkI7WUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQ0wsV0FBVyxFQUFFO2dCQUNyQixNQUFNTSxVQUFVLE1BQU0sSUFBSSxDQUFDWCxZQUFZO2dCQUN2QyxJQUFJLENBQUNXLFNBQVMsT0FBTyxFQUFFO1lBQ3pCO1lBRUEsa0NBQWtDO1lBQ2xDLE1BQU1DLFdBQVcsTUFBTWpCLDJEQUFZQSxDQUFDLENBQUM7WUFDckMsSUFBSSxDQUFDa0IsaUJBQWlCLEdBQUdEO1lBQ3pCLE9BQU9BO1FBQ1QsRUFBRSxPQUFPSixPQUFPO1lBQ2RDLFFBQVFELEtBQUss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QTRDO0FBSGhEekIsY0FJSWUsb0JBQStDLEVBQUU7QUF5SWhFLDJCQUEyQjtBQTdJaEJmLGNBOElJa0MsbUJBQXVFLElBQUlNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0cy9hdXRoL1dhbGxldFNlcnZpY2UudHM/N2E0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RlZEFjY291bnRXaXRoTWV0YSB9IGZyb20gJ0Bwb2xrYWRvdC9leHRlbnNpb24taW5qZWN0L3R5cGVzJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJ0AvY29uZmlnJztcbmltcG9ydCB7XG4gIHdlYjNFbmFibGUsXG4gIHdlYjNBY2NvdW50c1N1YnNjcmliZSxcbiAgd2ViM1NpZ25NZXNzYWdlLFxuICB3ZWIzQWNjb3VudHMsXG4gIGlzRXh0ZW5zaW9uQXZhaWxhYmxlLFxuICBwcmVwYXJlTWVzc2FnZVxufSBmcm9tICdAL2xpYi9wb2xrYWRvdCc7XG5cbmV4cG9ydCBjbGFzcyBXYWxsZXRTZXJ2aWNlIHtcbiAgLy8gVHJhY2sgaW5pdGlhbGl6YXRpb24gc3RhdGVcbiAgcHJpdmF0ZSBzdGF0aWMgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBzdGF0aWMgYWNjb3VudHNTdWJzY3JpcHRpb246ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHN0YXRpYyBsYXN0S25vd25BY2NvdW50czogSW5qZWN0ZWRBY2NvdW50V2l0aE1ldGFbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB3YWxsZXQgZXh0ZW5zaW9uIGlzIGF2YWlsYWJsZSB3aXRob3V0IHJlcXVlc3RpbmcgcGVybWlzc2lvbnNcbiAgICovXG4gIHN0YXRpYyBhc3luYyBpc0F2YWlsYWJsZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaXNFeHRlbnNpb25BdmFpbGFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgd2FsbGV0IGV4dGVuc2lvblxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGVuYWJsZVdhbGxldChhcHBOYW1lOiBzdHJpbmcgPSBjb25maWcuYXBwLm5hbWUpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBleHRlbnNpb25zID0gYXdhaXQgd2ViM0VuYWJsZShhcHBOYW1lKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBleHRlbnNpb25zLmxlbmd0aCA+IDA7XG5cbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIC8vIFN0YXJ0IG1vbml0b3JpbmcgYWNjb3VudHMgYWZ0ZXIgc3VjY2Vzc2Z1bCBpbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLnN0YXJ0QWNjb3VudHNNb25pdG9yaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZW5hYmxlIHdhbGxldDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhY2NvdW50cyBmcm9tIHdhbGxldFxuICAgKiBJZiB0aGUgd2FsbGV0IGlzbid0IGVuYWJsZWQgeWV0LCB0aGlzIHdpbGwgZW5hYmxlIGl0IGZpcnN0XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0QWNjb3VudHMoKTogUHJvbWlzZTxJbmplY3RlZEFjY291bnRXaXRoTWV0YVtdPiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gW107XG5cbiAgICB0cnkge1xuICAgICAgLy8gRW5zdXJlIHdhbGxldCBpcyBlbmFibGVkXG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgZW5hYmxlZCA9IGF3YWl0IHRoaXMuZW5hYmxlV2FsbGV0KCk7XG4gICAgICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgcHJvcGVyIGVtcHR5IG9wdGlvbnMgb2JqZWN0XG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHdlYjNBY2NvdW50cyh7fSk7XG4gICAgICB0aGlzLmxhc3RLbm93bkFjY291bnRzID0gYWNjb3VudHM7XG4gICAgICByZXR1cm4gYWNjb3VudHM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgYWNjb3VudHM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIGEgbWVzc2FnZSB3aXRoIHdhbGxldFxuICAgKiBFbnN1cmVzIHByb3BlciBtZXNzYWdlIGZvcm1hdHRpbmcgZm9yIGNvbnNpc3RlbnQgc2lnbmluZ1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIHNpZ25NZXNzYWdlKGFkZHJlc3M6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3ZWIzU2lnbk1lc3NhZ2UpIHJldHVybiBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEVuc3VyZSB3YWxsZXQgaXMgZW5hYmxlZFxuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIGNvbnN0IGVuYWJsZWQgPSBhd2FpdCB0aGlzLmVuYWJsZVdhbGxldCgpO1xuICAgICAgICBpZiAoIWVuYWJsZWQpIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIG1lc3NhZ2UgZm9yIGNvbnNpc3RlbnQgc2lnbmluZyBmb3JtYXRcbiAgICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2UgPSBwcmVwYXJlTWVzc2FnZShtZXNzYWdlKTtcblxuICAgICAgLy8gVXNlIHByb3BlciBwYXJhbWV0ZXJzIGZvciB3ZWIzU2lnbk1lc3NhZ2VcbiAgICAgIHJldHVybiBhd2FpdCB3ZWIzU2lnbk1lc3NhZ2Uoe1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBtZXNzYWdlOiBmb3JtYXR0ZWRNZXNzYWdlLFxuICAgICAgICAvLyBBZGQgYW4gZW1wdHkgY2FsbGJhY2sgZnVuY3Rpb24gdG8gc2F0aXNmeSB0aGUgaW50ZXJmYWNlXG4gICAgICAgIGNhbGxiYWNrRm46ICgpID0+IHt9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVHJhY2sgd2hldGhlciB0aGlzIHdhcyBhIHVzZXIgcmVqZWN0aW9uXG4gICAgICBjb25zdCBpc1JlamVjdGlvbiA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1JlamVjdGVkIGJ5IHVzZXInKSB8fFxuICAgICAgICAgZXJyb3IubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdjYW5jZWwnKSB8fFxuICAgICAgICAgZXJyb3IubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdyZWplY3QnKSk7XG5cbiAgICAgIC8vIFJldGhyb3cgd2l0aCByZWplY3Rpb24gaW5mb1xuICAgICAgaWYgKGlzUmVqZWN0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV0FMTEVUX1JFSkVDVElPTjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgbW9uaXRvcmluZyB3YWxsZXQgYWNjb3VudHNcbiAgICogVGhpcyBrZWVwcyBsYXN0S25vd25BY2NvdW50cyB1cCB0byBkYXRlIGFuZCBjYW4gbm90aWZ5IGxpc3RlbmVycyBvZiBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBzdGFydEFjY291bnRzTW9uaXRvcmluZygpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBzdWJzY3JpcHRpb25cbiAgICBpZiAodGhpcy5hY2NvdW50c1N1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5hY2NvdW50c1N1YnNjcmlwdGlvbigpO1xuICAgICAgdGhpcy5hY2NvdW50c1N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgYSBuZXcgc3Vic2NyaXB0aW9uXG4gICAgd2ViM0FjY291bnRzU3Vic2NyaWJlKChhY2NvdW50cykgPT4ge1xuICAgICAgdGhpcy5sYXN0S25vd25BY2NvdW50cyA9IGFjY291bnRzO1xuICAgICAgdGhpcy5ub3RpZnlBY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpO1xuICAgIH0pLnRoZW4odW5zdWJzY3JpYmUgPT4ge1xuICAgICAgdGhpcy5hY2NvdW50c1N1YnNjcmlwdGlvbiA9IHVuc3Vic2NyaWJlO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzdWJzY3JpYmUgdG8gYWNjb3VudHM6JywgZXJyb3IpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgbW9uaXRvcmluZyB3YWxsZXQgYWNjb3VudHNcbiAgICovXG4gIHN0YXRpYyBzdG9wQWNjb3VudHNNb25pdG9yaW5nKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmFjY291bnRzU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmFjY291bnRzU3Vic2NyaXB0aW9uKCk7XG4gICAgICB0aGlzLmFjY291bnRzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXN0IGtub3duIGFjY291bnRzIHdpdGhvdXQgbWFraW5nIGEgbmV3IHJlcXVlc3RcbiAgICovXG4gIHN0YXRpYyBnZXRDYWNoZWRBY2NvdW50cygpOiBJbmplY3RlZEFjY291bnRXaXRoTWV0YVtdIHtcbiAgICByZXR1cm4gdGhpcy5sYXN0S25vd25BY2NvdW50cztcbiAgfVxuXG4gIC8vIEFjY291bnQgY2hhbmdlIGxpc3RlbmVyc1xuICBwcml2YXRlIHN0YXRpYyBhY2NvdW50TGlzdGVuZXJzOiBTZXQ8KGFjY291bnRzOiBJbmplY3RlZEFjY291bnRXaXRoTWV0YVtdKSA9PiB2b2lkPiA9IG5ldyBTZXQoKTtcblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGFjY291bnQgY2hhbmdlc1xuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdW5zdWJzY3JpYmVcbiAgICovXG4gIHN0YXRpYyBzdWJzY3JpYmVUb0FjY291bnRDaGFuZ2VzKFxuICAgIGNhbGxiYWNrOiAoYWNjb3VudHM6IEluamVjdGVkQWNjb3VudFdpdGhNZXRhW10pID0+IHZvaWRcbiAgKTogKCkgPT4gdm9pZCB7XG4gICAgdGhpcy5hY2NvdW50TGlzdGVuZXJzLmFkZChjYWxsYmFjayk7XG5cbiAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYWNjb3VudHMsIG5vdGlmeSBpbW1lZGlhdGVseVxuICAgIGlmICh0aGlzLmxhc3RLbm93bkFjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2sodGhpcy5sYXN0S25vd25BY2NvdW50cyksIDApO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmFjY291bnRMaXN0ZW5lcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmeSBhbGwgbGlzdGVuZXJzIGFib3V0IGFjY291bnQgY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgbm90aWZ5QWNjb3VudHNDaGFuZ2VkKGFjY291bnRzOiBJbmplY3RlZEFjY291bnRXaXRoTWV0YVtdKTogdm9pZCB7XG4gICAgdGhpcy5hY2NvdW50TGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIoYWNjb3VudHMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gYWNjb3VudCBjaGFuZ2UgbGlzdGVuZXI6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOlsiY29uZmlnIiwid2ViM0VuYWJsZSIsIndlYjNBY2NvdW50c1N1YnNjcmliZSIsIndlYjNTaWduTWVzc2FnZSIsIndlYjNBY2NvdW50cyIsImlzRXh0ZW5zaW9uQXZhaWxhYmxlIiwicHJlcGFyZU1lc3NhZ2UiLCJXYWxsZXRTZXJ2aWNlIiwiaXNBdmFpbGFibGUiLCJlbmFibGVXYWxsZXQiLCJhcHBOYW1lIiwiYXBwIiwibmFtZSIsImV4dGVuc2lvbnMiLCJpbml0aWFsaXplZCIsImxlbmd0aCIsInN0YXJ0QWNjb3VudHNNb25pdG9yaW5nIiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0QWNjb3VudHMiLCJlbmFibGVkIiwiYWNjb3VudHMiLCJsYXN0S25vd25BY2NvdW50cyIsInNpZ25NZXNzYWdlIiwiYWRkcmVzcyIsIm1lc3NhZ2UiLCJmb3JtYXR0ZWRNZXNzYWdlIiwiY2FsbGJhY2tGbiIsImlzUmVqZWN0aW9uIiwiRXJyb3IiLCJpbmNsdWRlcyIsInRvTG93ZXJDYXNlIiwiYWNjb3VudHNTdWJzY3JpcHRpb24iLCJub3RpZnlBY2NvdW50c0NoYW5nZWQiLCJ0aGVuIiwidW5zdWJzY3JpYmUiLCJjYXRjaCIsInN0b3BBY2NvdW50c01vbml0b3JpbmciLCJnZXRDYWNoZWRBY2NvdW50cyIsInN1YnNjcmliZVRvQWNjb3VudENoYW5nZXMiLCJjYWxsYmFjayIsImFjY291bnRMaXN0ZW5lcnMiLCJhZGQiLCJzZXRUaW1lb3V0IiwiZGVsZXRlIiwiZm9yRWFjaCIsImxpc3RlbmVyIiwiU2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/auth/WalletService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/contexts/auth/index.ts":
/*!************************************!*\
  !*** ./src/contexts/auth/index.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAPI: function() { return /* reexport safe */ _AuthAPI__WEBPACK_IMPORTED_MODULE_3__.AuthAPI; },\n/* harmony export */   AuthContext: function() { return /* reexport safe */ _AuthContext__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; },\n/* harmony export */   AuthProvider: function() { return /* reexport safe */ _AuthProvider__WEBPACK_IMPORTED_MODULE_0__.AuthProvider; },\n/* harmony export */   WalletService: function() { return /* reexport safe */ _WalletService__WEBPACK_IMPORTED_MODULE_2__.WalletService; },\n/* harmony export */   useAuth: function() { return /* reexport safe */ _hooks_useAuth__WEBPACK_IMPORTED_MODULE_1__.useAuth; }\n/* harmony export */ });\n/* harmony import */ var _AuthProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AuthProvider */ \"(app-pages-browser)/./src/contexts/auth/AuthProvider.tsx\");\n/* harmony import */ var _hooks_useAuth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hooks/useAuth */ \"(app-pages-browser)/./src/contexts/auth/hooks/useAuth.ts\");\n/* harmony import */ var _WalletService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WalletService */ \"(app-pages-browser)/./src/contexts/auth/WalletService.ts\");\n/* harmony import */ var _AuthAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthAPI */ \"(app-pages-browser)/./src/contexts/auth/AuthAPI.ts\");\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AuthContext */ \"(app-pages-browser)/./src/contexts/auth/AuthContext.tsx\");\n\n\n\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9hdXRoL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDSjtBQUVNO0FBQ1o7QUFDbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHRzL2F1dGgvaW5kZXgudHM/MWNlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBBdXRoUHJvdmlkZXIgfSBmcm9tICcuL0F1dGhQcm92aWRlcic7XG5leHBvcnQgeyB1c2VBdXRoIH0gZnJvbSAnLi9ob29rcy91c2VBdXRoJztcbmV4cG9ydCB0eXBlIHsgQXV0aENvbnRleHRWYWx1ZSB9IGZyb20gJy4vQXV0aFR5cGVzJztcbmV4cG9ydCB7IFdhbGxldFNlcnZpY2UgfSBmcm9tICcuL1dhbGxldFNlcnZpY2UnO1xuZXhwb3J0IHsgQXV0aEFQSSB9IGZyb20gJy4vQXV0aEFQSSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEF1dGhDb250ZXh0IH0gZnJvbSAnLi9BdXRoQ29udGV4dCc7XG4iXSwibmFtZXMiOlsiQXV0aFByb3ZpZGVyIiwidXNlQXV0aCIsIldhbGxldFNlcnZpY2UiLCJBdXRoQVBJIiwiZGVmYXVsdCIsIkF1dGhDb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/auth/index.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/polkadot.ts":
/*!*****************************!*\
  !*** ./src/lib/polkadot.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensurePolkadotInitialized: function() { return /* binding */ ensurePolkadotInitialized; },\n/* harmony export */   hexToU8a: function() { return /* reexport safe */ _polkadot_util__WEBPACK_IMPORTED_MODULE_2__.hexToU8a; },\n/* harmony export */   isExtensionAvailable: function() { return /* binding */ isExtensionAvailable; },\n/* harmony export */   prepareMessage: function() { return /* binding */ prepareMessage; },\n/* harmony export */   signMessage: function() { return /* binding */ signMessage; },\n/* harmony export */   signatureVerify: function() { return /* binding */ signatureVerify; },\n/* harmony export */   stringToU8a: function() { return /* reexport safe */ _polkadot_util__WEBPACK_IMPORTED_MODULE_1__.stringToU8a; },\n/* harmony export */   u8aToHex: function() { return /* reexport safe */ _polkadot_util__WEBPACK_IMPORTED_MODULE_0__.u8aToHex; },\n/* harmony export */   web3Accounts: function() { return /* binding */ web3Accounts; },\n/* harmony export */   web3AccountsSubscribe: function() { return /* binding */ web3AccountsSubscribe; },\n/* harmony export */   web3Enable: function() { return /* binding */ web3Enable; },\n/* harmony export */   web3FromAddress: function() { return /* binding */ web3FromAddress; },\n/* harmony export */   web3SignMessage: function() { return /* binding */ web3SignMessage; }\n/* harmony export */ });\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polkadot/util */ \"(app-pages-browser)/./node_modules/@polkadot/util/u8a/toHex.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polkadot/util */ \"(app-pages-browser)/./node_modules/@polkadot/util/string/toU8a.js\");\n/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polkadot/util */ \"(app-pages-browser)/./node_modules/@polkadot/util/hex/toU8a.js\");\n/* __next_internal_client_entry_do_not_use__ ensurePolkadotInitialized,isExtensionAvailable,web3Enable,web3Accounts,web3AccountsSubscribe,web3FromAddress,prepareMessage,signMessage,web3SignMessage,signatureVerify,u8aToHex,stringToU8a,hexToU8a auto */ \n// Safe browser check\nconst isBrowser = \"object\" !== \"undefined\";\n// No-op function for empty callbacks\nconst noop = ()=>{};\n// Track initialization state\nlet isInitialized = false;\nlet isInitializing = false;\nconst initCallbacks = [];\nlet initRetries = 0;\nconst MAX_RETRIES = 3;\n// Extension detection status\nlet hasDetectedExtension = null;\n// Store for Polkadot extension API functions\nconst extensionApis = {\n    web3Enable: null,\n    web3AccountsSubscribe: null,\n    web3FromAddress: null,\n    web3Accounts: null,\n    signatureVerify: null\n};\n/**\n * Initialize Polkadot libraries asynchronously\n * Returns a promise that resolves when libraries are initialized\n */ const ensurePolkadotInitialized = async function() {\n    let forceRetry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    // Return immediately if already initialized or not in browser\n    if (isInitialized && !forceRetry) return true;\n    if (!isBrowser) return false;\n    // If initialization is in progress, wait for it to complete\n    if (isInitializing) {\n        return new Promise((resolve)=>{\n            initCallbacks.push(()=>resolve(isInitialized));\n        });\n    }\n    try {\n        isInitializing = true;\n        // Load APIs asynchronously\n        const [extDapp, utilCrypto] = await Promise.all([\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_polkadot_extension-dapp_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! @polkadot/extension-dapp */ \"(app-pages-browser)/./node_modules/@polkadot/extension-dapp/index.js\")),\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_polkadot_util-crypto_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! @polkadot/util-crypto */ \"(app-pages-browser)/./node_modules/@polkadot/util-crypto/index.js\"))\n        ]);\n        // Set the API functions\n        extensionApis.web3Enable = extDapp.web3Enable;\n        extensionApis.web3AccountsSubscribe = extDapp.web3AccountsSubscribe;\n        extensionApis.web3FromAddress = extDapp.web3FromAddress;\n        extensionApis.web3Accounts = extDapp.web3Accounts;\n        extensionApis.signatureVerify = utilCrypto.signatureVerify;\n        // Mark as initialized\n        isInitialized = true;\n        initRetries = 0;\n        console.log(\"Polkadot libraries initialized successfully\");\n        // Notify any waiting callbacks\n        initCallbacks.forEach((callback)=>callback());\n        initCallbacks.length = 0;\n        return true;\n    } catch (err) {\n        console.error(\"Failed to load Polkadot libraries:\", err);\n        initRetries++;\n        // If we haven't exceeded retry limit, try again\n        if (initRetries < MAX_RETRIES) {\n            console.log(\"Retrying initialization (attempt \".concat(initRetries + 1, \"/\").concat(MAX_RETRIES, \")...\"));\n            isInitializing = false;\n            return ensurePolkadotInitialized(true);\n        }\n        return false;\n    } finally{\n        isInitializing = false;\n    }\n};\n/**\n * Check if Polkadot extension is available in the browser\n * This is a lightweight check that doesn't trigger permission prompts\n */ const isExtensionAvailable = async ()=>{\n    if (!isBrowser) return false;\n    // Use cached result if available\n    if (hasDetectedExtension !== null) return hasDetectedExtension;\n    try {\n        // Check for injectedWeb3 without triggering permission prompts\n        const injectedWeb3 = window.injectedWeb3;\n        // Check if 'polkadot-js' or other Substrate wallets are present\n        hasDetectedExtension = !!injectedWeb3 && (!!injectedWeb3[\"polkadot-js\"] || !!injectedWeb3[\"subwallet-js\"] || !!injectedWeb3[\"talisman\"] || Object.keys(injectedWeb3).length > 0);\n        return hasDetectedExtension;\n    } catch (error) {\n        console.error(\"Error checking extension availability:\", error);\n        return false;\n    }\n};\n// Initialize on client only\nif (isBrowser) {\n    // Start initialization immediately, but don't wait for it\n    ensurePolkadotInitialized().catch(console.error);\n}\n// Safe wrapper functions with proper types\nconst web3Enable = async (appName)=>{\n    // Ensure libraries are initialized first\n    await ensurePolkadotInitialized();\n    if (!extensionApis.web3Enable) {\n        console.warn(\"web3Enable not available\");\n        return [];\n    }\n    try {\n        return await extensionApis.web3Enable(appName);\n    } catch (error) {\n        console.error(\"Error in web3Enable:\", error);\n        return [];\n    }\n};\n// Updated with imported type\nconst web3Accounts = async (options)=>{\n    // Ensure libraries are initialized first\n    await ensurePolkadotInitialized();\n    if (!extensionApis.web3Accounts) {\n        console.warn(\"web3Accounts not available\");\n        return [];\n    }\n    try {\n        return await extensionApis.web3Accounts(options);\n    } catch (error) {\n        console.error(\"Error in web3Accounts:\", error);\n        return [];\n    }\n};\nconst web3AccountsSubscribe = async (callback)=>{\n    // Ensure libraries are initialized first\n    await ensurePolkadotInitialized();\n    if (!extensionApis.web3AccountsSubscribe) {\n        console.warn(\"web3AccountsSubscribe not available\");\n        return noop; // Using noop instead of empty arrow function\n    }\n    try {\n        const unsubscribe = await extensionApis.web3AccountsSubscribe(callback);\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"Error in web3AccountsSubscribe:\", error);\n        return noop; // Using noop instead of empty arrow function\n    }\n};\nconst web3FromAddress = async (address)=>{\n    // Ensure libraries are initialized first\n    await ensurePolkadotInitialized();\n    if (!extensionApis.web3FromAddress) {\n        console.warn(\"web3FromAddress not available\");\n        return {\n            signer: null\n        };\n    }\n    try {\n        return await extensionApis.web3FromAddress(address);\n    } catch (error) {\n        console.error(\"Error in web3FromAddress:\", error);\n        return {\n            signer: null\n        };\n    }\n};\n/**\n * Prepare message for consistent signing and verification\n * This ensures messages are formatted the same way for signing and verification\n */ const prepareMessage = (message)=>{\n    // Check if the message is already in <Bytes>...</Bytes> format\n    if (message.startsWith(\"<Bytes>\") && message.endsWith(\"</Bytes>\")) {\n        return message;\n    }\n    // Convert to explicit hex format for consistent handling\n    return (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_0__.u8aToHex)((0,_polkadot_util__WEBPACK_IMPORTED_MODULE_1__.stringToU8a)(message));\n};\nconst signMessage = async (param)=>{\n    let { address, message, callbackFn } = param;\n    // Ensure libraries are initialized first\n    await ensurePolkadotInitialized();\n    if (!extensionApis.web3FromAddress) {\n        console.warn(\"Signing not available\");\n        return null;\n    }\n    try {\n        var _injector_signer;\n        const injector = await web3FromAddress(address);\n        const signRaw = injector === null || injector === void 0 ? void 0 : (_injector_signer = injector.signer) === null || _injector_signer === void 0 ? void 0 : _injector_signer.signRaw;\n        if (!signRaw) {\n            throw new Error(\"Signing not supported by this extension\");\n        }\n        const result = await signRaw({\n            address,\n            data: message,\n            type: \"bytes\"\n        });\n        // Call the callback only if provided\n        if (callbackFn) {\n            callbackFn(result);\n        }\n        return result.signature;\n    } catch (error) {\n        // Format error message to help identify rejection\n        if (error instanceof Error) {\n            const errorMsg = error.message.toLowerCase();\n            if (errorMsg.includes(\"reject\") || errorMsg.includes(\"cancel\") || errorMsg.includes(\"denied\") || errorMsg.includes(\"user declined\")) {\n                error.message = \"Rejected by user: \".concat(error.message);\n            }\n        }\n        throw error; // Let the caller handle the error\n    }\n};\n// Export for compatibility with existing code\nconst web3SignMessage = signMessage;\nconst signatureVerify = async (message, signature, address, crypto)=>{\n    // Ensure libraries are initialized first\n    await ensurePolkadotInitialized();\n    if (!extensionApis.signatureVerify) {\n        console.warn(\"signatureVerify not available\");\n        return {\n            isValid: false,\n            crypto: \"none\",\n            isWrapped: false,\n            publicKey: new Uint8Array()\n        };\n    }\n    try {\n        // Use the crypto parameter if provided\n        if (crypto) {\n            return extensionApis.signatureVerify(message, signature, address, crypto);\n        }\n        return extensionApis.signatureVerify(message, signature, address);\n    } catch (error) {\n        console.error(\"Error in signatureVerify:\", error);\n        return {\n            isValid: false,\n            crypto: \"none\",\n            isWrapped: false,\n            publicKey: new Uint8Array()\n        };\n    }\n};\n// Export util functions for verification\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcG9sa2Fkb3QudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyUEFzQmlFO0FBRWpFLHFCQUFxQjtBQUNyQixNQUFNRyxZQUFZLGFBQWtCO0FBRXBDLHFDQUFxQztBQUNyQyxNQUFNQyxPQUFPLEtBQWtDO0FBdUIvQyw2QkFBNkI7QUFDN0IsSUFBSUMsZ0JBQWdCO0FBQ3BCLElBQUlDLGlCQUFpQjtBQUNyQixNQUFNQyxnQkFBbUMsRUFBRTtBQUMzQyxJQUFJQyxjQUFjO0FBQ2xCLE1BQU1DLGNBQWM7QUFFcEIsNkJBQTZCO0FBQzdCLElBQUlDLHVCQUF1QztBQUUzQyw2Q0FBNkM7QUFDN0MsTUFBTUMsZ0JBQStCO0lBQ25DQyxZQUFZO0lBQ1pDLHVCQUF1QjtJQUN2QkMsaUJBQWlCO0lBQ2pCQyxjQUFjO0lBQ2RDLGlCQUFpQjtBQUNuQjtBQUVBOzs7Q0FHQyxHQUNNLE1BQU1DLDRCQUE0QjtRQUFPQyw4RUFBYTtJQUMzRCw4REFBOEQ7SUFDOUQsSUFBSWIsaUJBQWlCLENBQUNhLFlBQVksT0FBTztJQUN6QyxJQUFJLENBQUNmLFdBQVcsT0FBTztJQUV2Qiw0REFBNEQ7SUFDNUQsSUFBSUcsZ0JBQWdCO1FBQ2xCLE9BQU8sSUFBSWEsUUFBaUIsQ0FBQ0M7WUFDM0JiLGNBQWNjLElBQUksQ0FBQyxJQUFNRCxRQUFRZjtRQUNuQztJQUNGO0lBRUEsSUFBSTtRQUNGQyxpQkFBaUI7UUFFakIsMkJBQTJCO1FBQzNCLE1BQU0sQ0FBQ2dCLFNBQVNDLFdBQVcsR0FBRyxNQUFNSixRQUFRSyxHQUFHLENBQUM7WUFDOUMscVFBQU87WUFDUCw0UEFBTztTQUNSO1FBRUQsd0JBQXdCO1FBQ3hCYixjQUFjQyxVQUFVLEdBQUdVLFFBQVFWLFVBQVU7UUFDN0NELGNBQWNFLHFCQUFxQixHQUFHUyxRQUFRVCxxQkFBcUI7UUFDbkVGLGNBQWNHLGVBQWUsR0FBR1EsUUFBUVIsZUFBZTtRQUN2REgsY0FBY0ksWUFB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c0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG4vLyBJbXBvcnQgdGhlIGV4YWN0IHR5cGVzIGZyb20gUG9sa2Fkb3RcbmltcG9ydCB0eXBlIHsgSW5qZWN0ZWRBY2NvdW50V2l0aE1ldGEsIEluamVjdGVkRXh0ZW5zaW9uIH0gZnJvbSAnQHBvbGthZG90L2V4dGVuc2lvbi1pbmplY3QvdHlwZXMnO1xuLy8gRGVmaW5lIFdlYjNBY2NvdW50c09wdGlvbnMgaW5saW5lIGluc3RlYWQgb2YgaW1wb3J0aW5nXG5pbnRlcmZhY2UgV2ViM0FjY291bnRzT3B0aW9ucyB7XG4gIGNyZWF0ZWQ/OiBEYXRlO1xuICBnZW5lc2lzSGFzaD86IHN0cmluZztcbiAgc3M1OEZvcm1hdD86IG51bWJlcjtcbiAgdHlwZT86ICdzcjI1NTE5JyB8ICdlZDI1NTE5JyB8ICdlY2RzYSc7XG4gIHdpdGhBbnk/OiBib29sZWFuO1xuICB3aXRoSGFyZHdhcmU/OiBib29sZWFuO1xufVxuXG4vLyBEZWZpbmUgVmVyaWZ5UmVzdWx0IGlubGluZSBpbnN0ZWFkIG9mIGltcG9ydGluZ1xuaW50ZXJmYWNlIFZlcmlmeVJlc3VsdCB7XG4gIGNyeXB0bzogJ25vbmUnIHwgJ2VkMjU1MTknIHwgJ3NyMjU1MTknIHwgJ2VjZHNhJyB8ICdldGhlcmV1bScgfCBzdHJpbmc7XG4gIGlzVmFsaWQ6IGJvb2xlYW47XG4gIGlzV3JhcHBlZDogYm9vbGVhbjtcbiAgcHVibGljS2V5OiBVaW50OEFycmF5O1xufVxuXG5pbXBvcnQgeyB1OGFUb0hleCwgc3RyaW5nVG9VOGEsIGhleFRvVThhIH0gZnJvbSAnQHBvbGthZG90L3V0aWwnO1xuXG4vLyBTYWZlIGJyb3dzZXIgY2hlY2tcbmNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBOby1vcCBmdW5jdGlvbiBmb3IgZW1wdHkgY2FsbGJhY2tzXG5jb25zdCBub29wID0gKCkgPT4geyAvKiBpbnRlbnRpb25hbGx5IGVtcHR5ICovIH07XG5cbi8vIFN0b3JlIGZvciBQb2xrYWRvdCBleHRlbnNpb24gQVBJIGZ1bmN0aW9ucyAtIHByb3Blcmx5IHR5cGVkXG5pbnRlcmZhY2UgRXh0ZW5zaW9uQXBpcyB7XG4gIHdlYjNFbmFibGU6ICgoYXBwTmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPEluamVjdGVkRXh0ZW5zaW9uW10+KSB8IG51bGw7XG4gIHdlYjNBY2NvdW50c1N1YnNjcmliZTogKChjYWxsYmFjazogKGFjY291bnRzOiBJbmplY3RlZEFjY291bnRXaXRoTWV0YVtdKSA9PiB2b2lkKSA9PiBQcm9taXNlPCgpID0+IHZvaWQ+KSB8IG51bGw7XG4gIHdlYjNGcm9tQWRkcmVzczogKChhZGRyZXNzOiBzdHJpbmcpID0+IFByb21pc2U8SW5qZWN0b3JXaXRoU2lnbmVyPikgfCBudWxsO1xuICB3ZWIzQWNjb3VudHM6ICgob3B0aW9ucz86IFdlYjNBY2NvdW50c09wdGlvbnMpID0+IFByb21pc2U8SW5qZWN0ZWRBY2NvdW50V2l0aE1ldGFbXT4pIHwgbnVsbDtcbiAgc2lnbmF0dXJlVmVyaWZ5OiAoKG1lc3NhZ2U6IHN0cmluZyB8IFVpbnQ4QXJyYXksIHNpZ25hdHVyZTogc3RyaW5nIHwgVWludDhBcnJheSwgYWRkcmVzczogc3RyaW5nIHwgVWludDhBcnJheSwgY3J5cHRvPzogJ2VkMjU1MTknIHwgJ3NyMjU1MTknIHwgJ2VjZHNhJykgPT4gVmVyaWZ5UmVzdWx0KSB8IG51bGw7XG59XG5cbi8vIEJldHRlciB0eXBlIGZvciBpbmplY3RvciByZXR1cm5cbmludGVyZmFjZSBJbmplY3RvcldpdGhTaWduZXIge1xuICBzaWduZXI/OiB7XG4gICAgc2lnblJhdz86IChwYXJhbXM6IHtcbiAgICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICAgIGRhdGE6IHN0cmluZztcbiAgICAgIHR5cGU6ICdieXRlcycgfCAncGF5bG9hZCc7XG4gICAgfSkgPT4gUHJvbWlzZTx7IHNpZ25hdHVyZTogc3RyaW5nIH0+O1xuICB9IHwgbnVsbDtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG4vLyBUcmFjayBpbml0aWFsaXphdGlvbiBzdGF0ZVxubGV0IGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBpc0luaXRpYWxpemluZyA9IGZhbHNlO1xuY29uc3QgaW5pdENhbGxiYWNrczogQXJyYXk8KCkgPT4gdm9pZD4gPSBbXTtcbmxldCBpbml0UmV0cmllcyA9IDA7XG5jb25zdCBNQVhfUkVUUklFUyA9IDM7XG5cbi8vIEV4dGVuc2lvbiBkZXRlY3Rpb24gc3RhdHVzXG5sZXQgaGFzRGV0ZWN0ZWRFeHRlbnNpb246IGJvb2xlYW4gfCBudWxsID0gbnVsbDtcblxuLy8gU3RvcmUgZm9yIFBvbGthZG90IGV4dGVuc2lvbiBBUEkgZnVuY3Rpb25zXG5jb25zdCBleHRlbnNpb25BcGlzOiBFeHRlbnNpb25BcGlzID0ge1xuICB3ZWIzRW5hYmxlOiBudWxsLFxuICB3ZWIzQWNjb3VudHNTdWJzY3JpYmU6IG51bGwsXG4gIHdlYjNGcm9tQWRkcmVzczogbnVsbCxcbiAgd2ViM0FjY291bnRzOiBudWxsLFxuICBzaWduYXR1cmVWZXJpZnk6IG51bGxcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBQb2xrYWRvdCBsaWJyYXJpZXMgYXN5bmNocm9ub3VzbHlcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBsaWJyYXJpZXMgYXJlIGluaXRpYWxpemVkXG4gKi9cbmV4cG9ydCBjb25zdCBlbnN1cmVQb2xrYWRvdEluaXRpYWxpemVkID0gYXN5bmMgKGZvcmNlUmV0cnkgPSBmYWxzZSk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgaWYgYWxyZWFkeSBpbml0aWFsaXplZCBvciBub3QgaW4gYnJvd3NlclxuICBpZiAoaXNJbml0aWFsaXplZCAmJiAhZm9yY2VSZXRyeSkgcmV0dXJuIHRydWU7XG4gIGlmICghaXNCcm93c2VyKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgaW5pdGlhbGl6YXRpb24gaXMgaW4gcHJvZ3Jlc3MsIHdhaXQgZm9yIGl0IHRvIGNvbXBsZXRlXG4gIGlmIChpc0luaXRpYWxpemluZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxib29sZWFuPigocmVzb2x2ZSkgPT4ge1xuICAgICAgaW5pdENhbGxiYWNrcy5wdXNoKCgpID0+IHJlc29sdmUoaXNJbml0aWFsaXplZCkpO1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpc0luaXRpYWxpemluZyA9IHRydWU7XG5cbiAgICAvLyBMb2FkIEFQSXMgYXN5bmNocm9ub3VzbHlcbiAgICBjb25zdCBbZXh0RGFwcCwgdXRpbENyeXB0b10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBpbXBvcnQoJ0Bwb2xrYWRvdC9leHRlbnNpb24tZGFwcCcpLFxuICAgICAgaW1wb3J0KCdAcG9sa2Fkb3QvdXRpbC1jcnlwdG8nKVxuICAgIF0pO1xuXG4gICAgLy8gU2V0IHRoZSBBUEkgZnVuY3Rpb25zXG4gICAgZXh0ZW5zaW9uQXBpcy53ZWIzRW5hYmxlID0gZXh0RGFwcC53ZWIzRW5hYmxlO1xuICAgIGV4dGVuc2lvbkFwaXMud2ViM0FjY291bnRzU3Vic2NyaWJlID0gZXh0RGFwcC53ZWIzQWNjb3VudHNTdWJzY3JpYmU7XG4gICAgZXh0ZW5zaW9uQXBpcy53ZWIzRnJvbUFkZHJlc3MgPSBleHREYXBwLndlYjNGcm9tQWRkcmVzcztcbiAgICBleHRlbnNpb25BcGlzLndlYjNBY2NvdW50cyA9IGV4dERhcHAud2ViM0FjY291bnRzO1xuICAgIGV4dGVuc2lvbkFwaXMuc2lnbmF0dXJlVmVyaWZ5ID0gdXRpbENyeXB0by5zaWduYXR1cmVWZXJpZnk7XG5cbiAgICAvLyBNYXJrIGFzIGluaXRpYWxpemVkXG4gICAgaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgaW5pdFJldHJpZXMgPSAwO1xuICAgIGNvbnNvbGUubG9nKCdQb2xrYWRvdCBsaWJyYXJpZXMgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cbiAgICAvLyBOb3RpZnkgYW55IHdhaXRpbmcgY2FsbGJhY2tzXG4gICAgaW5pdENhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpO1xuICAgIGluaXRDYWxsYmFja3MubGVuZ3RoID0gMDtcblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgUG9sa2Fkb3QgbGlicmFyaWVzOlwiLCBlcnIpO1xuICAgIGluaXRSZXRyaWVzKys7XG5cbiAgICAvLyBJZiB3ZSBoYXZlbid0IGV4Y2VlZGVkIHJldHJ5IGxpbWl0LCB0cnkgYWdhaW5cbiAgICBpZiAoaW5pdFJldHJpZXMgPCBNQVhfUkVUUklFUykge1xuICAgICAgY29uc29sZS5sb2coYFJldHJ5aW5nIGluaXRpYWxpemF0aW9uIChhdHRlbXB0ICR7aW5pdFJldHJpZXMgKyAxfS8ke01BWF9SRVRSSUVTfSkuLi5gKTtcbiAgICAgIGlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gZW5zdXJlUG9sa2Fkb3RJbml0aWFsaXplZCh0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZmluYWxseSB7XG4gICAgaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBQb2xrYWRvdCBleHRlbnNpb24gaXMgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyXG4gKiBUaGlzIGlzIGEgbGlnaHR3ZWlnaHQgY2hlY2sgdGhhdCBkb2Vzbid0IHRyaWdnZXIgcGVybWlzc2lvbiBwcm9tcHRzXG4gKi9cbmV4cG9ydCBjb25zdCBpc0V4dGVuc2lvbkF2YWlsYWJsZSA9IGFzeW5jICgpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgaWYgKCFpc0Jyb3dzZXIpIHJldHVybiBmYWxzZTtcblxuICAvLyBVc2UgY2FjaGVkIHJlc3VsdCBpZiBhdmFpbGFibGVcbiAgaWYgKGhhc0RldGVjdGVkRXh0ZW5zaW9uICE9PSBudWxsKSByZXR1cm4gaGFzRGV0ZWN0ZWRFeHRlbnNpb247XG5cbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBmb3IgaW5qZWN0ZWRXZWIzIHdpdGhvdXQgdHJpZ2dlcmluZyBwZXJtaXNzaW9uIHByb21wdHNcbiAgICBjb25zdCBpbmplY3RlZFdlYjMgPSAod2luZG93IGFzIGFueSkuaW5qZWN0ZWRXZWIzO1xuXG4gICAgLy8gQ2hlY2sgaWYgJ3BvbGthZG90LWpzJyBvciBvdGhlciBTdWJzdHJhdGUgd2FsbGV0cyBhcmUgcHJlc2VudFxuICAgIGhhc0RldGVjdGVkRXh0ZW5zaW9uID0gISFpbmplY3RlZFdlYjMgJiYgKFxuICAgICAgISFpbmplY3RlZFdlYjNbJ3BvbGthZG90LWpzJ10gfHxcbiAgICAgICEhaW5qZWN0ZWRXZWIzWydzdWJ3YWxsZXQtanMnXSB8fFxuICAgICAgISFpbmplY3RlZFdlYjNbJ3RhbGlzbWFuJ10gfHxcbiAgICAgIE9iamVjdC5rZXlzKGluamVjdGVkV2ViMykubGVuZ3RoID4gMFxuICAgICk7XG5cbiAgICByZXR1cm4gaGFzRGV0ZWN0ZWRFeHRlbnNpb247XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgZXh0ZW5zaW9uIGF2YWlsYWJpbGl0eTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBJbml0aWFsaXplIG9uIGNsaWVudCBvbmx5XG5pZiAoaXNCcm93c2VyKSB7XG4gIC8vIFN0YXJ0IGluaXRpYWxpemF0aW9uIGltbWVkaWF0ZWx5LCBidXQgZG9uJ3Qgd2FpdCBmb3IgaXRcbiAgZW5zdXJlUG9sa2Fkb3RJbml0aWFsaXplZCgpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xufVxuXG4vLyBTYWZlIHdyYXBwZXIgZnVuY3Rpb25zIHdpdGggcHJvcGVyIHR5cGVzXG5leHBvcnQgY29uc3Qgd2ViM0VuYWJsZSA9IGFzeW5jIChhcHBOYW1lOiBzdHJpbmcpOiBQcm9taXNlPEluamVjdGVkRXh0ZW5zaW9uW10+ID0+IHtcbiAgLy8gRW5zdXJlIGxpYnJhcmllcyBhcmUgaW5pdGlhbGl6ZWQgZmlyc3RcbiAgYXdhaXQgZW5zdXJlUG9sa2Fkb3RJbml0aWFsaXplZCgpO1xuXG4gIGlmICghZXh0ZW5zaW9uQXBpcy53ZWIzRW5hYmxlKSB7XG4gICAgY29uc29sZS53YXJuKCd3ZWIzRW5hYmxlIG5vdCBhdmFpbGFibGUnKTtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBleHRlbnNpb25BcGlzLndlYjNFbmFibGUoYXBwTmFtZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gd2ViM0VuYWJsZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG4vLyBVcGRhdGVkIHdpdGggaW1wb3J0ZWQgdHlwZVxuZXhwb3J0IGNvbnN0IHdlYjNBY2NvdW50cyA9IGFzeW5jIChvcHRpb25zPzogV2ViM0FjY291bnRzT3B0aW9ucyk6IFByb21pc2U8SW5qZWN0ZWRBY2NvdW50V2l0aE1ldGFbXT4gPT4ge1xuICAvLyBFbnN1cmUgbGlicmFyaWVzIGFyZSBpbml0aWFsaXplZCBmaXJzdFxuICBhd2FpdCBlbnN1cmVQb2xrYWRvdEluaXRpYWxpemVkKCk7XG5cbiAgaWYgKCFleHRlbnNpb25BcGlzLndlYjNBY2NvdW50cykge1xuICAgIGNvbnNvbGUud2Fybignd2ViM0FjY291bnRzIG5vdCBhdmFpbGFibGUnKTtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBleHRlbnNpb25BcGlzLndlYjNBY2NvdW50cyhvcHRpb25zKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB3ZWIzQWNjb3VudHM6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHdlYjNBY2NvdW50c1N1YnNjcmliZSA9IGFzeW5jIChcbiAgY2FsbGJhY2s6IChhY2NvdW50czogSW5qZWN0ZWRBY2NvdW50V2l0aE1ldGFbXSkgPT4gdm9pZFxuKTogUHJvbWlzZTwoKSA9PiB2b2lkPiA9PiB7XG4gIC8vIEVuc3VyZSBsaWJyYXJpZXMgYXJlIGluaXRpYWxpemVkIGZpcnN0XG4gIGF3YWl0IGVuc3VyZVBvbGthZG90SW5pdGlhbGl6ZWQoKTtcblxuICBpZiAoIWV4dGVuc2lvbkFwaXMud2ViM0FjY291bnRzU3Vic2NyaWJlKSB7XG4gICAgY29uc29sZS53YXJuKCd3ZWIzQWNjb3VudHNTdWJzY3JpYmUgbm90IGF2YWlsYWJsZScpO1xuICAgIHJldHVybiBub29wOyAvLyBVc2luZyBub29wIGluc3RlYWQgb2YgZW1wdHkgYXJyb3cgZnVuY3Rpb25cbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBhd2FpdCBleHRlbnNpb25BcGlzLndlYjNBY2NvdW50c1N1YnNjcmliZShjYWxsYmFjayk7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHdlYjNBY2NvdW50c1N1YnNjcmliZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIG5vb3A7IC8vIFVzaW5nIG5vb3AgaW5zdGVhZCBvZiBlbXB0eSBhcnJvdyBmdW5jdGlvblxuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgd2ViM0Zyb21BZGRyZXNzID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8SW5qZWN0b3JXaXRoU2lnbmVyPiA9PiB7XG4gIC8vIEVuc3VyZSBsaWJyYXJpZXMgYXJlIGluaXRpYWxpemVkIGZpcnN0XG4gIGF3YWl0IGVuc3VyZVBvbGthZG90SW5pdGlhbGl6ZWQoKTtcblxuICBpZiAoIWV4dGVuc2lvbkFwaXMud2ViM0Zyb21BZGRyZXNzKSB7XG4gICAgY29uc29sZS53YXJuKCd3ZWIzRnJvbUFkZHJlc3Mgbm90IGF2YWlsYWJsZScpO1xuICAgIHJldHVybiB7IHNpZ25lcjogbnVsbCB9O1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZXh0ZW5zaW9uQXBpcy53ZWIzRnJvbUFkZHJlc3MoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gd2ViM0Zyb21BZGRyZXNzOicsIGVycm9yKTtcbiAgICByZXR1cm4geyBzaWduZXI6IG51bGwgfTtcbiAgfVxufTtcblxuaW50ZXJmYWNlIFNpZ25NZXNzYWdlUGFyYW1zIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIGNhbGxiYWNrRm4/OiAoX3Jlc3VsdDogYW55KSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFByZXBhcmUgbWVzc2FnZSBmb3IgY29uc2lzdGVudCBzaWduaW5nIGFuZCB2ZXJpZmljYXRpb25cbiAqIFRoaXMgZW5zdXJlcyBtZXNzYWdlcyBhcmUgZm9ybWF0dGVkIHRoZSBzYW1lIHdheSBmb3Igc2lnbmluZyBhbmQgdmVyaWZpY2F0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBwcmVwYXJlTWVzc2FnZSA9IChtZXNzYWdlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAvLyBDaGVjayBpZiB0aGUgbWVzc2FnZSBpcyBhbHJlYWR5IGluIDxCeXRlcz4uLi48L0J5dGVzPiBmb3JtYXRcbiAgaWYgKG1lc3NhZ2Uuc3RhcnRzV2l0aCgnPEJ5dGVzPicpICYmIG1lc3NhZ2UuZW5kc1dpdGgoJzwvQnl0ZXM+JykpIHtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICAvLyBDb252ZXJ0IHRvIGV4cGxpY2l0IGhleCBmb3JtYXQgZm9yIGNvbnNpc3RlbnQgaGFuZGxpbmdcbiAgcmV0dXJuIHU4YVRvSGV4KHN0cmluZ1RvVThhKG1lc3NhZ2UpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzaWduTWVzc2FnZSA9IGFzeW5jICh7IGFkZHJlc3MsIG1lc3NhZ2UsIGNhbGxiYWNrRm4gfTogU2lnbk1lc3NhZ2VQYXJhbXMpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+ID0+IHtcbiAgLy8gRW5zdXJlIGxpYnJhcmllcyBhcmUgaW5pdGlhbGl6ZWQgZmlyc3RcbiAgYXdhaXQgZW5zdXJlUG9sa2Fkb3RJbml0aWFsaXplZCgpO1xuXG4gIGlmICghZXh0ZW5zaW9uQXBpcy53ZWIzRnJvbUFkZHJlc3MpIHtcbiAgICBjb25zb2xlLndhcm4oJ1NpZ25pbmcgbm90IGF2YWlsYWJsZScpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBpbmplY3RvciA9IGF3YWl0IHdlYjNGcm9tQWRkcmVzcyhhZGRyZXNzKTtcbiAgICBjb25zdCBzaWduUmF3ID0gaW5qZWN0b3I/LnNpZ25lcj8uc2lnblJhdztcblxuICAgIGlmICghc2lnblJhdykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWduaW5nIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBleHRlbnNpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduUmF3KHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgdHlwZTogJ2J5dGVzJ1xuICAgIH0pO1xuXG4gICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgb25seSBpZiBwcm92aWRlZFxuICAgIGlmIChjYWxsYmFja0ZuKSB7XG4gICAgICBjYWxsYmFja0ZuKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5zaWduYXR1cmU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gRm9ybWF0IGVycm9yIG1lc3NhZ2UgdG8gaGVscCBpZGVudGlmeSByZWplY3Rpb25cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNc2cgPSBlcnJvci5tZXNzYWdlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoXG4gICAgICAgIGVycm9yTXNnLmluY2x1ZGVzKCdyZWplY3QnKSB8fFxuICAgICAgICBlcnJvck1zZy5pbmNsdWRlcygnY2FuY2VsJykgfHxcbiAgICAgICAgZXJyb3JNc2cuaW5jbHVkZXMoJ2RlbmllZCcpIHx8XG4gICAgICAgIGVycm9yTXNnLmluY2x1ZGVzKCd1c2VyIGRlY2xpbmVkJylcbiAgICAgICkge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gYFJlamVjdGVkIGJ5IHVzZXI6ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlcnJvcjsgLy8gTGV0IHRoZSBjYWxsZXIgaGFuZGxlIHRoZSBlcnJvclxuICB9XG59O1xuXG4vLyBFeHBvcnQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBjb2RlXG5leHBvcnQgY29uc3Qgd2ViM1NpZ25NZXNzYWdlID0gc2lnbk1lc3NhZ2U7XG5cbmV4cG9ydCBjb25zdCBzaWduYXR1cmVWZXJpZnkgPSBhc3luYyAoXG4gIG1lc3NhZ2U6IHN0cmluZyB8IFVpbnQ4QXJyYXksXG4gIHNpZ25hdHVyZTogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgYWRkcmVzczogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgY3J5cHRvPzogJ2VkMjU1MTknIHwgJ3NyMjU1MTknIHwgJ2VjZHNhJ1xuKTogUHJvbWlzZTxWZXJpZnlSZXN1bHQ+ID0+IHtcbiAgLy8gRW5zdXJlIGxpYnJhcmllcyBhcmUgaW5pdGlhbGl6ZWQgZmlyc3RcbiAgYXdhaXQgZW5zdXJlUG9sa2Fkb3RJbml0aWFsaXplZCgpO1xuXG4gIGlmICghZXh0ZW5zaW9uQXBpcy5zaWduYXR1cmVWZXJpZnkpIHtcbiAgICBjb25zb2xlLndhcm4oJ3NpZ25hdHVyZVZlcmlmeSBub3QgYXZhaWxhYmxlJyk7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIGNyeXB0bzogJ25vbmUnLCBpc1dyYXBwZWQ6IGZhbHNlLCBwdWJsaWNLZXk6IG5ldyBVaW50OEFycmF5KCkgfTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVXNlIHRoZSBjcnlwdG8gcGFyYW1ldGVyIGlmIHByb3ZpZGVkXG4gICAgaWYgKGNyeXB0bykge1xuICAgICAgcmV0dXJuIChleHRlbnNpb25BcGlzLnNpZ25hdHVyZVZlcmlmeSBhcyBhbnkpKG1lc3NhZ2UsIHNpZ25hdHVyZSwgYWRkcmVzcywgY3J5cHRvKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbkFwaXMuc2lnbmF0dXJlVmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSwgYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gc2lnbmF0dXJlVmVyaWZ5OicsIGVycm9yKTtcbiAgICByZXR1cm4geyBpc1ZhbGlkOiBmYWxzZSwgY3J5cHRvOiAnbm9uZScsIGlzV3JhcHBlZDogZmFsc2UsIHB1YmxpY0tleTogbmV3IFVpbnQ4QXJyYXkoKSB9O1xuICB9XG59O1xuXG4vLyBFeHBvcnQgdXRpbCBmdW5jdGlvbnMgZm9yIHZlcmlmaWNhdGlvblxuZXhwb3J0IHsgdThhVG9IZXgsIHN0cmluZ1RvVThhLCBoZXhUb1U4YSB9O1xuIl0sIm5hbWVzIjpbInU4YVRvSGV4Iiwic3RyaW5nVG9VOGEiLCJoZXhUb1U4YSIsImlzQnJvd3NlciIsIm5vb3AiLCJpc0luaXRpYWxpemVkIiwiaXNJbml0aWFsaXppbmciLCJpbml0Q2FsbGJhY2tzIiwiaW5pdFJldHJpZXMiLCJNQVhfUkVUUklFUyIsImhhc0RldGVjdGVkRXh0ZW5zaW9uIiwiZXh0ZW5zaW9uQXBpcyIsIndlYjNFbmFibGUiLCJ3ZWIzQWNjb3VudHNTdWJzY3JpYmUiLCJ3ZWIzRnJvbUFkZHJlc3MiLCJ3ZWIzQWNjb3VudHMiLCJzaWduYXR1cmVWZXJpZnkiLCJlbnN1cmVQb2xrYWRvdEluaXRpYWxpemVkIiwiZm9yY2VSZXRyeSIsIlByb21pc2UiLCJyZXNvbHZlIiwicHVzaCIsImV4dERhcHAiLCJ1dGlsQ3J5cHRvIiwiYWxsIiwiY29uc29sZSIsImxvZyIsImZvckVhY2giLCJjYWxsYmFjayIsImxlbmd0aCIsImVyciIsImVycm9yIiwiaXNFeHRlbnNpb25BdmFpbGFibGUiLCJpbmplY3RlZFdlYjMiLCJ3aW5kb3ciLCJPYmplY3QiLCJrZXlzIiwiY2F0Y2giLCJhcHBOYW1lIiwid2FybiIsIm9wdGlvbnMiLCJ1bnN1YnNjcmliZSIsImFkZHJlc3MiLCJzaWduZXIiLCJwcmVwYXJlTWVzc2FnZSIsIm1lc3NhZ2UiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzaWduTWVzc2FnZSIsImNhbGxiYWNrRm4iLCJpbmplY3RvciIsInNpZ25SYXciLCJFcnJvciIsInJlc3VsdCIsImRhdGEiLCJ0eXBlIiwic2lnbmF0dXJlIiwiZXJyb3JNc2ciLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwid2ViM1NpZ25NZXNzYWdlIiwiY3J5cHRvIiwiaXNWYWxpZCIsImlzV3JhcHBlZCIsInB1YmxpY0tleSIsIlVpbnQ4QXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/polkadot.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/env.ts":
/*!**************************!*\
  !*** ./src/utils/env.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnvVariable: function() { return /* binding */ getEnvVariable; },\n/* harmony export */   getEnvironmentConfig: function() { return /* binding */ getEnvironmentConfig; },\n/* harmony export */   getPublicEnv: function() { return /* binding */ getPublicEnv; },\n/* harmony export */   isDev: function() { return /* binding */ isDev; },\n/* harmony export */   isProd: function() { return /* binding */ isProd; },\n/* harmony export */   isTest: function() { return /* binding */ isTest; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Get an environment variable with type safety\n * @param key - The name of the environment variable\n * @param defaultValue - Optional default value if the environment variable is not set\n * @returns The value of the environment variable or the default value\n * @throws Error if no value is found and no default is provided\n */ function getEnvVariable(key, defaultValue) {\n    const value = process.env[key] || defaultValue;\n    if (value === undefined) {\n        throw new Error(\"Environment variable \".concat(key, \" is not defined\"));\n    }\n    return value;\n}\n/**\n * Check if we're in production environment\n */ const isProd = \"development\" === \"production\";\n/**\n * Check if we're in development environment\n */ const isDev = \"development\" === \"development\";\n/**\n * Check if we're in test environment\n */ const isTest = \"development\" === \"test\";\n/**\n * Get environment-specific configuration\n * @returns Configuration object based on current environment\n */ function getEnvironmentConfig() {\n    return {\n        polkadotApiUrl: getEnvVariable(\"POLKADOT_API_URL\", \"https://rpc.polkadot.io\"),\n        isDebugEnabled: !isProd,\n        appVersion: \"1.0.0\" || 0\n    };\n}\n/**\n * Safely access a public environment variable (NEXT_PUBLIC_*)\n * These are safe to expose to the browser\n * @param key - The name of the environment variable (without NEXT_PUBLIC_ prefix)\n * @param defaultValue - Optional default value\n */ function getPublicEnv(key, defaultValue) {\n    const fullKey = \"NEXT_PUBLIC_\".concat(key);\n    return getEnvVariable(fullKey, defaultValue);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9lbnYudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNBLGVBQWVDLEdBQVcsRUFBRUMsWUFBcUI7SUFDL0QsTUFBTUMsUUFBUUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDSixJQUFJLElBQUlDO0lBQ2xDLElBQUlDLFVBQVVHLFdBQVc7UUFDdkIsTUFBTSxJQUFJQyxNQUFNLHdCQUE0QixPQUFKTixLQUFJO0lBQzlDO0lBQ0EsT0FBT0U7QUFDVDtBQUVBOztDQUVDLEdBQ00sTUFBTUssU0FBU0osa0JBQXlCLGFBQWE7QUFFNUQ7O0NBRUMsR0FDTSxNQUFNSyxRQUFRTCxrQkFBeUIsY0FBYztBQUU1RDs7Q0FFQyxHQUNNLE1BQU1NLFNBQVNOLGtCQUF5QixPQUFPO0FBRXREOzs7Q0FHQyxHQUNNLFNBQVNPO0lBQ2QsT0FBTztRQUNMQyxnQkFBZ0JaLGVBQWUsb0JBQW9CO1FBQ25EYSxnQkFBZ0IsQ0FBQ0w7UUFDakJNLFlBQVlWLE9BQW1DLElBQUk7SUFDckQ7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU1ksYUFBYWYsR0FBVyxFQUFFQyxZQUFxQjtJQUM3RCxNQUFNZSxVQUFVLGVBQW1CLE9BQUpoQjtJQUMvQixPQUFPRCxlQUFlaUIsU0FBU2Y7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2Vudi50cz9jYmU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2V0IGFuIGVudmlyb25tZW50IHZhcmlhYmxlIHdpdGggdHlwZSBzYWZldHlcbiAqIEBwYXJhbSBrZXkgLSBUaGUgbmFtZSBvZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBPcHRpb25hbCBkZWZhdWx0IHZhbHVlIGlmIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0XG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIHRoZSBkZWZhdWx0IHZhbHVlXG4gKiBAdGhyb3dzIEVycm9yIGlmIG5vIHZhbHVlIGlzIGZvdW5kIGFuZCBubyBkZWZhdWx0IGlzIHByb3ZpZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnZWYXJpYWJsZShrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgdmFsdWUgPSBwcm9jZXNzLmVudltrZXldIHx8IGRlZmF1bHRWYWx1ZTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVudmlyb25tZW50IHZhcmlhYmxlICR7a2V5fSBpcyBub3QgZGVmaW5lZGApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBpc1Byb2QgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBjb25zdCBpc0RldiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIGluIHRlc3QgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGlzVGVzdCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCc7XG5cbi8qKlxuICogR2V0IGVudmlyb25tZW50LXNwZWNpZmljIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIENvbmZpZ3VyYXRpb24gb2JqZWN0IGJhc2VkIG9uIGN1cnJlbnQgZW52aXJvbm1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVudmlyb25tZW50Q29uZmlnKCkge1xuICByZXR1cm4ge1xuICAgIHBvbGthZG90QXBpVXJsOiBnZXRFbnZWYXJpYWJsZSgnUE9MS0FET1RfQVBJX1VSTCcsICdodHRwczovL3JwYy5wb2xrYWRvdC5pbycpLFxuICAgIGlzRGVidWdFbmFibGVkOiAhaXNQcm9kLFxuICAgIGFwcFZlcnNpb246IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQUF9WRVJTSU9OIHx8ICcxLjAuMCcsXG4gIH07XG59XG5cbi8qKlxuICogU2FmZWx5IGFjY2VzcyBhIHB1YmxpYyBlbnZpcm9ubWVudCB2YXJpYWJsZSAoTkVYVF9QVUJMSUNfKilcbiAqIFRoZXNlIGFyZSBzYWZlIHRvIGV4cG9zZSB0byB0aGUgYnJvd3NlclxuICogQHBhcmFtIGtleSAtIFRoZSBuYW1lIG9mIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSAod2l0aG91dCBORVhUX1BVQkxJQ18gcHJlZml4KVxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIE9wdGlvbmFsIGRlZmF1bHQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YmxpY0VudihrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZnVsbEtleSA9IGBORVhUX1BVQkxJQ18ke2tleX1gO1xuICByZXR1cm4gZ2V0RW52VmFyaWFibGUoZnVsbEtleSwgZGVmYXVsdFZhbHVlKTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRFbnZWYXJpYWJsZSIsImtleSIsImRlZmF1bHRWYWx1ZSIsInZhbHVlIiwicHJvY2VzcyIsImVudiIsInVuZGVmaW5lZCIsIkVycm9yIiwiaXNQcm9kIiwiaXNEZXYiLCJpc1Rlc3QiLCJnZXRFbnZpcm9ubWVudENvbmZpZyIsInBvbGthZG90QXBpVXJsIiwiaXNEZWJ1Z0VuYWJsZWQiLCJhcHBWZXJzaW9uIiwiTkVYVF9QVUJMSUNfQVBQX1ZFUlNJT04iLCJnZXRQdWJsaWNFbnYiLCJmdWxsS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/env.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@polkadot/util/hex/toU8a.js":
/*!**************************************************!*\
  !*** ./node_modules/@polkadot/util/hex/toU8a.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hexToU8a: function() { return /* binding */ hexToU8a; }\n/* harmony export */ });\nconst CHR = \"0123456789abcdef\";\nconst U8 = new Uint8Array(256);\nconst U16 = new Uint8Array(256 * 256);\nfor(let i = 0, count = CHR.length; i < count; i++){\n    U8[CHR[i].charCodeAt(0) | 0] = i | 0;\n    if (i > 9) {\n        U8[CHR[i].toUpperCase().charCodeAt(0) | 0] = i | 0;\n    }\n}\nfor(let i = 0; i < 256; i++){\n    const s = i << 8;\n    for(let j = 0; j < 256; j++){\n        U16[s | j] = U8[i] << 4 | U8[j];\n    }\n}\n/**\n * @name hexToU8a\n * @summary Creates a Uint8Array object from a hex string.\n * @description\n * `null` inputs returns an empty `Uint8Array` result. Hex input values return the actual bytes value converted to a Uint8Array. Anything that is not a hex string (including the `0x` prefix) throws an error.\n * @example\n * <BR>\n *\n * ```javascript\n * import { hexToU8a } from '@polkadot/util';\n *\n * hexToU8a('0x80001f'); // Uint8Array([0x80, 0x00, 0x1f])\n * hexToU8a('0x80001f', 32); // Uint8Array([0x00, 0x80, 0x00, 0x1f])\n * ```\n */ function hexToU8a(value) {\n    let bitLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;\n    if (!value) {\n        return new Uint8Array();\n    }\n    let s = value.startsWith(\"0x\") ? 2 : 0;\n    const decLength = Math.ceil((value.length - s) / 2);\n    const endLength = Math.ceil(bitLength === -1 ? decLength : bitLength / 8);\n    const result = new Uint8Array(endLength);\n    const offset = endLength > decLength ? endLength - decLength : 0;\n    for(let i = offset; i < endLength; i++, s += 2){\n        // The big factor here is actually the string lookups. If we do\n        // HEX_TO_U16[value.substring()] we get an 10x slowdown. In the\n        // same vein using charCodeAt (as opposed to value[s] or value.charAt(s)) is\n        // also the faster operation by at least 2x with the character map above\n        result[i] = U16[value.charCodeAt(s) << 8 | value.charCodeAt(s + 1)];\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QvdXRpbC9oZXgvdG9VOGEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLE1BQU07QUFDWixNQUFNQyxLQUFLLElBQUlDLFdBQVc7QUFDMUIsTUFBTUMsTUFBTSxJQUFJRCxXQUFXLE1BQU07QUFDakMsSUFBSyxJQUFJRSxJQUFJLEdBQUdDLFFBQVFMLElBQUlNLE1BQU0sRUFBRUYsSUFBSUMsT0FBT0QsSUFBSztJQUNoREgsRUFBRSxDQUFDRCxHQUFHLENBQUNJLEVBQUUsQ0FBQ0csVUFBVSxDQUFDLEtBQUssRUFBRSxHQUFHSCxJQUFJO0lBQ25DLElBQUlBLElBQUksR0FBRztRQUNQSCxFQUFFLENBQUNELEdBQUcsQ0FBQ0ksRUFBRSxDQUFDSSxXQUFXLEdBQUdELFVBQVUsQ0FBQyxLQUFLLEVBQUUsR0FBR0gsSUFBSTtJQUNyRDtBQUNKO0FBQ0EsSUFBSyxJQUFJQSxJQUFJLEdBQUdBLElBQUksS0FBS0EsSUFBSztJQUMxQixNQUFNSyxJQUFJTCxLQUFLO0lBQ2YsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUksS0FBS0EsSUFBSztRQUMxQlAsR0FBRyxDQUFDTSxJQUFJQyxFQUFFLEdBQUcsRUFBRyxDQUFDTixFQUFFLElBQUksSUFBS0gsRUFBRSxDQUFDUyxFQUFFO0lBQ3JDO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNNLFNBQVNDLFNBQVNDLEtBQUs7UUFBRUMsWUFBQUEsaUVBQVksQ0FBQztJQUN6QyxJQUFJLENBQUNELE9BQU87UUFDUixPQUFPLElBQUlWO0lBQ2Y7SUFDQSxJQUFJTyxJQUFJRyxNQUFNRSxVQUFVLENBQUMsUUFDbkIsSUFDQTtJQUNOLE1BQU1DLFlBQVlDLEtBQUtDLElBQUksQ0FBQyxDQUFDTCxNQUFNTixNQUFNLEdBQUdHLENBQUFBLElBQUs7SUFDakQsTUFBTVMsWUFBWUYsS0FBS0MsSUFBSSxDQUFDSixjQUFjLENBQUMsSUFDckNFLFlBQ0FGLFlBQVk7SUFDbEIsTUFBTU0sU0FBUyxJQUFJakIsV0FBV2dCO0lBQzlCLE1BQU1FLFNBQVNGLFlBQVlILFlBQ3JCRyxZQUFZSCxZQUNaO0lBQ04sSUFBSyxJQUFJWCxJQUFJZ0IsUUFBUWhCLElBQUljLFdBQVdkLEtBQUtLLEtBQUssRUFBRztRQUM3QywrREFBK0Q7UUFDL0QsK0RBQStEO1FBQy9ELDRFQUE0RTtRQUM1RSx3RUFBd0U7UUFDeEVVLE1BQU0sQ0FBQ2YsRUFBRSxHQUFHRCxHQUFHLENBQUMsTUFBT0ksVUFBVSxDQUFDRSxNQUFNLElBQUtHLE1BQU1MLFVBQVUsQ0FBQ0UsSUFBSSxHQUFHO0lBQ3pFO0lBQ0EsT0FBT1U7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvbGthZG90L3V0aWwvaGV4L3RvVThhLmpzP2Y3Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ0hSID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuY29uc3QgVTggPSBuZXcgVWludDhBcnJheSgyNTYpO1xuY29uc3QgVTE2ID0gbmV3IFVpbnQ4QXJyYXkoMjU2ICogMjU2KTtcbmZvciAobGV0IGkgPSAwLCBjb3VudCA9IENIUi5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgVThbQ0hSW2ldLmNoYXJDb2RlQXQoMCkgfCAwXSA9IGkgfCAwO1xuICAgIGlmIChpID4gOSkge1xuICAgICAgICBVOFtDSFJbaV0udG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApIHwgMF0gPSBpIHwgMDtcbiAgICB9XG59XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgY29uc3QgcyA9IGkgPDwgODtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI1NjsgaisrKSB7XG4gICAgICAgIFUxNltzIHwgal0gPSAoVThbaV0gPDwgNCkgfCBVOFtqXTtcbiAgICB9XG59XG4vKipcbiAqIEBuYW1lIGhleFRvVThhXG4gKiBAc3VtbWFyeSBDcmVhdGVzIGEgVWludDhBcnJheSBvYmplY3QgZnJvbSBhIGhleCBzdHJpbmcuXG4gKiBAZGVzY3JpcHRpb25cbiAqIGBudWxsYCBpbnB1dHMgcmV0dXJucyBhbiBlbXB0eSBgVWludDhBcnJheWAgcmVzdWx0LiBIZXggaW5wdXQgdmFsdWVzIHJldHVybiB0aGUgYWN0dWFsIGJ5dGVzIHZhbHVlIGNvbnZlcnRlZCB0byBhIFVpbnQ4QXJyYXkuIEFueXRoaW5nIHRoYXQgaXMgbm90IGEgaGV4IHN0cmluZyAoaW5jbHVkaW5nIHRoZSBgMHhgIHByZWZpeCkgdGhyb3dzIGFuIGVycm9yLlxuICogQGV4YW1wbGVcbiAqIDxCUj5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBoZXhUb1U4YSB9IGZyb20gJ0Bwb2xrYWRvdC91dGlsJztcbiAqXG4gKiBoZXhUb1U4YSgnMHg4MDAwMWYnKTsgLy8gVWludDhBcnJheShbMHg4MCwgMHgwMCwgMHgxZl0pXG4gKiBoZXhUb1U4YSgnMHg4MDAwMWYnLCAzMik7IC8vIFVpbnQ4QXJyYXkoWzB4MDAsIDB4ODAsIDB4MDAsIDB4MWZdKVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb1U4YSh2YWx1ZSwgYml0TGVuZ3RoID0gLTEpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbiAgICBsZXQgcyA9IHZhbHVlLnN0YXJ0c1dpdGgoJzB4JylcbiAgICAgICAgPyAyXG4gICAgICAgIDogMDtcbiAgICBjb25zdCBkZWNMZW5ndGggPSBNYXRoLmNlaWwoKHZhbHVlLmxlbmd0aCAtIHMpIC8gMik7XG4gICAgY29uc3QgZW5kTGVuZ3RoID0gTWF0aC5jZWlsKGJpdExlbmd0aCA9PT0gLTFcbiAgICAgICAgPyBkZWNMZW5ndGhcbiAgICAgICAgOiBiaXRMZW5ndGggLyA4KTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmRMZW5ndGgpO1xuICAgIGNvbnN0IG9mZnNldCA9IGVuZExlbmd0aCA+IGRlY0xlbmd0aFxuICAgICAgICA/IGVuZExlbmd0aCAtIGRlY0xlbmd0aFxuICAgICAgICA6IDA7XG4gICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGVuZExlbmd0aDsgaSsrLCBzICs9IDIpIHtcbiAgICAgICAgLy8gVGhlIGJpZyBmYWN0b3IgaGVyZSBpcyBhY3R1YWxseSB0aGUgc3RyaW5nIGxvb2t1cHMuIElmIHdlIGRvXG4gICAgICAgIC8vIEhFWF9UT19VMTZbdmFsdWUuc3Vic3RyaW5nKCldIHdlIGdldCBhbiAxMHggc2xvd2Rvd24uIEluIHRoZVxuICAgICAgICAvLyBzYW1lIHZlaW4gdXNpbmcgY2hhckNvZGVBdCAoYXMgb3Bwb3NlZCB0byB2YWx1ZVtzXSBvciB2YWx1ZS5jaGFyQXQocykpIGlzXG4gICAgICAgIC8vIGFsc28gdGhlIGZhc3RlciBvcGVyYXRpb24gYnkgYXQgbGVhc3QgMnggd2l0aCB0aGUgY2hhcmFjdGVyIG1hcCBhYm92ZVxuICAgICAgICByZXN1bHRbaV0gPSBVMTZbKHZhbHVlLmNoYXJDb2RlQXQocykgPDwgOCkgfCB2YWx1ZS5jaGFyQ29kZUF0KHMgKyAxKV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iXSwibmFtZXMiOlsiQ0hSIiwiVTgiLCJVaW50OEFycmF5IiwiVTE2IiwiaSIsImNvdW50IiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsInRvVXBwZXJDYXNlIiwicyIsImoiLCJoZXhUb1U4YSIsInZhbHVlIiwiYml0TGVuZ3RoIiwic3RhcnRzV2l0aCIsImRlY0xlbmd0aCIsIk1hdGgiLCJjZWlsIiwiZW5kTGVuZ3RoIiwicmVzdWx0Iiwib2Zmc2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@polkadot/util/hex/toU8a.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@polkadot/util/string/toU8a.js":
/*!*****************************************************!*\
  !*** ./node_modules/@polkadot/util/string/toU8a.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stringToU8a: function() { return /* binding */ stringToU8a; }\n/* harmony export */ });\n/* harmony import */ var _polkadot_x_textencoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polkadot/x-textencoder */ \"(app-pages-browser)/./node_modules/@polkadot/x-textencoder/browser.js\");\n\nconst encoder = new _polkadot_x_textencoder__WEBPACK_IMPORTED_MODULE_0__.TextEncoder();\n/**\n * @name stringToU8a\n * @summary Creates a Uint8Array object from a utf-8 string.\n * @description\n * String input values return the actual encoded `UInt8Array`. `null` or `undefined` values returns an empty encoded array.\n * @example\n * <BR>\n *\n * ```javascript\n * import { stringToU8a } from '@polkadot/util';\n *\n * stringToU8a('hello'); // [0x68, 0x65, 0x6c, 0x6c, 0x6f]\n * ```\n */ function stringToU8a(value) {\n    return value ? encoder.encode(value.toString()) : new Uint8Array();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QvdXRpbC9zdHJpbmcvdG9VOGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0Q7QUFDdEQsTUFBTUMsVUFBVSxJQUFJRCxnRUFBV0E7QUFDL0I7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLFNBQVNFLFlBQVlDLEtBQUs7SUFDN0IsT0FBT0EsUUFDREYsUUFBUUcsTUFBTSxDQUFDRCxNQUFNRSxRQUFRLE1BQzdCLElBQUlDO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC91dGlsL3N0cmluZy90b1U4YS5qcz83MzVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHRFbmNvZGVyIH0gZnJvbSAnQHBvbGthZG90L3gtdGV4dGVuY29kZXInO1xuY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuLyoqXG4gKiBAbmFtZSBzdHJpbmdUb1U4YVxuICogQHN1bW1hcnkgQ3JlYXRlcyBhIFVpbnQ4QXJyYXkgb2JqZWN0IGZyb20gYSB1dGYtOCBzdHJpbmcuXG4gKiBAZGVzY3JpcHRpb25cbiAqIFN0cmluZyBpbnB1dCB2YWx1ZXMgcmV0dXJuIHRoZSBhY3R1YWwgZW5jb2RlZCBgVUludDhBcnJheWAuIGBudWxsYCBvciBgdW5kZWZpbmVkYCB2YWx1ZXMgcmV0dXJucyBhbiBlbXB0eSBlbmNvZGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqIDxCUj5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBzdHJpbmdUb1U4YSB9IGZyb20gJ0Bwb2xrYWRvdC91dGlsJztcbiAqXG4gKiBzdHJpbmdUb1U4YSgnaGVsbG8nKTsgLy8gWzB4NjgsIDB4NjUsIDB4NmMsIDB4NmMsIDB4NmZdXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvVThhKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gZW5jb2Rlci5lbmNvZGUodmFsdWUudG9TdHJpbmcoKSlcbiAgICAgICAgOiBuZXcgVWludDhBcnJheSgpO1xufVxuIl0sIm5hbWVzIjpbIlRleHRFbmNvZGVyIiwiZW5jb2RlciIsInN0cmluZ1RvVThhIiwidmFsdWUiLCJlbmNvZGUiLCJ0b1N0cmluZyIsIlVpbnQ4QXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@polkadot/util/string/toU8a.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@polkadot/util/u8a/toHex.js":
/*!**************************************************!*\
  !*** ./node_modules/@polkadot/util/u8a/toHex.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   u8aToHex: function() { return /* binding */ u8aToHex; }\n/* harmony export */ });\nconst U8 = new Array(256);\nconst U16 = new Array(256 * 256);\nfor(let n = 0; n < 256; n++){\n    U8[n] = n.toString(16).padStart(2, \"0\");\n}\nfor(let i = 0; i < 256; i++){\n    const s = i << 8;\n    for(let j = 0; j < 256; j++){\n        U16[s | j] = U8[i] + U8[j];\n    }\n}\n/** @internal */ function hex(value, result) {\n    const mod = value.length % 2 | 0;\n    const length = value.length - mod | 0;\n    for(let i = 0; i < length; i += 2){\n        result += U16[value[i] << 8 | value[i + 1]];\n    }\n    if (mod) {\n        result += U8[value[length] | 0];\n    }\n    return result;\n}\n/**\n * @name u8aToHex\n * @summary Creates a hex string from a Uint8Array object.\n * @description\n * `UInt8Array` input values return the actual hex string. `null` or `undefined` values returns an `0x` string.\n * @example\n * <BR>\n *\n * ```javascript\n * import { u8aToHex } from '@polkadot/util';\n *\n * u8aToHex(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0xf])); // 0x68656c0f\n * ```\n */ function u8aToHex(value) {\n    let bitLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, isPrefixed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n    // this is not 100% correct sinmce we support isPrefixed = false....\n    const empty = isPrefixed ? \"0x\" : \"\";\n    if (!(value === null || value === void 0 ? void 0 : value.length)) {\n        return empty;\n    } else if (bitLength > 0) {\n        const length = Math.ceil(bitLength / 8);\n        if (value.length > length) {\n            return \"\".concat(hex(value.subarray(0, length / 2), empty), \"\").concat(hex(value.subarray(value.length - length / 2), \"\"));\n        }\n    }\n    return hex(value, empty);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QvdXRpbC91OGEvdG9IZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLEtBQUssSUFBSUMsTUFBTTtBQUNyQixNQUFNQyxNQUFNLElBQUlELE1BQU0sTUFBTTtBQUM1QixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSSxLQUFLQSxJQUFLO0lBQzFCSCxFQUFFLENBQUNHLEVBQUUsR0FBR0EsRUFBRUMsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHO0FBQ3ZDO0FBQ0EsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksS0FBS0EsSUFBSztJQUMxQixNQUFNQyxJQUFJRCxLQUFLO0lBQ2YsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUksS0FBS0EsSUFBSztRQUMxQk4sR0FBRyxDQUFDSyxJQUFJQyxFQUFFLEdBQUdSLEVBQUUsQ0FBQ00sRUFBRSxHQUFHTixFQUFFLENBQUNRLEVBQUU7SUFDOUI7QUFDSjtBQUNBLGNBQWMsR0FDZCxTQUFTQyxJQUFJQyxLQUFLLEVBQUVDLE1BQU07SUFDdEIsTUFBTUMsTUFBTSxNQUFPQyxNQUFNLEdBQUcsSUFBSztJQUNqQyxNQUFNQSxTQUFTLE1BQU9BLE1BQU0sR0FBR0QsTUFBTztJQUN0QyxJQUFLLElBQUlOLElBQUksR0FBR0EsSUFBSU8sUUFBUVAsS0FBSyxFQUFHO1FBQ2hDSyxVQUFVVCxHQUFHLENBQUMsS0FBTSxDQUFDSSxFQUFFLElBQUksSUFBS0ksS0FBSyxDQUFDSixJQUFJLEVBQUUsQ0FBQztJQUNqRDtJQUNBLElBQUlNLEtBQUs7UUFDTEQsVUFBVVgsRUFBRSxDQUFDVSxLQUFLLENBQUNHLE9BQU8sR0FBRyxFQUFFO0lBQ25DO0lBQ0EsT0FBT0Y7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDTSxTQUFTRyxTQUFTSixLQUFLO1FBQUVLLFlBQUFBLGlFQUFZLENBQUMsR0FBR0MsYUFBQUEsaUVBQWE7SUFDekQsb0VBQW9FO0lBQ3BFLE1BQU1DLFFBQVFELGFBQ1IsT0FDQTtJQUNOLElBQUksRUFBQ04sa0JBQUFBLDRCQUFBQSxNQUFPRyxNQUFNLEdBQUU7UUFDaEIsT0FBT0k7SUFDWCxPQUNLLElBQUlGLFlBQVksR0FBRztRQUNwQixNQUFNRixTQUFTSyxLQUFLQyxJQUFJLENBQUNKLFlBQVk7UUFDckMsSUFBSUwsTUFBTUcsTUFBTSxHQUFHQSxRQUFRO1lBQ3ZCLE9BQU8sR0FBZ0RKLE9BQTdDQSxJQUFJQyxNQUFNVSxRQUFRLENBQUMsR0FBR1AsU0FBUyxJQUFJSSxRQUFPLEtBQXNELE9BQW5EUixJQUFJQyxNQUFNVSxRQUFRLENBQUNWLE1BQU1HLE1BQU0sR0FBR0EsU0FBUyxJQUFJO1FBQzFHO0lBQ0o7SUFDQSxPQUFPSixJQUFJQyxPQUFPTztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvbGthZG90L3V0aWwvdThhL3RvSGV4LmpzPzYzN2IiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVTggPSBuZXcgQXJyYXkoMjU2KTtcbmNvbnN0IFUxNiA9IG5ldyBBcnJheSgyNTYgKiAyNTYpO1xuZm9yIChsZXQgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIFU4W25dID0gbi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKTtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBjb25zdCBzID0gaSA8PCA4O1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjU2OyBqKyspIHtcbiAgICAgICAgVTE2W3MgfCBqXSA9IFU4W2ldICsgVThbal07XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gaGV4KHZhbHVlLCByZXN1bHQpIHtcbiAgICBjb25zdCBtb2QgPSAodmFsdWUubGVuZ3RoICUgMikgfCAwO1xuICAgIGNvbnN0IGxlbmd0aCA9ICh2YWx1ZS5sZW5ndGggLSBtb2QpIHwgMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHJlc3VsdCArPSBVMTZbKHZhbHVlW2ldIDw8IDgpIHwgdmFsdWVbaSArIDFdXTtcbiAgICB9XG4gICAgaWYgKG1vZCkge1xuICAgICAgICByZXN1bHQgKz0gVThbdmFsdWVbbGVuZ3RoXSB8IDBdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAbmFtZSB1OGFUb0hleFxuICogQHN1bW1hcnkgQ3JlYXRlcyBhIGhleCBzdHJpbmcgZnJvbSBhIFVpbnQ4QXJyYXkgb2JqZWN0LlxuICogQGRlc2NyaXB0aW9uXG4gKiBgVUludDhBcnJheWAgaW5wdXQgdmFsdWVzIHJldHVybiB0aGUgYWN0dWFsIGhleCBzdHJpbmcuIGBudWxsYCBvciBgdW5kZWZpbmVkYCB2YWx1ZXMgcmV0dXJucyBhbiBgMHhgIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKiA8QlI+XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgdThhVG9IZXggfSBmcm9tICdAcG9sa2Fkb3QvdXRpbCc7XG4gKlxuICogdThhVG9IZXgobmV3IFVpbnQ4QXJyYXkoWzB4NjgsIDB4NjUsIDB4NmMsIDB4NmMsIDB4Zl0pKTsgLy8gMHg2ODY1NmMwZlxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OGFUb0hleCh2YWx1ZSwgYml0TGVuZ3RoID0gLTEsIGlzUHJlZml4ZWQgPSB0cnVlKSB7XG4gICAgLy8gdGhpcyBpcyBub3QgMTAwJSBjb3JyZWN0IHNpbm1jZSB3ZSBzdXBwb3J0IGlzUHJlZml4ZWQgPSBmYWxzZS4uLi5cbiAgICBjb25zdCBlbXB0eSA9IGlzUHJlZml4ZWRcbiAgICAgICAgPyAnMHgnXG4gICAgICAgIDogJyc7XG4gICAgaWYgKCF2YWx1ZT8ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYml0TGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtoZXgodmFsdWUuc3ViYXJyYXkoMCwgbGVuZ3RoIC8gMiksIGVtcHR5KX3igKYke2hleCh2YWx1ZS5zdWJhcnJheSh2YWx1ZS5sZW5ndGggLSBsZW5ndGggLyAyKSwgJycpfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhleCh2YWx1ZSwgZW1wdHkpO1xufVxuIl0sIm5hbWVzIjpbIlU4IiwiQXJyYXkiLCJVMTYiLCJuIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImkiLCJzIiwiaiIsImhleCIsInZhbHVlIiwicmVzdWx0IiwibW9kIiwibGVuZ3RoIiwidThhVG9IZXgiLCJiaXRMZW5ndGgiLCJpc1ByZWZpeGVkIiwiZW1wdHkiLCJNYXRoIiwiY2VpbCIsInN1YmFycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@polkadot/util/u8a/toHex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@polkadot/x-global/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@polkadot/x-global/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exposeGlobal: function() { return /* binding */ exposeGlobal; },\n/* harmony export */   extractGlobal: function() { return /* binding */ extractGlobal; },\n/* harmony export */   packageInfo: function() { return /* reexport safe */ _packageInfo_js__WEBPACK_IMPORTED_MODULE_0__.packageInfo; },\n/* harmony export */   xglobal: function() { return /* binding */ xglobal; }\n/* harmony export */ });\n/* harmony import */ var _packageInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./packageInfo.js */ \"(app-pages-browser)/./node_modules/@polkadot/x-global/packageInfo.js\");\n\n/** @internal Last-resort \"this\", if it gets here it probably would fail anyway */\nfunction evaluateThis(fn) {\n    return fn('return this');\n}\n/**\n * A cross-environment implementation for globalThis\n */\nconst xglobal = /*#__PURE__*/ (typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof global !== 'undefined'\n        ? global\n        : typeof self !== 'undefined'\n            ? self\n            : typeof window !== 'undefined'\n                ? window\n                : evaluateThis(Function));\n/**\n * Extracts a known global from the environment, applying a fallback if not found\n */\nfunction extractGlobal(name, fallback) {\n    // Not quite sure why this is here - snuck in with TS 4.7.2 with no real idea\n    // (as of now) as to why this looks like an \"any\" when we do cast it to a T\n    //\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return typeof xglobal[name] === 'undefined'\n        ? fallback\n        : xglobal[name];\n}\n/**\n * Expose a value as a known global, if not already defined\n */\nfunction exposeGlobal(name, fallback) {\n    if (typeof xglobal[name] === 'undefined') {\n        xglobal[name] = fallback;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QveC1nbG9iYWwvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QveC1nbG9iYWwvaW5kZXguanM/NTMyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBwYWNrYWdlSW5mbyB9IGZyb20gJy4vcGFja2FnZUluZm8uanMnO1xuLyoqIEBpbnRlcm5hbCBMYXN0LXJlc29ydCBcInRoaXNcIiwgaWYgaXQgZ2V0cyBoZXJlIGl0IHByb2JhYmx5IHdvdWxkIGZhaWwgYW55d2F5ICovXG5mdW5jdGlvbiBldmFsdWF0ZVRoaXMoZm4pIHtcbiAgICByZXR1cm4gZm4oJ3JldHVybiB0aGlzJyk7XG59XG4vKipcbiAqIEEgY3Jvc3MtZW52aXJvbm1lbnQgaW1wbGVtZW50YXRpb24gZm9yIGdsb2JhbFRoaXNcbiAqL1xuZXhwb3J0IGNvbnN0IHhnbG9iYWwgPSAvKiNfX1BVUkVfXyovICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IGdsb2JhbFRoaXNcbiAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZ2xvYmFsXG4gICAgICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IHNlbGZcbiAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHdpbmRvd1xuICAgICAgICAgICAgICAgIDogZXZhbHVhdGVUaGlzKEZ1bmN0aW9uKSk7XG4vKipcbiAqIEV4dHJhY3RzIGEga25vd24gZ2xvYmFsIGZyb20gdGhlIGVudmlyb25tZW50LCBhcHBseWluZyBhIGZhbGxiYWNrIGlmIG5vdCBmb3VuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEdsb2JhbChuYW1lLCBmYWxsYmFjaykge1xuICAgIC8vIE5vdCBxdWl0ZSBzdXJlIHdoeSB0aGlzIGlzIGhlcmUgLSBzbnVjayBpbiB3aXRoIFRTIDQuNy4yIHdpdGggbm8gcmVhbCBpZGVhXG4gICAgLy8gKGFzIG9mIG5vdykgYXMgdG8gd2h5IHRoaXMgbG9va3MgbGlrZSBhbiBcImFueVwiIHdoZW4gd2UgZG8gY2FzdCBpdCB0byBhIFRcbiAgICAvL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgIHJldHVybiB0eXBlb2YgeGdsb2JhbFtuYW1lXSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBmYWxsYmFja1xuICAgICAgICA6IHhnbG9iYWxbbmFtZV07XG59XG4vKipcbiAqIEV4cG9zZSBhIHZhbHVlIGFzIGEga25vd24gZ2xvYmFsLCBpZiBub3QgYWxyZWFkeSBkZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBvc2VHbG9iYWwobmFtZSwgZmFsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHhnbG9iYWxbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHhnbG9iYWxbbmFtZV0gPSBmYWxsYmFjaztcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@polkadot/x-global/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@polkadot/x-global/packageInfo.js":
/*!********************************************************!*\
  !*** ./node_modules/@polkadot/x-global/packageInfo.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   packageInfo: function() { return /* binding */ packageInfo; }\n/* harmony export */ });\nconst packageInfo = { name: '@polkadot/x-global', path: ( true) ? new URL(\"file:///C:/Users/crist/monkeyscanjump/download-manager/node_modules/@polkadot/x-global/packageInfo.js\").pathname.substring(0, new URL(\"file:///C:/Users/crist/monkeyscanjump/download-manager/node_modules/@polkadot/x-global/packageInfo.js\").pathname.lastIndexOf('/') + 1) : 0, type: 'esm', version: '13.4.3' };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QveC1nbG9iYWwvcGFja2FnZUluZm8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLHNCQUFzQixtQ0FBbUMsS0FBOEIsWUFBWSx1R0FBZSxnQ0FBZ0MsdUdBQWUsbUNBQW1DLENBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC94LWdsb2JhbC9wYWNrYWdlSW5mby5qcz9hNThhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBwYWNrYWdlSW5mbyA9IHsgbmFtZTogJ0Bwb2xrYWRvdC94LWdsb2JhbCcsIHBhdGg6IChpbXBvcnQubWV0YSAmJiBpbXBvcnQubWV0YS51cmwpID8gbmV3IFVSTChpbXBvcnQubWV0YS51cmwpLnBhdGhuYW1lLnN1YnN0cmluZygwLCBuZXcgVVJMKGltcG9ydC5tZXRhLnVybCkucGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKSArIDEpIDogJ2F1dG8nLCB0eXBlOiAnZXNtJywgdmVyc2lvbjogJzEzLjQuMycgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@polkadot/x-global/packageInfo.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@polkadot/x-textencoder/browser.js":
/*!*********************************************************!*\
  !*** ./node_modules/@polkadot/x-textencoder/browser.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextEncoder: function() { return /* binding */ TextEncoder; },\n/* harmony export */   packageInfo: function() { return /* reexport safe */ _packageInfo_js__WEBPACK_IMPORTED_MODULE_0__.packageInfo; }\n/* harmony export */ });\n/* harmony import */ var _polkadot_x_global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polkadot/x-global */ \"(app-pages-browser)/./node_modules/@polkadot/x-global/index.js\");\n/* harmony import */ var _fallback_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fallback.js */ \"(app-pages-browser)/./node_modules/@polkadot/x-textencoder/fallback.js\");\n/* harmony import */ var _packageInfo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./packageInfo.js */ \"(app-pages-browser)/./node_modules/@polkadot/x-textencoder/packageInfo.js\");\n\n\n\nconst TextEncoder = /*#__PURE__*/ (0,_polkadot_x_global__WEBPACK_IMPORTED_MODULE_1__.extractGlobal)('TextEncoder', _fallback_js__WEBPACK_IMPORTED_MODULE_2__.TextEncoder);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QveC10ZXh0ZW5jb2Rlci9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1EO0FBQ0s7QUFDVDtBQUN4QyxrQ0FBa0MsaUVBQWEsZ0JBQWdCLHFEQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QveC10ZXh0ZW5jb2Rlci9icm93c2VyLmpzP2I4MzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXh0cmFjdEdsb2JhbCB9IGZyb20gJ0Bwb2xrYWRvdC94LWdsb2JhbCc7XG5pbXBvcnQgeyBUZXh0RW5jb2RlciBhcyBGYWxsYmFjayB9IGZyb20gJy4vZmFsbGJhY2suanMnO1xuZXhwb3J0IHsgcGFja2FnZUluZm8gfSBmcm9tICcuL3BhY2thZ2VJbmZvLmpzJztcbmV4cG9ydCBjb25zdCBUZXh0RW5jb2RlciA9IC8qI19fUFVSRV9fKi8gZXh0cmFjdEdsb2JhbCgnVGV4dEVuY29kZXInLCBGYWxsYmFjayk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@polkadot/x-textencoder/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@polkadot/x-textencoder/fallback.js":
/*!**********************************************************!*\
  !*** ./node_modules/@polkadot/x-textencoder/fallback.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextEncoder: function() { return /* binding */ TextEncoder; }\n/* harmony export */ });\nclass TextEncoder {\n    encode(value) {\n        const count = value.length;\n        const u8a = new Uint8Array(count);\n        for (let i = 0; i < count; i++) {\n            u8a[i] = value.charCodeAt(i);\n        }\n        return u8a;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QveC10ZXh0ZW5jb2Rlci9mYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QveC10ZXh0ZW5jb2Rlci9mYWxsYmFjay5qcz9iYjY4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBUZXh0RW5jb2RlciB7XG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBjb25zdCB1OGEgPSBuZXcgVWludDhBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdThhW2ldID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdThhO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@polkadot/x-textencoder/fallback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@polkadot/x-textencoder/packageInfo.js":
/*!*************************************************************!*\
  !*** ./node_modules/@polkadot/x-textencoder/packageInfo.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   packageInfo: function() { return /* binding */ packageInfo; }\n/* harmony export */ });\nconst packageInfo = { name: '@polkadot/x-textencoder', path: ( true) ? new URL(\"file:///C:/Users/crist/monkeyscanjump/download-manager/node_modules/@polkadot/x-textencoder/packageInfo.js\").pathname.substring(0, new URL(\"file:///C:/Users/crist/monkeyscanjump/download-manager/node_modules/@polkadot/x-textencoder/packageInfo.js\").pathname.lastIndexOf('/') + 1) : 0, type: 'esm', version: '13.4.3' };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QveC10ZXh0ZW5jb2Rlci9wYWNrYWdlSW5mby5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sc0JBQXNCLHdDQUF3QyxLQUE4QixZQUFZLDRHQUFlLGdDQUFnQyw0R0FBZSxtQ0FBbUMsQ0FBTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvbGthZG90L3gtdGV4dGVuY29kZXIvcGFja2FnZUluZm8uanM/ZDZmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgcGFja2FnZUluZm8gPSB7IG5hbWU6ICdAcG9sa2Fkb3QveC10ZXh0ZW5jb2RlcicsIHBhdGg6IChpbXBvcnQubWV0YSAmJiBpbXBvcnQubWV0YS51cmwpID8gbmV3IFVSTChpbXBvcnQubWV0YS51cmwpLnBhdGhuYW1lLnN1YnN0cmluZygwLCBuZXcgVVJMKGltcG9ydC5tZXRhLnVybCkucGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKSArIDEpIDogJ2F1dG8nLCB0eXBlOiAnZXNtJywgdmVyc2lvbjogJzEzLjQuMycgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@polkadot/x-textencoder/packageInfo.js\n"));

/***/ })

});